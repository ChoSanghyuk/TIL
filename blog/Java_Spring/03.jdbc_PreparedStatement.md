# [Java] Jdbc 1편. Jdbc와 PreparedStatement



Java-Spring 기반으로 작업을하다보면, Db 연결 시에 주로 Prepared Statement, Mybatis, Jpa 이 셋 중에 하나를 골라서 사용하게 된다. 돌아가면서 사용하다보니 기본적인 설정과 동작법들을 매번 까먹고 다시 찾아보게 되는데, 이번 기회에 내용을 정리해 보고자 한다.



## Jdbc란



JDBC(Java Database Connectivity )는 자바에서 DBMS에 접근할 수 있도록 해주는 표준 API이다. Java 8 이상을 사용한다면, 기본적으로 Java를 설치했을 때 같이 설치되며, 다음 두 개의 패키지로 구성되어 있다. 

- java.sql
- javax.sql

JDBC는 Interface와 Class들로 이루어져 있는데, 이 JDBC API만을 가지고 DBMS에 접근할 수 있는 것은 아니다. 특정 DBMS에 작업하기 위해서는 해당 DBMS로 접근할 수 있는 JDBC 기반의 driver를 사용해야 한다. 다시 말해, JDBC는 JDBC Driver가 수행해야 할 역할만을 명시하는 Interface이며, 실제 작업에 대한 구현은 별도 Driver를 통해서 가능하다.



## Driver Import

특정 DBMS에 접근하기 위해서는 해당 Driver로 접근할 수 있는 Driver를 Java 프로그램에서 사용할 수 있게 해줘야 한다. 방법으로는 두가지가 있다.

1.. 첫번째로 Maven, Gradle 같이 빌드 도구를 사용한 프로젝트라면 의존성(depency)을 추가하여 설정할 수 있다. Maven 프로젝트를 예시로 들자면, pom.xml에 다음과 같이 의존성을 추가함으로 프로젝트 내에서 Hikari라는 driver을 사용할 수 있게 된다.

```xml
<dependencies>
    // ... 
    <dependency>
        <groupId>com.zaxxer</groupId>
        <artifactId>HikariCP</artifactId>
        <version>5.0.0</version>
    </dependency>
    // ...
</dependencies>
```



2.. 두번재로는 직접 Jar 파일을 다운받아 프로젝트의 Library에 넣어주는 것이다. 의존성 관리를 자동으로 해주는 빌드 도구 대신해서, 내가 직접 의존성 주입을 해준다고 생각하면 된다. 의존성 추가는 다음과 같은 step으로 진행할 수 있다.

1. Jar 파일을 다운받는다. Jar 파일은 의존maven 중앙 저장소(https://mvnrepository.com/) 혹은 driver의 공식 홈페이지에서 다운받을 수 있다. 
2. 프로젝트 폴더에 lib 폴더를 생성해준다. (이름은 아무거나 상관 없다)
3. 다운받은 Jar 파일을 lib 폴더에 넣어둔다.
4. 프로젝트를 우클릭해서 **Java Build Path**를 클릭한 다음, **Libraries** tab을 눌러준다.
5. 팝업창 우측의 **Add JARs** 버튼을 누른 후, lib에 넣어둔 Jar 파일을 찾아 추가해준다. 그리고 파업창 우측 하단의 Apply를 누른다.







## Prepared Statement



Prepared Statement는 java.sql 패키지 안에서 제공되는 클래스로, 다음 3가지의 중요 특징을 가진다.

1.. Prepared Statement는 **parameterized query** 형식이다.

parameterized query란, parameter 값 자리에 placeholder(자리표시)를 두고, 나중에 placeholder을 실제 값으로 바꾸는 SQL문을 의미한다. 



예를 들어서, 다음과 같이 실제 값들을 모두 쿼리 속에 포함하는 것이 아닌

```sql
select * from people_table where age > 20 and name ='조상혁'
```

실제 값들 대신에 **?**와 같은 placeholder를 parameter 자리에 위치 시키는 것이다.

```sql
select * from people_table where age > ? and name = ? 
```



Prepared Statement의 경우에는 **?**를 placeholder로써 사용하고 있다. 



2.. Prepared Statement는 **pre-compiled** SQL Statement이다.

 pre-compiled라는 것의 의미는 특정한 파라미터 값들로 구문이 실행되기 전에, DB 엔진에서 SQL 구문의 실행 준비를 미리 해두는 것을 의미한다. pre-compiled된 SQL 구문을 사용한다면, DB 엔진은 해당 구문으로 **최적화된 실행 계획**을 세울 수 있으며, 해당 실행 계획을 메모리해 저장해 둔다. 이로 인해서, 구문이 첫번째로 실행될 때에 한번만 최적화가 이루어 진다면, 그 다음의 파라미터 값들이 변경되어도 별도의 과정 없이 최적화된 실행을 할 수 있게 된다. 즉, 성능이 좋아진다. 



 참고로 최적화된 실행 계획이란, DB 구조, 가용 인덱스, 테이블 정보 등의 다양한 요소들을 고려해 가장 효과적인 쿼리 실행 방법을 찾아내는 것이다. 



3.. Prepared Statement는 **SQL injection 공격을 예방**한다. 





1. Parameterized queries: Prepared statements use placeholders or parameters in the SQL query, rather than embedding user-supplied data directly into the query string. The actual values of the parameters are then bound to the placeholders separately. This way, user-supplied data is treated as data, not as part of the SQL query, effectively preventing SQL injection attacks.
2. Automatic data type handling: Prepared statements automatically handle data type conversion for parameters, ensuring that user-supplied data is treated as the correct data type in the database. This eliminates the need for manual data type conversion, reducing the risk of SQL injection caused by incorrect data type handling.
3. Query compilation and caching: Prepared statements are compiled and cached by the database server, which can improve performance when the same query with different parameter values is executed multiple times. Since the query is only compiled once, it reduces the likelihood of SQL injection attacks, as the compiled query is reused with different parameter values.
4. Separation of SQL logic and data: Prepared statements separate the SQL query logic from the user-supplied data. This makes it easier to validate and sanitize user input, as the query itself remains unchanged. It also eliminates the need for manual escaping or sanitization of user input, reducing the risk of SQL injection vulnerabilities caused by incomplete or incorrect escaping or sanitization.
5. Prevention of concatenated queries: Prepared statements do not require concatenation of user-supplied data with the SQL query, as parameters are bound separately. Concatenating user input with SQL queries is a common source of SQL injection vulnerabilities, as it can allow malicious SQL code to be injected into the query. Prepared statements avoid this risk altogether.







Using these standard interfaces and classes, programmers can write applications that connect to databases, send queries written in structured query language (SQL), and process the results.







## 출처

 https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/

https://www.geeksforgeeks.org/how-to-use-preparedstatement-in-java/

https://www.techtarget.com/searchsecurity/feature/How-to-prevent-SQL-injection-with-prepared-statements

















