# 객체 지향적으로 코드 작성하기



회사에서 자바로 프로그램을 작성하던 중 문득 이런 생각이 들었다.

"나는 자바답게 프로그램을 작성하고 있는가"

자바는 객체 지향 프로그래밍 언어인데, 나는 객체 지향적으로 코드를 작성하기 위해 얼마나 노력하고 있었나 라는 생각이 들었다.

이번 기회에, 객체 지향적이란 무엇인지에 대해 다시 한번 복습해보고자 한다.



## 객체 지향 프로그래밍이란



객체란 우리 주변에 있는 모든 것을 말한다. 객체 지향적 프로그래밍이란, 객체가 데이터와 로직을 수행하는 함수를 가지게 하여 해당 객체들의 상호작용을 통해 프로그램을 설계하는 것이다. 즉, 프로그래밍 로직이 진행될 때, 기능이 아닌 객체가 중심이 되어 **어떤 객체**가 **무슨 일을 수행**할지에 초점을 맞춰서 설계하는 것이다.



반대되는 개념으로는 절차 지향적 프로그래밍이 있다. 절차 지향은 **기능중심**으로 바라보는 방식으로, 무엇을 어떤 절차로 할 지에 초점을 맞춰서 설계한다. 

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F998992425B3768AA23)



출처 : https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F998992425B3768AA23



객체 지향적 프로그래밍은 높은 재사용성, 생산성, 유지보수성을 가지기에 대규모 프로젝트에 용이, 하지만 소규모 프로젝트에서는 모든 것을 객체로 작성해야 해서 비효율 발생

객체 지향적 설계를 통해 소프트웨어를 개발하면 코드의 재사용을 통해 반복적인 코드를 최소화하고, 보다 유연하고 변경이 용이한 프로그램을 만들 수 있다는 사실을 알 수 있었습니다.



http://www.incodom.kr/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5#:~:text=Articles%20(Article%201)-,%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5(Object%20oriented)%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80%3F,%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%84%20%EB%A7%8C%EB%93%9C%EB%8A%94%20%EA%B2%83%EC%9D%84%20%EB%A7%90%ED%95%9C%EB%8B%A4.



## 객체 지향 프로그래밍의 특징

객체 지향 프로그래밍의 특징으로 다음과 같이 4가지가 있다.



### 추상화

추상화의 사전적 정의는 "주어진 문제나 시스템을 중요하고 관계 있는 부분만 분리해 내어 간결하고 이해하기 쉽게 만드는 작업" 이다(출처 :네이버사전). 이는, 핵심과 공통 부분을 따로 추출하는 것으로, 프로그래밍 관점으로는 **객체의 공통적인 속성과 기능을 추출하여 정의하는 것**이다. 

추상화의 방법으로는 크게 두 가지가 있는데, 상속과 인터페이스이다. 상속을 통해서 하위 클래스들의 공통적인 속성과 기능을 부모 클래스로 추출할 수 있으며, 인터페이스를 통해서 객체들이 수행해야 하는 핵심적인 역할들을 따로 규정할 수 있게 된다. 특히, 인터페이스는 역할만을 규정하고 실제 구현은 해당 인터페이스를 구현하는 각각의 객체하는 하도록 하여, 역할과 구현을 분리시킨다. 



### 상속

상속은 클래스 간 **공유될 수 있는 속성과 기능들을 상위 클래스로 추상화** 시켜 해당 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있게 하는 것이다. 이를 통해서, 반복적인 정의 없이 재사용할 수 있으며, 공유하는 속성과 기능에 간편하게 접근할 수 있게 된다. 



하지만 상속을 한다 해서, 부모의 모든 속성과 기능을 그대로 받는 것은 아니다. 부모 클래스에서는 private 접근 제어자를 통해 상속시키지 않을 속성과 메소드를 지정할 수 있다. 또한 자식 클래스에서도 부모의 모든 메소드를 그대로 받는 것이 아닌, 메서드 오버라이딩(method overriding)을 통해 내용을 재정의 할 수 있다.



### 다형성

다형성이란 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것을 의미한다. 좀 더 구체적으로, 상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있도록 하는 것이다. 예를 들어, Player 클래스를 BaseballPlayer, SoccerPlayer가 상속받는다 하겠다.

```java
Player player = new BaseballPlayer();
player = new SoccerPlayer();
```

위와 같이, player변수는 Player클래스 타입의 객체이지만, 참조하는 객체는 BassbllPlayer 타입이 될 수도 SoccerPlayer 타입이 될 수도 있다. 



이러한 다형성을 통해 코드를 작성했을 경우 두가지 장점이 있다. 



첫번째로, 하나의 타입만으로 하나의 타입만으로 여러 가지 타입의 객체를 참조할 수 있어 보다 **간편하고 유연하게 코드**를 작성하는 것이 가능해진다.

```java
// 예시 1. List
List<Player> list = new ArrayList<>();
list.add(new BaseballPlayer());
list.add(new SoccerPlayer());

// 예시 2 method
public void play(Player player){ // 매개변수에 BaseballPlayer, SoccerPlayer 타입 변수 사용 가능.
    // ...
}
```

이처럼 Player 타입을 받는 클래스, 메소드에 자식 클래스들을 넣을 수 있게 되면서, 더 유연하게 코드를 작성할 수 있게 된다. 



두번째로, 객체들간의 **결합도를 낮출 수** 있다. 

A라는 클래스가 B타입의 변수를 직접적으로 참조해 사용한다면,  A 클래스는 B 클래스에 의존한다 하고, 두 객체간 결합도가 높다 라고 말한다. 하지만 A 클래스가 B 타입만의 속성/메소드를 사용하는 것이 아닌 다른 타입들과의 공통적인 특징을 사용한다면, B 타입의 부모 클래스 혹은 인터페이스 타입을 참조함으로써 결합도를 낮출 수 있다. 



### 캡슐화

캡슐화는 서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것이다. 캡슐화는 **접근제어자**와 **getter/setter** 메서드를 통해서 구현이 가능하다.

priavate, default, protected, public의 접근제어자로 외부의 노출 정도를 정할 수 있으며, getter/setter 메소드를 통해서 직접적인 노출을 피한 속성들에 대해서 외부의 접근 수정을 허락할 수 있게 된다. 









https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95



## 객체 지향 프로그래밍의 5가지 설계 원칙

https://mangkyu.tistory.com/194

그렇다면 마지막으로 위와 같은 특징을 가진 객체 지향 프로그램을 잘 작성하기 위해서라면 어떻게 해야 할까. 객체 지향 프로그래밍에는 SOLID라 불리는 5가지 원칙이 있다. 



### 단일 책임의 원칙(SRP, Single Responsibility Principle)

단일 책임 원칙은 하나의 모듈이 하나의 책임을 가진다라고 주로 해석되지만, 실제의 의미는 모듈이 변경되는 이유가 한가지여야 함이다. 모듈이 변경되는 이유가 한가지가 되기 위해서는, 해당 모듈이 여러 액터들에 대해 책임을 가지지 않고, 오직 한 가지의 액터에 대해서만 책임을 져야 하는 것이다. 

어떤 하나의 모듈에서 여러가지의 요구사항을 모두 처리하고 있다면, 해당 모듈을 변경하게 되는 되는 이유는 요구사항의 수 만큼 있을 수 있다. 하지만, 단 하나의 역할만 가짐으로써 특정 요구사항의 변화가 있을 때, **명확한 하나의 수정 대상**을 가질 수 있다. 이는 곧 모듈을 응집도 높게 작성하게 되는 것이다.





### 개방 폐쇄 원칙 (Open-Closed Principle, OCP)

개방 폐쇄 원칙은 **확장에 열려있고, 수정에 닫혀있어야 한다**는 원칙이다. 확장에 열려있다는 것은 요구사항이 변경될 때 새로운 동작을 추가하여 기능을 확장할 수 있는 것이며, 수정에 닫혀있다는 것은 기존의 소스를 수정하지 않고, 동작의 추가 및 변경을 하는 것이다.

새로운 동작을 추가하여 기능을 확장하는 것은 직관적으로 이해되는 반면 기존의 소스를 수정하지 않고, 동작의 추가와 변경을 수행하는 것은 바로 와닿지는 않는다. 여기에서 **추상화**의 개념이 다시 사용된다. 

추상화없이 A라는 클래스가 B라는 클래스에 직접적으로 의존하는 경우, B 클래스에 변경이 있거나 새로운 C 클래스를 사용해야 할 경우, B와 C랑은 상관없는 A 클래스까지 수정이 필요해진다. 이렇게 결합도 높은 상태에서는 개방 폐쇄 원칙을 지키기 어렵다.

하지만, A 클래스가 처음부터 역할만을 추출한 Interface에 의존하고 있었다면, 아무리 많은 수의 구현 로직과 구현 클래스들이 생성되어도 A 클래스의 수정없이 사용 가능해진다.





### 인터페이스 분리 원칙 (Interface segregation principle, ISP)



### 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)



### 의존 역전 원칙 (Dependency Inversion Principle, DIP) 













**역할**과 **구현을 구분**하여 **객체들 간의 직접적인 결합을 피하고, 느슨한 관계 설정을 통해 보다 유연하고 변경이 용이한 프로그램 설계**

