# [Rust] 소유권



 흔히 Rust를 소개할 때 많이들 C와 비교해서 말하곤 한다. "C처럼 빠르지만, C의 메모리 취약점을 보완한 언어".

 우선, C는 왜 다른 언어들보다 빠른가? 많이 이유들이 있겠지만, 결정적인 이유 중 하나로 **Garbage Collector(쓰레기 수집기)**의 유무가 있다. Garbage Collector는 주기적으로 메모리를 검사하여, 더 이상 사용하지 않는 메모리(Garbage)를 해제 시켜준다. Java와 Python과 같은 응용 프로그래밍 언어들은 내장된 garbage collector가 있어서, 메모를 직접 해제 시켜주는 일 없이도 메모리 누수를 걱정할 필요가 없다. 하지만, 해당 작업은 리소스를 많이 잡아먹기 때문에, 개발자가 메모리를 직접 해제하는 C보다 느려지는 것이다.

 여기에서 C의 메모리 취약점이 나온다. 개발자가 더 이상 사용되지 않는 메모리를 전부 해제 시켜주지 않는다면, 누적된 메모리 누수로 프로그램에 장애가 생기거나, 메모리 관련 에러를 이용한 해킹에 노출이 될 수 있다. 하지만 사람은 누구나 실수를 하기 때문에, 모든 메모리를 신경써야 하는 C의 이러한 성격은 C의 단점으로 꼽힌다.

 Rust는 **OwnerShip(소유권)**이라는 개념을 통해서 Garbage Collector와 개발자의 수작업없이 메모리 해제를 가능하게 해, 빠르고 안전한 언어가 될 수 있었다. 



## Ownership 소개



### 3 Rules

앞서 말했듯이, ownership은 rust만의 독특한 메모리 해제 방식이다. ownership은 다음과 같은 3가지 규칙을 통해서 메모리를 해제시킨다.

1. 모든 값(value)는 소유자를 가진다.
2. 소유자는 단 한명이다.
3. 소유자가 Scope를 나가게 된다면, 값 또한 해제된다.



#### 소유권자와 메모리 해제

```rust
fn main() {

    {
        let owner1: String = String::from("value");
        println!("{}", owner);
    }
    // println!("{}", owner); // Error 
}
```

코드의 동작을 자세히 뜯어보면, 우선 "value"라는 값은 heap 영역에 저장되며, stack 영역에서 저장되는 owner1라는 변수가 "value"의 소유권자가 된다. 내부의 코드 블록이 끝이 난다면, owner1 변수는 stack에서 빠지게 되며, 소유권자를 잃은 "value" 값의 heap 메모리 영역도 같이 해제가 된다.



#### 유일한 소유권자

```rust
fn main() {

    let owner1: String = String::from("value");
    let owner2: String = owner1;

    // println!("{}", owner1);  // Error 
    println!("{}", owner2);
    
}

```

이 코드에서는 "value"의 값을 owner1 변수가 소유한 다음, owner2의 변수도 owner1와 같은 값을 가지게 된다. 이때, 소유권자는 단 한명만 존재해야 함으로, owner1는 "value" 값의 소유권을 잃게되며 owner2가 소유권을 가지게 된다. 이후로는 더 이상 소유권을 잃은 owner1은 사용할 수 없다.



## 소유권의 이전



위의 코드에서 보았듯이, 값에 대한 소유권자는 단 한명이기 때문에 특정 변수가 가지고 있는 값을 다른 변수가 가지기 위해서는 **소유권이 이전**되어야 한다. 이러한 소유권의 이전은 함수의 파라미터로 이용될 때에도 똑같이 적용된다.



```rust
fn main() {

    let owner1: String = String::from("value");
    print_my_value(owner1);
    // println!("{}", owner1);	// Error!
}

fn print_my_value(val : String) {
    println!("{}", val);
}
```

**print_my_value** 함수의 파라미터로 **owner1**을 사용하게 되면, **"value"** 값에 대한 소유권은 **owner1**에서 **val**로 이전하게 된다. 이때, **print_my_value**함수가 종료되면 **"value"** 값의 소유권자인 **val**이 Scope를 나게되는 것임으로 **"value"**의 메모리도 같이 해제되게 된다. 또한 owner1은 더 이상 어떠한 값도 가지지 못하므로, 더 이상 사용할 수 없게된다.



이처럼 단순히 함수의 파라미터 값으로 한번 사용 했다고, 더 이상 Local Scope 내의 변수를 더 이상 못 쓰게 되는 것을 방지하기 위해서는, 함수의 파라미터로 실제 값이 아닌 Reference를 넣어야 한다.

```rust
fn main() {

    let owner1: String = String::from("value");
    print_my_value(&owner1);
    println!("{}", owner1); // No Error
}

fn print_my_value(val : &String) {
    println!("{}", val);
}
```

print_my_value 함수가 실제의 값을 받아서 사용하는 것이 아니라, 값에 대한 Reference만을 파라미터로 받는 다면 print_my_value 함수에 파라미터로 Local 변수를 사용하여도 더 이상 소유권이 이전되지 않는다. 



또한 참조형을 파라미터로 입력한다고 해서, 실제 값을 조회만 할 수 있는 것이 아니라 값에 대한 변경도 가능하다

```rust
fn main() {

    let mut owner1: String = String::from("value");
    print_my_value(&owner1);        	// value
    change_my_value(&mut owner1);   
    println!("{}", owner1);             // value changed
}

fn print_my_value(val : &String) {
    println!("{}", val);
}

fn change_my_value(val : &mut String) {
    val.push_str(" changed");
}
```

**&mut** 타입으로 지정한다면, 변경 가능한 참조형이 되어서 소유권의 이전 없이도 직접적인 값에 대한 수정이 가능해진다.



## Value type, Reference type



이처럼, 하나의 value에 대해서는 한명의 소유권자만 존재해야 한다고 해서, 해당 변수에 하나의 변수만 접근할 수 있는 것이 아니다. Rust에서는 이를 구분짓기 위해서 **Value type**과 **Reference type**이 존재한다.



### Value Type

Value Type은 직접적으로 값을 저장하고 있으며, 해당 값의 소유권을 가지는 타입이다. 이것은 변수가 값에 대한 메모리 할당과 해제를 담당함을 뜻한다. 



### Reference Type

반면에, Reference Type은 값을 직접적으로 저장하고 있지 않으며, 값에 대한 reference 혹은 pointer을 저장하고 있는 타입이다. 이것은 해당 데이터의 소유권과 분리되었음을 뜻한다. 



https://www.tutorialsteacher.com/csharp/csharp-value-type-and-reference-type



In Rust, values can be categorized as either "value types" or "reference types".

A value type is a type **whose data is directly stored in a variable**, and **ownership** of that data is tied to the variable that holds it. This means that the variable is r**esponsible for allocating and deallocating memory for the data** it holds. Examples of value types in Rust include integers, booleans, floating-point numbers, characters, and other primitive types.

On the other hand, a **reference typ**e is a type that does not directly store its own data, but instead **stores a reference or pointer to data** that is stored elsewhere in memory. This means that **ownership of the data is separate** from the reference that points to it. The reference itself does not own the data it points to, but instead borrows or shares ownership of that data with other references that may also be pointing to it. Examples of reference types in Rust include references (`&T`), mutable references (`&mut T`), and smart pointers like `Box<T>` and `Rc<T>`.

**When a value is passed to a function** or assigned to a variable in Rust, it is typically **moved or copied**. In the case of value types, ownership of the data is transferred to the receiving variable or function, **while** in the case of **reference type**s, **ownership remains with the original owner**, and the reference is simply borrowed for the scope of the variable or function that uses it.

Overall, understanding the distinction between value types and reference types is crucial to writing safe and efficient Rust code, as it helps you manage ownership and borrowing of data, and avoid common memory-related bugs like use-after-free or double free errors.



stack, heap, 







```rust
let s1: &str = "hi";  // If the string won’t be edited
```

- 이때의 소유



You are correct that in Rust, every value must have an owner, and that ownership is a fundamental concept in Rust's memory management system.

In the case of a string literal like `"hello"`, the value itself is not owned by any variable or structure in your program. Instead, it is a static value that is baked into your program's binary at compile time.

This means that the string literal `"hello"` does not have an owner in the traditional sense, because it does not exist as a dynamic value that is created at runtime and stored on the heap. Instead, it is a compile-time constant that is loaded into memory when the program starts running, and remains in memory for the entire duration of the program's execution.

Because string literals are not dynamically allocated on the heap, they do not require ownership or deallocation. They have a fixed lifetime and are simply loaded into memory when the program starts running, and remain in memory until the program exits.







-- binary 

In computing, a program's binary (also called the binary code or executable file) is the machine-readable representation of a compiled computer program. It consists of a sequence of binary digits (bits) that can be executed directly by a computer's processor. The binary file typically contains instructions for the computer to perform specific operations, as well as any static data or resources needed by the program at runtime.

The process of compiling a program involves translating the program's source code into machine code, which is then saved as a binary file. This binary file can then be loaded and executed by the computer's operating system or runtime environment.

In the context of Rust, when you compile a Rust program, the Rust compiler translates your source code into machine code and generates a binary file that can be run on a specific platform, such as a Windows or Linux operating system. The resulting binary file contains the program's instructions and any data or resources that were compiled into the program, such as string literals, static variables, and other constants. When you run the program, the operating system loads the binary file into memory and executes the instructions in the file.





In Rust, memory is managed through a combination of stack, heap, and binary memory.

The stack is a region of memory that stores data for function calls and local variables. When a function is called, its local variables and function arguments are pushed onto the stack. As the function returns, the stack is "unwound" and the memory used by the local variables is released. The size of the stack is fixed at compile-time, which means that the amount of memory allocated for the stack cannot change at runtime. This makes the stack fast and efficient, but also limits the amount of memory that can be used for local variables.

The heap is a region of memory that can be dynamically allocated at runtime. Unlike the stack, the heap can grow and shrink as needed, allowing for more flexible memory allocation. In Rust, heap-allocated memory is managed through the use of smart pointers such as `Box<T>` and `Rc<T>`. These smart pointers allow you to allocate memory on the heap and automatically manage its lifetime and ownership.

The binary memory refers to the memory used by the compiled program itself, including any static data or resources needed by the program at runtime. This includes things like string literals, global variables, and constants, which are stored in the program's binary file. When the program is loaded into memory, the binary memory is loaded into a read-only data segment, which is separate from the stack and heap.

In Rust, memory safety is enforced through a system of ownership and borrowing. Each value in Rust has an owner, which is responsible for managing the value's lifetime and freeing its memory when it is no longer needed. Ownership can be transferred between variables using moves, or shared between variables using references. When a variable goes out of scope, its memory is automatically freed by Rust's built-in memory management system, which ensures that memory leaks and use-after-free errors are avoided.





The heap data structure is used for dynamic allocation in programming languages because it allows for flexible memory management at runtime. Unlike the stack, which has a fixed size and can be quickly allocated and deallocated but has limited capacity, the heap can grow and shrink as needed to accommodate data of arbitrary size and complexity.

When you allocate memory on the heap, the operating system assigns a block of memory from a pool of available memory managed by the system. This block of memory is not necessarily contiguous, meaning it can be spread across multiple physical memory pages. When you release the memory back to the system, it can be returned to the pool of available memory to be used by other programs.

The heap is especially useful for managing data structures that can change size at runtime, such as strings, arrays, and linked lists. When you allocate memory for a data structure on the heap, you can dynamically resize it as needed, allowing you to adapt to changing data requirements without having to worry about running out of space.

However, managing memory on the heap also introduces some overhead and potential problems, such as fragmentation, memory leaks, and invalid pointers. To mitigate these issues, modern programming languages provide various memory management techniques, such as garbage collection, reference counting, and manual memory management, each with its own trade-offs and benefits. Rust, for example, uses a combination of ownership, borrowing, and lifetimes to ensure safe and efficient memory management without the need for garbage collection.





You're correct that heaps are often used to search for the top priority element, but in the context of dynamic memory allocation, the priority is not necessarily related to the value of the data being stored. Instead, the priority refers to the order in which memory is allocated and deallocated from the heap.

In Rust, the heap allocator uses a memory allocation algorithm that is designed to minimize fragmentation and efficiently allocate and deallocate memory blocks of various sizes. The allocator maintains a list of free memory blocks of different sizes, and when you allocate memory on the heap, it searches for a block that is large enough to accommodate the requested size.

The allocator may prioritize certain memory blocks based on their size, location, or other factors, to optimize for performance or memory usage. For example, it may prioritize smaller memory blocks to minimize fragmentation, or larger blocks to reduce the number of allocations required.

Similarly, when you deallocate memory, the allocator may prioritize certain blocks for reuse based on their size, location, or other factors, to reduce fragmentation or improve performance.

While the concept of priority is different in the context of memory allocation compared to data structures, the heap data structure is still used as the underlying mechanism for allocating and deallocating memory on the heap.







### fragmentation 



Fragmentation refers to the phenomenon where memory becomes divided into small, non-contiguous blocks, resulting in inefficient use of available memory.

In the context of memory allocation, fragmentation can occur when memory is allocated and deallocated in a way that leaves small gaps between allocated blocks. These gaps, also known as "holes," cannot be used for further allocations, even if the total amount of free memory is sufficient. Over time, these holes can accumulate, leading to a situation where there is plenty of free memory, but it is not available in a single, contiguous block.

Fragmentation can have a negative impact on the performance of programs that frequently allocate and deallocate memory. For example, if a program repeatedly requests small amounts of memory, the allocator may be forced to search for small holes in the memory pool to accommodate each request. This can be time-consuming and may lead to increased memory usage, as the allocator may be forced to allocate larger blocks than necessary to avoid small holes.

There are several types of fragmentation, including internal fragmentation, where allocated memory blocks are larger than necessary, resulting in wasted space within each block, and external fragmentation, where there are gaps between allocated blocks that cannot be used for further allocations. Different memory allocation algorithms and techniques, such as memory pooling and garbage collection, can be used to mitigate fragmentation and improve memory usage efficiency.











