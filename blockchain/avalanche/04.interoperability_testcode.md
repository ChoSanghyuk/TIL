# Avalanche Interoperability Test Code



Avalanche ICM-Contract Source에 기반하여, 로컬에 세팅해 둔 커스텀 네트워크애 상호운용성을 테스트해보는 코드.

https://github.com/ava-labs/icm-contracts



```go
// abi-bindings > go > ictt > ictt_test.go 위치에 작성
package ictt

import (
	"context"
	"math/big"
	"os"
	"testing"
	"time"

	"github.com/ava-labs/avalanchego/ids"
	erc20tokenhome "github.com/ava-labs/icm-contracts/abi-bindings/go/ictt/TokenHome/ERC20TokenHome"
	erc20tokenremote "github.com/ava-labs/icm-contracts/abi-bindings/go/ictt/TokenRemote/ERC20TokenRemote"
	exampleerc20decimals "github.com/ava-labs/icm-contracts/abi-bindings/go/ictt/mocks/ExampleERC20Decimals"
	teleportermessenger "github.com/ava-labs/icm-contracts/abi-bindings/go/teleporter/TeleporterMessenger"
	teleporterregistry "github.com/ava-labs/icm-contracts/abi-bindings/go/teleporter/registry/TeleporterRegistry"
	"github.com/ava-labs/icm-contracts/tests/interfaces"
	"github.com/ava-labs/icm-contracts/tests/utils"
	"github.com/ava-labs/libevm/common"
	"github.com/ava-labs/libevm/crypto"
	"github.com/ava-labs/subnet-evm/accounts/abi/bind"
	"github.com/ava-labs/subnet-evm/ethclient"
	"github.com/onsi/gomega"
)

func TestERC20TokenHomeERC20TokenRemote(t *testing.T) {
	gomega.RegisterTestingT(t)

	// whether send or not
	var isSend bool = true

	// common
	tokenDecimals := uint8(6)
	// SOURCE CHAIN
	var mockERC20TokenAddress common.Address = common.Address{} //common.HexToAddress("0xe17bDC68168d07c1776c362d596adaa5d52A1De7") //
	var mockERC20TokentokenName string = "Mock Token"
	var mockERC20TokenSymbol string = "EXMP"
	var mockERC20Token *exampleerc20decimals.ExampleERC20Decimals
	var homeERC20TokenAddress common.Address = common.Address{} //common.HexToAddress("0xF5f1f185cF359dC48469e410Aeb6983cD4DC5812") //common.Address{} //
	var homeERC20Token *erc20tokenhome.ERC20TokenHome

	// DESTINATION CHAIN
	var remoteERC20TokenAddress common.Address = common.Address{} //common.HexToAddress("0xcad00692aa206527F64Fc683dB0f711dc49CB176") // common.Address{} //
	var remoteERC20Token *erc20tokenremote.ERC20TokenRemote
	var recipientAddress common.Address = common.Address{} //common.HexToAddress("0x5b02E1d30b066D3f5c855C5566f63ad1F6E095E0") //common.Address{}

	// parameter setting
	chain1Client, err := ethclient.Dial("http://127.0.0.1:53896/ext/bc/2syE518fxK6R9XLLcamagg9CFiKB7Bf6WvMTh7KYfHZsrhVBEv/rpc")
	if err != nil {
		t.Fatalf("Failed to create client of chain1: %v", err)
	}
	chain1WSClient, err := ethclient.Dial("ws://127.0.0.1:53896/ext/bc/2syE518fxK6R9XLLcamagg9CFiKB7Bf6WvMTh7KYfHZsrhVBEv/ws")
	if err != nil {
		t.Fatalf("Failed to create websocket client of chain1: %v", err)
	}
	chain1SenderKey, err := crypto.HexToECDSA("56289e99c94b6912bfc12adc093c9b51124f0dc54ac7a766b2bc5ccf558d8027")
	if err != nil {
		t.Fatalf("Failed to convert sender key to ECDSA: %v", err)
	}
	chain1SenderAddress := crypto.PubkeyToAddress(chain1SenderKey.PublicKey)
	chain1Opts, err := bind.NewKeyedTransactorWithChainID(chain1SenderKey, big.NewInt(1))
	if err != nil {
		t.Fatalf("Failed to create transactor: %v", err)
	}

	// chain2 setting
	chain2Client, err := ethclient.Dial("http://127.0.0.1:54337/ext/bc/2oAyCEp6RKQVQvfgvfHjVywpULexzfhsXTsqKBQv9UgKGZwKVb/rpc")
	if err != nil {
		t.Fatalf("Failed to create client of chain1: %v", err)
	}
	chain2WSClient, err := ethclient.Dial("ws://127.0.0.1:54337/ext/bc/2oAyCEp6RKQVQvfgvfHjVywpULexzfhsXTsqKBQv9UgKGZwKVb/ws")
	if err != nil {
		t.Fatalf("Failed to create websocket client of chain2: %v", err)
	}
	chain2SenderKey, err := crypto.HexToECDSA("56289e99c94b6912bfc12adc093c9b51124f0dc54ac7a766b2bc5ccf558d8027")
	if err != nil {
		t.Fatalf("Failed to convert sender key to ECDSA: %v", err)
	}
	chain2SenderAddress := crypto.PubkeyToAddress(chain2SenderKey.PublicKey)
	chain2Opts, err := bind.NewKeyedTransactorWithChainID(chain2SenderKey, big.NewInt(2))
	if err != nil {
		t.Fatalf("Failed to create transactor: %v", err)
	}

	// network setting
	sourceL1SubnetID, err := ids.FromString("2W9boARgCWL25z6pMFNtkCfNA5v28VGg9PmBgUJfuKndEdhrvw")
	if err != nil {
		t.Fatalf("Failed to convert string to ID: %v", err)
	}
	sourceL1BlockchainID, err := ids.FromString("2syE518fxK6R9XLLcamagg9CFiKB7Bf6WvMTh7KYfHZsrhVBEv")
	if err != nil {
		t.Fatalf("Failed to convert string to ID: %v", err)
	}

	sourceL1 := interfaces.L1TestInfo{
		SubnetID:                     sourceL1SubnetID,
		BlockchainID:                 sourceL1BlockchainID,
		NodeURIs:                     []string{"http://127.0.0.1:53896"},
		WSClient:                     chain1WSClient,
		RPCClient:                    chain1Client,
		EVMChainID:                   big.NewInt(1),
		RequirePrimaryNetworkSigners: false,
	}

	destinationL1SubnetID, err := ids.FromString("2H73Ef5b5CfpR6Sw6Gq4qkyVF9hqQqYYEF9khuGKVPNJE5hFmg")
	if err != nil {
		t.Fatalf("Failed to convert string to ID: %v", err)
	}
	destinationL1BlockchainID, err := ids.FromString("2oAyCEp6RKQVQvfgvfHjVywpULexzfhsXTsqKBQv9UgKGZwKVb")
	if err != nil {
		t.Fatalf("Failed to convert string to ID: %v", err)
	}

	destinationL1 := interfaces.L1TestInfo{
		SubnetID:                     destinationL1SubnetID,
		BlockchainID:                 destinationL1BlockchainID,
		NodeURIs:                     []string{"http://127.0.0.1:54337"},
		WSClient:                     chain2WSClient,
		RPCClient:                    chain2Client,
		EVMChainID:                   big.NewInt(2),
		RequirePrimaryNetworkSigners: false,
	}

	// teleporter setting
	chain1TeleporterRegistryAddress := common.HexToAddress("0x4585a6649CBe4A95DB74A88674b4C3f78cCBA2A7")
	chain1TeleporterRegistry, err := teleporterregistry.NewTeleporterRegistry(chain1TeleporterRegistryAddress, chain1Client)
	if err != nil {
		t.Fatalf("Failed to create teleporter registry: %v", err)
	}
	chain1TeleporterMessengerAddress := common.HexToAddress("0x253b2784c75e510dD0fF1da844684a1aC0aa5fcf")
	chain1TeleporterMessenger, err := teleportermessenger.NewTeleporterMessenger(chain1TeleporterMessengerAddress, chain1Client)
	if err != nil {
		t.Fatalf("Failed to create teleporter messenger: %v", err)
	}

	chain2TeleporterRegistryAddress := common.HexToAddress("0x4585a6649CBe4A95DB74A88674b4C3f78cCBA2A7")
	chain2TeleporterRegistry, err := teleporterregistry.NewTeleporterRegistry(chain2TeleporterRegistryAddress, chain2Client)
	if err != nil {
		t.Fatalf("Failed to create teleporter registry: %v", err)
	}
	chain2TeleporterMessengerAddress := common.HexToAddress("0x253b2784c75e510dD0fF1da844684a1aC0aa5fcf")
	chain2TeleporterMessenger, err := teleportermessenger.NewTeleporterMessenger(chain2TeleporterMessengerAddress, chain2Client)
	if err != nil {
		t.Fatalf("Failed to create teleporter messenger: %v", err)
	}

	teleporter := utils.TeleporterTestInfo{
		sourceL1BlockchainID: {
			TeleporterRegistry:         chain1TeleporterRegistry,
			TeleporterRegistryAddress:  chain1TeleporterRegistryAddress,
			TeleporterMessenger:        chain1TeleporterMessenger,
			TeleporterMessengerAddress: chain1TeleporterMessengerAddress,
		},
		destinationL1BlockchainID: {
			TeleporterRegistry:         chain2TeleporterRegistry,
			TeleporterRegistryAddress:  chain2TeleporterRegistryAddress,
			TeleporterMessenger:        chain2TeleporterMessenger,
			TeleporterMessengerAddress: chain2TeleporterMessengerAddress,
		},
	}

	// aggregator setting
	aggregator := newSignatureAggregator()
	defer aggregator.Shutdown()

	// deploy mock ERC20 token
	if mockERC20TokenAddress == (common.Address{}) || mockERC20TokentokenName == "" || mockERC20TokenSymbol == "" {
		tokenAddress, tx, exampleERC20, err := exampleerc20decimals.DeployExampleERC20Decimals(chain1Opts, chain1Client, tokenDecimals)

		t.Logf("mockERC20TokenAddress: %s", tokenAddress)
		t.Logf("mockERC20TokenTxHash: %s", tx.Hash())

		_, err = utils.WaitMined(context.Background(), chain1Client, tx.Hash())
		if err != nil {
			t.Fatalf("Failed to wait for transaction to be mined: %v", err)
		}

		mockERC20Token = exampleERC20

		tokenName, err := exampleERC20.Name(&bind.CallOpts{})
		if err != nil {
			t.Fatalf("Failed to get token name: %v", err)
		}
		tokenSymbol, err := exampleERC20.Symbol(&bind.CallOpts{})
		if err != nil {
			t.Fatalf("Failed to get token symbol: %v", err)
		}

		t.Logf("mockERC20TokentokenName: %s", tokenName)
		t.Logf("mockERC20TokenSymbol: %s", tokenSymbol)
		mockERC20TokenAddress = tokenAddress
		mockERC20TokentokenName = tokenName
		mockERC20TokenSymbol = tokenSymbol
	}
	if mockERC20Token == nil {
		mockERC20Token, err = exampleerc20decimals.NewExampleERC20Decimals(mockERC20TokenAddress, chain1Client)
		if err != nil {
			t.Fatalf("Failed to create ExampleERC20Decimals: %v", err)
		}
	}

	if homeERC20TokenAddress == (common.Address{}) {
		implAddress, tx, erc20TokenHome, err := erc20tokenhome.DeployERC20TokenHome(
			chain1Opts,
			chain1Client,
			common.HexToAddress("0x4585a6649CBe4A95DB74A88674b4C3f78cCBA2A7"), // TODO: add teleporter registry address (= ICM registry)
			chain1SenderAddress, // TODO: add teleporter manager address
			big.NewInt(1),       //LatestTeleporterVersion
			mockERC20TokenAddress,
			tokenDecimals,
		)
		if err != nil {
			t.Fatalf("Failed to deploy ERC20TokenHome: %v", err)
		}
		_, err = utils.WaitMined(context.Background(), chain1Client, tx.Hash())
		if err != nil {
			t.Fatalf("Failed to wait for transaction to be mined: %v", err)
		}

		homeERC20Token = erc20TokenHome
		t.Logf("homeERC20TokenAddress: %s", implAddress)
		t.Logf("homeERC20TokenTxHash: %s", tx.Hash())
		homeERC20TokenAddress = implAddress
	}
	if homeERC20Token == nil {
		homeERC20Token, err = erc20tokenhome.NewERC20TokenHome(homeERC20TokenAddress, chain1Client)
		if err != nil {
			t.Fatalf("Failed to create ERC20TokenHome: %v", err)
		}
	}

	if remoteERC20TokenAddress == (common.Address{}) {
		implAddress, tx, erc20TokenRemote, err := erc20tokenremote.DeployERC20TokenRemote(
			chain2Opts,
			chain2Client,
			erc20tokenremote.TokenRemoteSettings{
				TeleporterRegistryAddress: common.HexToAddress("0x4585a6649CBe4A95DB74A88674b4C3f78cCBA2A7"), // TODO: add teleporter registry address (= ICM registry)
				TeleporterManager:         chain2SenderAddress,
				MinTeleporterVersion:      big.NewInt(1),
				TokenHomeBlockchainID:     sourceL1BlockchainID, //[32]byte{1},
				TokenHomeAddress:          homeERC20TokenAddress,
				TokenHomeDecimals:         tokenDecimals,
			},
			mockERC20TokentokenName,
			mockERC20TokenSymbol,
			tokenDecimals,
		)
		if err != nil {
			t.Fatalf("Failed to deploy ERC20TokenRemote: %v", err)
		}
		_, err = utils.WaitMined(context.Background(), chain2Client, tx.Hash())
		if err != nil {
			t.Fatalf("Failed to wait for transaction to be mined: %v", err)
		}

		remoteERC20Token = erc20TokenRemote
		t.Logf("remoteERC20TokenAddress: %s", implAddress)
		t.Logf("remoteERC20TokenTxHash: %s", tx.Hash())
		remoteERC20TokenAddress = implAddress

		utils.RegisterTokenRemoteOnHome(
			context.Background(),
			teleporter,
			sourceL1,
			homeERC20TokenAddress,
			destinationL1,
			remoteERC20TokenAddress,
			big.NewInt(0),
			big.NewInt(1),
			false,
			chain1SenderKey,
			aggregator,
		)

		// wait for relaying
		time.Sleep(10 * time.Second)
		// t.Logf("collateralNeeded: %s", collateralNeeded)
	}
	if remoteERC20Token == nil {
		remoteERC20Token, err = erc20tokenremote.NewERC20TokenRemote(remoteERC20TokenAddress, chain2Client)
		if err != nil {
			t.Fatalf("Failed to create ERC20TokenRemote: %v", err)
		}
	}

	if recipientAddress == (common.Address{}) {
		// Generate new recipient to receive transferred tokens
		recipientKey, err := crypto.GenerateKey()
		if err != nil {
			t.Fatalf("Failed to generate recipient key: %v", err)
		}
		recipientAddress = crypto.PubkeyToAddress(recipientKey.PublicKey)
		t.Logf("recipientKey: %s", recipientKey)
		t.Logf("recipientAddress: %s", recipientAddress)
	}
	balance, err := remoteERC20Token.BalanceOf(&bind.CallOpts{}, recipientAddress)
	if err != nil {
		t.Fatalf("Failed to get balance of recipient: %v", err)
	}
	t.Logf("initial balance: %s", balance)

	if isSend {
		// Send tokens from C-Chain to recipient on L1 A
		input := erc20tokenhome.SendTokensInput{
			DestinationBlockchainID:            destinationL1BlockchainID,
			DestinationTokenTransferrerAddress: remoteERC20TokenAddress,
			Recipient:                          recipientAddress,
			PrimaryFeeTokenAddress:             mockERC20TokenAddress,
			PrimaryFee:                         big.NewInt(0),
			SecondaryFee:                       big.NewInt(0),
			RequiredGasLimit:                   utils.DefaultERC20RequiredGas,
		}
		amount := new(big.Int).Mul(big.NewInt(1e18), big.NewInt(13))

		receipt, transferredAmount := utils.SendERC20TokenHome(
			context.Background(),
			sourceL1,
			homeERC20Token,
			homeERC20TokenAddress,
			mockERC20Token,
			input,
			amount,
			chain1SenderKey,
		)

		t.Logf("SendERC20TokenHome tx hash: %s\n", receipt.TxHash)
		// Relay the message to L1 A and check for message delivery
		// receipt = teleporter.RelayTeleporterMessage(
		// 	context.Background(),
		// 	receipt,
		// 	sourceL1,
		// 	destinationL1,
		// 	true,
		// 	chain1SenderKey,
		// 	nil,
		// 	aggregator,
		// )
		// t.Logf("RelayTeleporterMessage tx hash: %s\n", receipt.TxHash)
		// utils.CheckERC20TokenRemoteWithdrawal(
		// 	context.Background(),
		// 	remoteERC20Token,
		// 	receipt,
		// 	recipientAddress,
		// 	transferredAmount,
		// )
		t.Logf("transferredAmount: %s", transferredAmount)

		// wait for relaying
		time.Sleep(10 * time.Second)
	}
	// Check that the recipient received the tokens
	balance, err = remoteERC20Token.BalanceOf(&bind.CallOpts{}, recipientAddress)
	if err != nil {
		t.Fatalf("Failed to get balance of recipient: %v", err)
	}
	t.Logf("final balance: %s", balance)
}

func newSignatureAggregator() *utils.SignatureAggregator {
	home := os.Getenv("HOME")
	os.Setenv("SIG_AGG_PATH", home+"/.teleporter-deps/icm-services/signature-aggregator")
	var subnetIDs []ids.ID = []ids.ID{
		ids.ID{1},
		ids.ID{2},
	}

	return utils.NewSignatureAggregator(
		"http://127.0.0.1:9650", // 여기는 primary 쓰는 듯?
		subnetIDs,
	)
}

/* fake case
tx: 0xa7fd2c4da7f7e3a8a192d5610b8274716c2b9665c2c13d399197e9298345d053
homeERC20TokenAddress: 0x789a5FDac2b37FCD290f12924382297A6AE65860
remoteERC20TokenAddress: 0x17aB05351fC94a1a67Bf3f56DdbB941aE6c63E25
*/

```

