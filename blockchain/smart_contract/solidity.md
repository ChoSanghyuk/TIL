# Solidity



## Layout of a Solidity Source File



### SPDX License Identifier

- 배경

  - 소스 코드의 공개는 코드의 신뢰도를 높여줄 수 있지만, 저작권 같은 법적인 문제를 야기하기도 함

    => Solidity compiler encourages the use of machine-readable SPDX license identifiers

- 개요

  - 오픈 소스 소트웨어의 라이선스를 표기하기 위한 표준화된 방식

    => 소프트웨어의 라이선스 정보를 명확하게, 일관되게 표현

  - Identifier는 소스 코드 내 주석 등에 표기되어, 해당 소프트웨어 라이선스 정보를 명확히 전달

  - SPDX 웹사이트에서 제공하는 라이선스 리스트에 따라 사용

  - The compiler does not validate that the license is part of the list allowed by SPDX, but it does include the supplied string in the bytecode metadata

- 작성

  - The comment is recognized by the compiler anywhere in the file at the file level, but it is recommended to put it at the top of the file
    - ex) `// SPDX-License-Identifier: MIT`
  - In case you do not want to specify a license or if the source code is not open-source
    - use the special value `UNLICENSED`
      - != `UNLICENSE` (grants all rights to everyone)



## Contracts



### Creating Contracts

- A constructor is optional
- Only one constructor is allowed, which means overloading is not supported
- The deployed code does not include the constructor code or internal functions only called from the constructor



### Visibility and Getters

#### State Variable Visibility

- 종류

  - public

    - compiler automatically generates getter functions for them

      => allows other contracts to read their values

    - Setter functions are not generated so other contracts cannot directly modify their values
    - 외부에서의 접근은 getter을 자동으로 호출하여 접근, 내부에서의 접근은 storage로부터 직접 접근함

  - internal

    - can only be accessed from within the contract they are defined in and **in derived contracts**
      - cannot be accessed externally
    - default visibility level

  - private

    - can only be accessed from within the contract they are defined in

- 위치

  - after the type
  - ex) `uint public data;`

#### Function Visibility

- 종류
  - external
    - part of the contract interface, which means they can be called from other contracts and via transactions
    - 내부에서 호출하기 위해서는 `this.{함수}`와 같은 접근 필요
  - public
    - part of the contract interface and can be either called internally or via message calls.
  - internal
    - can only be accessed from within the current contract or contracts deriving from it
    - cannot be accessed externally
    -  Since they are not exposed to the outside through the contract’s ABI, they can **take parameters of internal types like mappings or storage references**.
  - private
    - like internal ones but they are not visible in derived contracts
- 위치
  - between parameter list and return parameter list
  - ex) `function setData(uint a) internal { data = a; }`

#### Getter Functions

- 개요

  - The compiler automatically creates getter functions for all **public** state variables
  - The getter functions have external visibility
  - ex) `uint public data = 42;` 선언 시 자동으로 `function data() external view returns (uint) {return data}` 라는 함수가 생성됨

- 복합 타입

  - can only retrieve single elements of the array via the generated getter function
    - <=  avoid high gas costs when returning an entire array.
  - You can use arguments to specify which individual element to return
  - If you want to return an entire array in one call, then you need to write a function

  ```solidity
  // SPDX-License-Identifier: GPL-3.0
  pragma solidity >=0.4.16 <0.9.0;
  
  contract arrayExample {
      // public state variable
      uint[] public myArray;
  
      // Getter function generated by the compiler
      /*
      function myArray(uint i) public view returns (uint) {
          return myArray[i];
      }
      */
  
      // function that returns entire array
      function getArray() public view returns (uint[] memory) {
          return myArray;
      }
  }
  ```
  
  - 복합타입이 포함된 struct 타입에 대해서는, 복합필드를 제외한 필드들만 자동 getter로 반환함

### Function Modifiers

- 개요
  - used to change the behavior of functions in a declarative way. 
    - ex) you can use a modifier to automatically check a condition prior to executing the function.
- 특징
  - inheritable properties of contracts
    - if they are marked `virtual`, modifier can be overridden by derived contracts
  - It is only possible to use modifiers defined in the current contract or its base contracts. 
    - Modifiers can also be defined in libraries but their use is limited to functions of the same library.
    - If you want to access a modifier `m` defined in a contract `C`, you can use `C.m` to reference it without virtual lookup. 
  - cannot implicitly access or change the arguments and return values of functions they modify
    - Their values can only be passed to them explicitly at the point of invocation
  - Symbols introduced in the modifier are not visible in the function (as they might change by overriding).
    - <=> Arbitrary expressions are allowed for modifier arguments and in this context, all symbols visible from the function are visible in the modifier.
  - Explicit returns from a modifier or function body only leave the current modifier or function body
    - Return variables are assigned and control flow continues after the `_` in the preceding modifier
    - An explicit return from a modifier with `return;` does not affect the values returned by the function
    - The modifier can, however, choose not to execute the function body at all and in that case the return variables are set to their default values
- 사용
  - Multiple modifiers are applied to a function by specifying them in a whitespace-separated list and are evaluated in the order presented.
  - The placeholder statement (`_`) is used to denote where the body of the function being modified should be inserted
    - The `_` symbol can appear in the modifier multiple times. Each occurrence is replaced with the function body, and the function returns the return value of the final occurrence.

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.1 <0.9.0;

contract owned {
    constructor() { owner = payable(msg.sender); }
    address payable owner;

    // This contract only defines a modifier but does not use
    // it: it will be used in derived contracts.
    // The function body is inserted where the special symbol
    // `_;` in the definition of a modifier appears.
    // This means that if the owner calls this function, the
    // function is executed and otherwise, an exception is
    // thrown.
    modifier onlyOwner {
        require(
            msg.sender == owner,
            "Only owner can call this function."
        );
        _;
    }
}

contract priced {
    // Modifiers can receive arguments:
    modifier costs(uint price) {
        if (msg.value >= price) {
            _;
        }
    }
}

contract Register is priced, owned {
    mapping(address => bool) registeredAddresses;
    uint price;

    constructor(uint initialPrice) { price = initialPrice; }

    // It is important to also provide the
    // `payable` keyword here, otherwise the function will
    // automatically reject all Ether sent to it.
    function register() public payable costs(price) {
        registeredAddresses[msg.sender] = true;
    }

    // This contract inherits the `onlyOwner` modifier from
    // the `owned` contract. As a result, calls to `changePrice` will
    // only take effect if they are made by the stored owner.
    function changePrice(uint price_) public onlyOwner {
        price = price_;
    }
}

contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(
            !locked,
            "Reentrant call."
        );
        locked = true;
        _;
        locked = false;
    }

    /// This function is protected by a mutex, which means that
    /// reentrant calls from within `msg.sender.call` cannot call `f` again.
    /// The `return 7` statement assigns 7 to the return value but still
    /// executes the statement `locked = false` in the modifier.
    function f() public noReentrancy returns (uint) {
        (bool success,) = msg.sender.call("");
        require(success);
        return 7;
    }
}
```



### Transient Storage

- 개요

  - another data location besides memory, storage, calldata (and return-data and code)
  - data in transient storage is not permanent, but is scoped to the current transaction only, after which it will be reset to zero.
    - new data location behaves as a key-value store similar to storage, but gas costs are much lower

- 특징

  - Transient storage variables cannot be initialized in place, i.e., they cannot be assigned to upon declaration
  - `constant` and `immutable` variables conflict with transient storage
  - have completely independent address space from storage
    - need distinct names though
  - can have visibility as well
  - such use of `transient` as a data location is only allowed for value type.
    - Reference types(array, mapping, struct, ... ) are not yet supported.

- canonical use cases

  - cheaper reentrancy locks

    ```solidity
    // SPDX-License-Identifier: GPL-3.0
    pragma solidity ^0.8.28;
    
    contract Generosity {
        mapping(address => bool) sentGifts;
        bool transient locked;
    
        modifier nonReentrant {
            require(!locked, "Reentrancy attempt");
            locked = true;
            _;
            // Unlocks the guard, making the pattern composable.
            // After the function exits, it can be called again, even in the same transaction.
            locked = false;
        }
    
        function claimGift() nonReentrant public {
            require(address(this).balance >= 1 ether);
            require(!sentGifts[msg.sender]);
            (bool success, ) = msg.sender.call{value: 1 ether}("");
            require(success);
    
            // In a reentrant function, doing this last would open up the vulnerability
            sentGifts[msg.sender] = true;
        }
    }
    ```

:bulb: Composability of Smart Contracts and the Caveats of Transient Storage

- transient 이전에는 단일 트랜잭션 내 여러 external calls과 여러 transaction call이 구분되지 않았음
- transient를 쓸 때에는 가스비에 있어서 이점이 있지만, 컨트랙트의 활용이 단일 트랜잭션 내에서의 사용으로 국한됨을 인지해야 함



### `constant` and `immutable` State Variables

- 공통점
  - cannot be modified after the contract has been constructed
  -  Compared to regular state variables, the gas costs are much lower 

- 차이점
  - `constant`
    - fixed at compile-time
    - possible to define `constant` variables at the file level.
    - The compiler does not reserve a storage slot for these variables
      - every occurrence is replaced by the respective value.
    - Any expression that accesses storage, blockchain data or execution data or makes calls to external contracts is disallowed
      - blockchain data ex : `block.timestamp`, `address(this).balance` or `block.number`
      - execution  data ex : `msg.value` or `gasleft()`
  - `immutable`
    - can be assigned at construction time
      - can be changed at any time before deployment and then it becomes permanent.
    - can only be assigned to inside expressions for which there is no possibility of being executed after creation.
      - excludes all modifier definitions and functions other than constructors.
    - no restrictions on reading immutable variables
      - read is even allowed to happen before the variable is written to
        - variables in Solidity always have a well-defined initial value
        - it is also allowed to never explicitly assign a value to an immutable.



### Functions

- free functions

  - Functions outside of a contract,
  - always have implicit `internal` visibility
  - Their code is included in all contracts that call them, similar to internal library functions.
  - The main difference to functions defined inside a contract is that free functions do not have direct access to the variable `this`, storage variables and functions not in their scope.

- function parameters and return variables

  - function parameters

    - Function parameters are declared the same way as variables, and the name of unused parameters can be omitted.

  - return variables

    - return variables are declared with the same syntax after the `returns` keyword
    - names of return variables can be omitted
      - can provide return values (either a single or multiple ones directly)
      - You can either explicitly assign to return variables, or you can provide return values directly with the `return` statement:
    - Return variables can be used as any other local variable and they are initialized with their default value assigned.
    - the statement `return (v0, v1, ..., vn)` can be used to return multiple values
      - The number of components must be the same as the number of return variables and their types have to match
    
    ```solidity
    contract Simple {
        function arithmetic(uint a, uint b)
            public
            pure
            returns (uint sum, uint product)
        {
            sum = a + b;
            product = a * b;
            //  return (sum , product; 생략하거나 명시 둘 다 가능
        }
    }
    ```

- State Mutability

  :bulb: `STATICCALL` is used when `view` functions are called, which enforces the state to stay unmodified

  :bulb:  For library `view` functions `DELEGATECALL` is used, because there is no combined `DELEGATECALL` and `STATICCALL` [:link:](https://docs.soliditylang.org/en/v0.8.28/contracts.html#view-functions)

  - `view` function

    - in case they promise not to modify the state
      - modifying the state case
        - Writing to state variables.
        - Emitting events.
        - Creating other contracts.
        - Using `selfdestruct`.
        - Sending Ether via calls.
        - Calling any function not marked `view` or `pure`.
        - Using low-level calls.
        - Using inline assembly that contains certain opcodes.

    ```solidity
    contract C {
        function f(uint a, uint b) public view returns (uint) {
            return a * (b + 42) + block.timestamp;
        }
    }
    ```

  - `pure` function

    - in case they promise not to read from or modify the state
      - reading from the state case
        - Reading from state variables.
        - Accessing `address(this).balance` or `<address>.balance`.
        - Accessing any of the members of `block`, `tx`, `msg` (with the exception of `msg.sig` and `msg.data`).
        - Calling any function not marked `pure`.
        - Using inline assembly that contains certain opcodes.
    - Pure functions are able to use the `revert()` and `require()` functions to revert potential state changes when an error occurs.
      - Reverting a state change is not considered a “state modification”
      - 어차피 `view`나 `pure`은 상태 변화 못 하니, revert가 의미 없어짐. try-catch로 revert 잡고 트랜잭션 전파 X는 방법도 사용
      - in line with the `STATICCALL` opcode.

  :warning:It is not possible to prevent functions from reading the state at the level of the EVM (only `view` can be enforced at the EVM level, `pure` can not).

- Special Functions

  - Receive Ether Function

    - 개요
      - is executed on a call to the contract with empty calldata
      - A contract can have at most one `receive` function
        - `receive() external payable { ... }` (without the `function` keyword)
    - 특징
      - This function cannot have arguments, cannot return anything and must have `external` visibility and `payable` state mutability
      - can be virtual, can override and can have modifiers
      - If no such function exists, but a payable fallback function exists, the fallback function will be called on a plain Ether transfer.

    :bulb: If neither a receive Ether nor a payable fallback function is present, the contract cannot receive Ether through a transaction that does not represent a payable function call

    :memo: 이더를 보내는 방법에는 direct로 전송하는 것과 payable 함수를 통해 보내는 것이 있는데, 전자만 `receive`와 `payable fallback` 없으면 못 받음

    :memo: "it can only rely on 2300 gas being available", leaving little room to perform other operations except basic logging.

  - Fallback Function

    - 개요

      - is executed on a call to the contract 

        1. none of the other functions match the given function signature
        2. if no data was supplied at all 
        3. there is no `receive` Ether function

      - can have at most one `fallback` function

        - `fallback () external [payable]`

        - `fallback (bytes calldata input) external [payable] returns (bytes memory output)`

          (both without the `function` keyword)

    - 특징

      - must have `external` visibility. 
      - can be virtual, can override and can have modifiers
      - The fallback function always receives data, but in order to also receive Ether it must be marked `payable`.
      - If the version with parameters is used, `input` will contain the full data sent to the contract (equal to `msg.data`) and can return data in `output`. 
        - The returned data will not be ABI-encoded
        - Instead it will be returned without modifications (not even padding)
      - In the worst case, if a payable fallback function is also used in place of a receive function, it can only rely on 2300 gas being available

- Function Overloading

  - 개요

    - can have multiple functions of the same name but with different parameter types

  - 특징

    - also applies to inherited functions
    
    - It is an error if two externally visible functions differ by their Solidity types but not by their external types.
      - ex) `uint256` and `uint` are treated as the **same external type**
    
    - overload resolution and argument matching
    
      - If there is not exactly one candidate, resolution fails.
    
      ```solidity
      contract A {
          function f(uint8 val) public pure returns (uint8 out) {
              out = val;
          }
      
          function f(uint256 val) public pure returns (uint256 out) {
              out = val;
          }
      }
      ```
    
      => Calling `f(50)` would create a type error since `50` can be implicitly converted both to `uint8` and `uint256` types



virtual

- 함수가 자식 contract에서 재정의 될 수 있음을 나타냄

- virtual 키워드가 붙은 함수는 상속받은 계약에서 `override` 키워드를 사용하여 재정의할 수 있음

payable

- 함수가 이더를 받을 수 있음을 나타냄
  - payable이 붙은 함수는 호출할 때 이더를 전송할 수 있음

- 이더를 받지 않는 함수에 이더를 보내려고 하면 트랜잭션이 실패함

- 따라서, 이더를 받아야 하는 함수에는 반드시 payable 키워드를 붙여야 함





### Events

- 개요

  - Solidity events give an abstraction on top of the EVM’s logging functionality
  - Applications can subscribe and listen to these events through the RPC interface of an Ethereum client.
  - Events can be defined at file level or as inheritable members of contracts

- 동작

  - When you call them, they cause the arguments to be stored in the transaction’s log
    - logs are associated with the address of the contract that emitted them, are incorporated into the blockchain, and stay there as long as a block is accessible

- 특징

  - The Log and its event data is not accessible from within contracts

- 토픽

  - You can add the attribute `indexed` to **up to three parameters** which adds them to a special data structure known as “topics” instead of the data part of the log
  - A topic can only hold a single word (32 bytes) so if you use a reference type for an indexed argument, the Keccak-256 hash of the value is stored as a topic instead.
    - All parameters without the `indexed` attribute are ABI-encoded into the data part of the log
  - Topics allow you to search for events
    - ex) when filtering a sequence of blocks for certain events
  - You can also filter events by the address of the contract that emitted the event.

- `anonymous` specifier

  - it is not possible to filter for specific anonymous events by name, you can **only filter by the contract address**. (원래는 topics 처음에 event signature가 있는데, `anonymous` 지정 시 없어짐)
  - The advantage of anonymous events is that they are cheaper to deploy and call

  ```solidity
  event MyEvent(uint indexed id, uint value) anonymous;
  ```

- Members of Event

  - `event.selector`
    - For non-anonymous events, this is a `bytes32` value containing the `keccak256` hash of the event signature, as used in the default topic



### Custom Errors

- 개요

  - provide a convenient and gas-efficient way to explain to the user why an operation failed
  - can be defined inside and outside of contracts (including interfaces and libraries)

- 특징

  - have to be used together with the revert statement or the require function

    - false => all changes in the current call are reverted, and the error data passed back to the caller
    - Instances of errors can only be created using `revert` statements, or as the second argument to `require` functions.

  - memory allocation for the error-based revert reason will only happen in the reverting case

    => gas-efficient

  - Errors cannot be overloaded or overridden but are inherited

  - same error can be defined in multiple places as long as the scopes are distinct

  - an error can only be caught when coming from an external call, reverts happening in internal calls or inside the same function cannot be caught.



### Inheritance

- Solidity supports multiple inheritance including polymorphism.
  - a function call always executes the function of the same name (and parameter types) in the most derived contract in the inheritance hierarchy
    - the most derived : 상속 계층 구조의 맨 아래에 있는 계약
  - has to be explicitly enabled on each function in the hierarchy using the `virtual` and `override` keywords
  - possible to call functions further up in the inheritance hierarchy internally by explicitly specifying the contract using `ContractName.functionName()` or using `super.functionName()` 
- When a contract inherits from other contracts, only a single contract is created on the blockchain, and the code from all the base contracts is compiled into the created contract.
- State variable shadowing is considered as an error.
  - State variable shadowing : 상속 관계에 있는 계약 간에 동일한 이름의 상태 변수(State Variable)가 선언
- 동일한 함수를 가진 두 컨트랙트를 상속받아서 `super.함수`할 경우에는, 최종 상속 그래프에서 다음 기본 계약의 함수를 호출함
  - 최종 상속 그래프 : solidity에서 다중 상속을 지원할 때 C3 선형화 알고리즘으로, 상속 관계를 단일 선형 순서로 정리
  - 다음 기본 계약 : 상속에서 더 먼저 나열된 계약 `contract A is B, C` 일 경우, B가 다음 기본 계약

#### Function Overriding

- The overriding function must then use the `override` keyword in the function header
- may only change the visibility of the overridden function from `external` to `public`. 
- mutability may be changed to a more strict one following the order:
  - `nonpayable` => `view` => `pure`
  - `payable` is an exception and cannot be changed to any other mutability. 
- If you do not mark a function that overrides as `virtual`, derived contracts can no longer change the behavior of that function
- :bulb: Functions with the `private` visibility cannot be `virtual`
- the `override` keyword is not required when overriding an interface function, except for the case where the function is defined in multiple bases.

#### Modifier Overriding

- works in the same way as function overriding

#### Constructors

- If there is no constructor, the contract will assume the default constructor, which is equivalent to `constructor() {}`. 
- You can use internal parameters in a constructor (for example storage pointers).
  - the contract has to be marked [abstract](https://docs.soliditylang.org/en/v0.8.28/contracts.html#abstract-contract), because these parameters cannot be assigned valid values from outside but only through the constructors of derived contracts.

#### Arguments for Base Constructors

- The constructors of all the base contracts will be called following the linearization rules

  - If the base constructors have arguments, derived contracts need to specify all of them

    1. directly in the inheritance list `contract Derived1 is Base(7)`
    2. a modifier is invoked as part of the derived constructor `constructor(uint y) Base(y * y)`

    :bulb: Specifying arguments in both places is an error.

  - If a derived contract does not specify the arguments to all of its base contracts’ constructors, it must be declared abstract.

    - 나중에 추후 상속하는 애가 명시 안 된 부모꺼까지 다 명시해야함

#### Multiple Inheritance and Linearization

- the order in which the base classes are given in the `is` directive is important

  - You have to list the direct base contracts in the order **from “most base-like” to “most derived”**

  - when a function is called that is defined multiple times in different contracts, the given bases are searched from right to left
    - :bulb: 같은 이름의 함수 override할 때에는 right-to-left이지만, 앞선 `super.함수` 일 때는 left-to-right임

- The constructors will always be executed in the linearized order, regardless of the order in which their arguments are provided in the inheriting contract’s constructor.



### Abstract Contracts

- Contracts must be marked as abstract when at least one of their functions is not implemented or when they do not provide arguments for all of their base contract constructors.

- a contract may still be marked abstract, such as when you do not intend for the contract to be created directly

- An abstract contract is declared using the `abstract` keyword

  ```solidity
  abstract contract Feline {
      function utterance() public virtual returns (bytes32);
  }
  ```

- a function without implementation is different from a Function Type

  - function without implementation : `function foo(address) external returns (address);`
  - Function Type : `function(address) external returns (address) foo;`



#### Interfaces

- 개요 - similar to abstract contracts, but there are further restrictions:
  - cannot have any functions implemented
  - cannot inherit from other contracts (but they can inherit from other interfaces)
  - All declared functions must be external in the interface, even if they are public in the contract
  - cannot declare a constructor
  - cannot declare state variables
  - cannot declare modifiers

- 선언 - Interfaces are denoted by their own keyword:

  ```solidity
  interface Token {
      enum TokenType { Fungible, NonFungible }
      struct Coin { string obverse; string reverse; }
      function transfer(address recipient, uint amount) external;
  }
  ```

- 특징

  - All functions declared in interfaces are implicitly `virtual` and any functions that override them do not need the `override` keyword



### Libraries

- 개요
  - libraries are deployed only once at a specific address and their code is reused using the `DELEGATECALL`
  - if library functions are called, their code is executed in the context of the calling contract

- 특징

  - As a library is an isolated piece of source code, it can only access state variables of the calling contract if they are explicitly supplied

  - Library functions can only be called directly, if they do not modify the state (`view` or `pure`)

  - not possible to destroy a library.

  - calls to library functions look just like calls to functions of explicit base contracts

  - If you use libraries, be aware that an actual external function call is performed.
    - `msg.sender`, `msg.value` and `this` will retain their values in this call, though

- restrictions

  - cannot have state variables
  - cannot inherit nor be inherited
  - cannot receive Ether
  - cannot be destroyed

- Library Linking

  - It is possible to obtain the address of a library by converting the library type to the `address` type, i.e. using `address(LibraryName)`.
  - As the compiler does not know the address where the library will be deployed, the compiled hex code will contain placeholders of the form `__$30bbc0abd4d6364515865950d3e0d10953$__`
  -  [Library Linking](https://docs.soliditylang.org/en/v0.8.28/using-the-compiler.html#library-linking)



### 기타 문법

- Assembly Block

  - 개요

    - allows for low-level operations

  - 예시

    ```solidity
    assembly ("memory-safe") {
        mstore(0, 0xd0e30db0) // deposit()
        success := call(gas(), wnative, amount, 28, 4, 0, 0)
    }
    ```

    - memory-safe is a mode that helps prevent memory corruption.
    - `mstore(0, 0xd0e30db0)` stores the function selector for `deposit()` at memory position 0.
      - `0xd0e30db0` is the first 4 bytes of the Keccak-256 hash of the string "deposit()"

  - low-level opcodes

    - `sstore(slot, value)`

      - stores `value` at the `slot` in storage
      - **gas cost**: High

    - `mstore(offset, value)`

      - stores `value` at memory position `offset`
      - **gas cost**: Low

    - `calldatacopy(memOffset, dataOffset, length)`

      - copies raw input (`calldata`) into memory
      - copies `length` bytes from `calldata[dataOffset:]` into `memory[memOffset:]`

    - `call(gas, to, value, in_offset, in_size, out_offset, out_size)`

      - `gas` : Amount of gas to forward to the call.

      - `to` : Address to call (the target contract).

      - `value` : Amount of ETH/AVAX (native token) to send (0 here).

      - `in_offset `: Memory offset where input data starts.

      - `in_size` : Size of input data in bytes.

      - `out_offset` : Memory offset where output data should be stored.

      - `out_size` : Size of output buffer in bytes.



## Style Guide

### Function

- The modifier order for a function should be:
  1. Visibility
  2. Mutability
  3. Virtual
  4. Override
  5. Custom modifiers
- For short function declarations, it is recommended for the opening brace of the function body to be kept on the same line as the function declaration
- For long function declarations, it is recommended to drop each argument onto its own line at the same indentation level as the function body
  - The closing parenthesis and opening bracket should be placed on their own line as well at the same indentation level as the function declaration.

#### function Signatures and Selectors in Libraries

- While external calls to public or external library functions are possible, the calling convention for such calls is considered to be internal to Solidity and not the same as specified for the regular contract ABI
  - External library functions support more argument types than external contract functions
    - recursive structs
    - storage pointers
  - function signatures are computed following an internal naming schema and arguments of types not supported in the contract ABI use an internal encoding.
    - :link: [used identifiers for the types in the signatures](https://docs.soliditylang.org/en/v0.8.28/contracts.html#function-signatures-and-selectors-in-libraries)



### Using For

- 개요

  - 특정 데이터 타입에 대해 **라이브러리 함수**를 연결하여, 해당 타입의 변수에서 직접 라이브러리 함수처럼 호출할 수 있도록 해주는 기능

- 구문

  ```solidity
  using LibraryName for DataType;
  ```

- 동작

  - The first argument is automatically set to the variable you call the function on

  - 특정 데이터 타입의 변수에서 해당 타입에 연관된 **라이브러리 함수**를 **인스턴스 메서드처럼 호출** 가능. `value.functionName()`
  
    =  `LibraryName.functionName(value)`

- 예시

  ```solidity
  // Library: SafeERC20
  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {...}
  ```

  ```solidity
  using SafeERC20 for IERC20;
  // ...
  erc20.safeTransferFrom(from, address(this), amount);
  ```

  









