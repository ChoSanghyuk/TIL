# Solidity



## Layout of a Solidity Source File



### SPDX License Identifier

- 배경

  - 소스 코드의 공개는 코드의 신뢰도를 높여줄 수 있지만, 저작권 같은 법적인 문제를 야기하기도 함

    => Solidity compiler encourages the use of machine-readable SPDX license identifiers

- 개요

  - 오픈 소스 소트웨어의 라이선스를 표기하기 위한 표준화된 방식

    => 소프트웨어의 라이선스 정보를 명확하게, 일관되게 표현

  - Identifier는 소스 코드 내 주석 등에 표기되어, 해당 소프트웨어 라이선스 정보를 명확히 전달

  - SPDX 웹사이트에서 제공하는 라이선스 리스트에 따라 사용

  - The compiler does not validate that the license is part of the list allowed by SPDX, but it does include the supplied string in the bytecode metadata

- 작성

  - The comment is recognized by the compiler anywhere in the file at the file level, but it is recommended to put it at the top of the file
    - ex) `// SPDX-License-Identifier: MIT`
  - In case you do not want to specify a license or if the source code is not open-source
    - use the special value `UNLICENSED`
      - != `UNLICENSE` (grants all rights to everyone)



## Contracts



### Creating Contracts

- A constructor is optional
- Only one constructor is allowed, which means overloading is not supported
- The deployed code does not include the constructor code or internal functions only called from the constructor



### Visibility and Getters

#### State Variable Visibility

- 종류

  - public

    - compiler automatically generates getter functions for them

      => allows other contracts to read their values

    - Setter functions are not generated so other contracts cannot directly modify their values
    - 외부에서의 접근은 getter을 자동으로 호출하여 접근, 내부에서의 접근은 storage로부터 직접 접근함

  - internal

    - can only be accessed from within the contract they are defined in and **in derived contracts**
      - cannot be accessed externally
    - default visibility level

  - private

    - can only be accessed from within the contract they are defined in

- 위치

  - after the type
  - ex) `uint public data;`

#### Function Visibility

- 종류
  - external
    - part of the contract interface, which means they can be called from other contracts and via transactions
    - 내부에서 호출하기 위해서는 `this.{함수}`와 같은 접근 필요
  - public
    - part of the contract interface and can be either called internally or via message calls.
  - internal
    - can only be accessed from within the current contract or contracts deriving from it
    - cannot be accessed externally
    -  Since they are not exposed to the outside through the contract’s ABI, they can **take parameters of internal types like mappings or storage references**.
  - private
    - like internal ones but they are not visible in derived contracts
- 위치
  - between parameter list and return parameter list
  - ex) `function setData(uint a) internal { data = a; }`

#### Getter Functions

- 개요

  - The compiler automatically creates getter functions for all **public** state variables
  - The getter functions have external visibility
  - ex) `uint public data = 42;` 선언 시 자동으로 `function data() external view returns (uint) {return data}` 라는 함수가 생성됨

- 복합 타입

  - can only retrieve single elements of the array via the generated getter function
    - <=  avoid high gas costs when returning an entire array.
  - You can use arguments to specify which individual element to return
  - If you want to return an entire array in one call, then you need to write a function

  ```solidity
  // SPDX-License-Identifier: GPL-3.0
  pragma solidity >=0.4.16 <0.9.0;
  
  contract arrayExample {
      // public state variable
      uint[] public myArray;
  
      // Getter function generated by the compiler
      /*
      function myArray(uint i) public view returns (uint) {
          return myArray[i];
      }
      */
  
      // function that returns entire array
      function getArray() public view returns (uint[] memory) {
          return myArray;
      }
  }
  ```
  
  - 복합타입이 포함된 struct 타입에 대해서는, 복합필드를 제외한 필드들만 자동 getter로 반환함

### Function Modifiers

- 개요
  - used to change the behavior of functions in a declarative way. 
    - ex) you can use a modifier to automatically check a condition prior to executing the function.
- 특징
  - inheritable properties of contracts
    - if they are marked `virtual`, modifier can be overridden by derived contracts
  - It is only possible to use modifiers defined in the current contract or its base contracts. 
    - Modifiers can also be defined in libraries but their use is limited to functions of the same library.
    - If you want to access a modifier `m` defined in a contract `C`, you can use `C.m` to reference it without virtual lookup. 
  - cannot implicitly access or change the arguments and return values of functions they modify
    - Their values can only be passed to them explicitly at the point of invocation
  - Symbols introduced in the modifier are not visible in the function (as they might change by overriding).
    - <=> Arbitrary expressions are allowed for modifier arguments and in this context, all symbols visible from the function are visible in the modifier.
  - Explicit returns from a modifier or function body only leave the current modifier or function body
    - Return variables are assigned and control flow continues after the `_` in the preceding modifier
    - An explicit return from a modifier with `return;` does not affect the values returned by the function
    - The modifier can, however, choose not to execute the function body at all and in that case the return variables are set to their default values
- 사용
  - Multiple modifiers are applied to a function by specifying them in a whitespace-separated list and are evaluated in the order presented.
  - The placeholder statement (`_`) is used to denote where the body of the function being modified should be inserted
    - The `_` symbol can appear in the modifier multiple times. Each occurrence is replaced with the function body, and the function returns the return value of the final occurrence.

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.1 <0.9.0;

contract owned {
    constructor() { owner = payable(msg.sender); }
    address payable owner;

    // This contract only defines a modifier but does not use
    // it: it will be used in derived contracts.
    // The function body is inserted where the special symbol
    // `_;` in the definition of a modifier appears.
    // This means that if the owner calls this function, the
    // function is executed and otherwise, an exception is
    // thrown.
    modifier onlyOwner {
        require(
            msg.sender == owner,
            "Only owner can call this function."
        );
        _;
    }
}

contract priced {
    // Modifiers can receive arguments:
    modifier costs(uint price) {
        if (msg.value >= price) {
            _;
        }
    }
}

contract Register is priced, owned {
    mapping(address => bool) registeredAddresses;
    uint price;

    constructor(uint initialPrice) { price = initialPrice; }

    // It is important to also provide the
    // `payable` keyword here, otherwise the function will
    // automatically reject all Ether sent to it.
    function register() public payable costs(price) {
        registeredAddresses[msg.sender] = true;
    }

    // This contract inherits the `onlyOwner` modifier from
    // the `owned` contract. As a result, calls to `changePrice` will
    // only take effect if they are made by the stored owner.
    function changePrice(uint price_) public onlyOwner {
        price = price_;
    }
}

contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(
            !locked,
            "Reentrant call."
        );
        locked = true;
        _;
        locked = false;
    }

    /// This function is protected by a mutex, which means that
    /// reentrant calls from within `msg.sender.call` cannot call `f` again.
    /// The `return 7` statement assigns 7 to the return value but still
    /// executes the statement `locked = false` in the modifier.
    function f() public noReentrancy returns (uint) {
        (bool success,) = msg.sender.call("");
        require(success);
        return 7;
    }
}
```



### Transient Storage

- 개요

  - another data location besides memory, storage, calldata (and return-data and code)
  - data in transient storage is not permanent, but is scoped to the current transaction only, after which it will be reset to zero.
    - new data location behaves as a key-value store similar to storage, but gas costs are much lower

- 특징

  - Transient storage variables cannot be initialized in place, i.e., they cannot be assigned to upon declaration
  - `constant` and `immutable` variables conflict with transient storage
  - have completely independent address space from storage
    - need distinct names though
  - can have visibility as well
  - such use of `transient` as a data location is only allowed for value type.
    - Reference types(array, mapping, struct, ... ) are not yet supported.

- canonical use cases

  - cheaper reentrancy locks

    ```solidity
    // SPDX-License-Identifier: GPL-3.0
    pragma solidity ^0.8.28;
    
    contract Generosity {
        mapping(address => bool) sentGifts;
        bool transient locked;
    
        modifier nonReentrant {
            require(!locked, "Reentrancy attempt");
            locked = true;
            _;
            // Unlocks the guard, making the pattern composable.
            // After the function exits, it can be called again, even in the same transaction.
            locked = false;
        }
    
        function claimGift() nonReentrant public {
            require(address(this).balance >= 1 ether);
            require(!sentGifts[msg.sender]);
            (bool success, ) = msg.sender.call{value: 1 ether}("");
            require(success);
    
            // In a reentrant function, doing this last would open up the vulnerability
            sentGifts[msg.sender] = true;
        }
    }
    ```

:bulb: Composability of Smart Contracts and the Caveats of Transient Storage

- transient 이전에는 단일 트랜잭션 내 여러 external calls과 여러 transaction call이 구분되지 않았음
- transient를 쓸 때에는 가스비에 있어서 이점이 있지만, 컨트랙트의 활용이 단일 트랜잭션 내에서의 사용으로 국한됨을 인지해야 함



### `constant` and `immutable` State Variables

- 공통점
  - cannot be modified after the contract has been constructed
  -  Compared to regular state variables, the gas costs are much lower 

- 차이점
  - `constant`
    - fixed at compile-time
    - possible to define `constant` variables at the file level.
    - The compiler does not reserve a storage slot for these variables
      - every occurrence is replaced by the respective value.
    - Any expression that accesses storage, blockchain data or execution data or makes calls to external contracts is disallowed
      - blockchain data ex : `block.timestamp`, `address(this).balance` or `block.number`
      - execution  data ex : `msg.value` or `gasleft()`
  - `immutable`
    - can be assigned at construction time
      - can be changed at any time before deployment and then it becomes permanent.
    - can only be assigned to inside expressions for which there is no possibility of being executed after creation.
      - excludes all modifier definitions and functions other than constructors.
    - no restrictions on reading immutable variables
      - read is even allowed to happen before the variable is written to
        - variables in Solidity always have a well-defined initial value
        - it is also allowed to never explicitly assign a value to an immutable.



### Functions

- free functions

  - Functions outside of a contract,
  - always have implicit `internal` visibility
  - Their code is included in all contracts that call them, similar to internal library functions.
  - The main difference to functions defined inside a contract is that free functions do not have direct access to the variable `this`, storage variables and functions not in their scope.

- function parameters and return variables

  - function parameters

    - Function parameters are declared the same way as variables, and the name of unused parameters can be omitted.

  - return variables

    - return variables are declared with the same syntax after the `returns` keyword
    - names of return variables can be omitted
      - can provide return values (either a single or multiple ones directly)
      - You can either explicitly assign to return variables, or you can provide return values directly with the `return` statement:
    - Return variables can be used as any other local variable and they are initialized with their default value assigned.
    - the statement `return (v0, v1, ..., vn)` can be used to return multiple values
      - The number of components must be the same as the number of return variables and their types have to match
    
    ```solidity
    contract Simple {
        function arithmetic(uint a, uint b)
            public
            pure
            returns (uint sum, uint product)
        {
            sum = a + b;
            product = a * b;
            //  return (sum , product; 생략하거나 명시 둘 다 가능
        }
    }
    ```

- State Mutability

  - `view` function

    - in case they promise not to modify the state
      - modifying the state case
        - Writing to state variables.
        - Emitting events.
        - Creating other contracts.
        - Using `selfdestruct`.
        - Sending Ether via calls.
        - Calling any function not marked `view` or `pure`.
        - Using low-level calls.
        - Using inline assembly that contains certain opcodes.

    ```solidity
    contract C {
        function f(uint a, uint b) public view returns (uint) {
            return a * (b + 42) + block.timestamp;
        }
    }
    ```

  - `pure` function

    - in case they promise not to read from or modify the state
      - reading from the state case
        - Reading from state variables.
        - Accessing `address(this).balance` or `<address>.balance`.
        - Accessing any of the members of `block`, `tx`, `msg` (with the exception of `msg.sig` and `msg.data`).
        - Calling any function not marked `pure`.
        - Using inline assembly that contains certain opcodes.
    - Pure functions are able to use the `revert()` and `require()` functions to revert potential state changes when an error occurs.
      - Reverting a state change is not considered a “state modification”
      - in line with the `STATICCALL` opcode.

- Special Functions

  - Receive Ether Function

    - 개요
      - is executed on a call to the contract with empty calldata
      - A contract can have at most one `receive` function
        - `receive() external payable { ... }` (without the `function` keyword)
    - 특징
      - This function cannot have arguments, cannot return anything and must have `external` visibility and `payable` state mutability
      - can be virtual, can override and can have modifiers

    :bulb: If no such function exists, but a payable fallback function exists, the fallback function will be called on a plain Ether transfer. If neither a receive Ether nor a payable fallback function is present, the contract cannot receive Ether

  - Fallback Function

    - 개요

      - is executed on a call to the contract 

        1. none of the other functions match the given function signature
        2. if no data was supplied at all 
        3. there is no [receive Ether function

      - can have at most one `fallback` function

        - `fallback () external [payable]`

        - `fallback (bytes calldata input) external [payable] returns (bytes memory output)`

          (both without the `function` keyword)

    - 특징

      - must have `external` visibility. A fallback function can be virtual, can override and can have modifiers
      - The fallback function always receives data, but in order to also receive Ether it must be marked `payable`.
      - If the version with parameters is used, `input` will contain the full data sent to the contract (equal to `msg.data`) and can return data in `output`. 
        - The returned data will not be ABI-encoded
        - Instead it will be returned without modifications (not even padding)

  :memo: "it can only rely on 2300 gas being available" 라는 설명이 있지만, 현재 단계에서는 아직 이해 X

- Function Overloading

  - 개요

    - can have multiple functions of the same name but with different parameter types

  - 특징

    - also applies to inherited functions
    - It is an error if two externally visible functions differ by their Solidity types but not by their external types.
      - ex) `uint256` and `uint` are treated as the **same external type**

    - overload resolution and argument matching

      - If there is not exactly one candidate, resolution fails.

      ```solidity
      contract A {
          function f(uint8 val) public pure returns (uint8 out) {
              out = val;
          }
      
          function f(uint256 val) public pure returns (uint256 out) {
              out = val;
          }
      }
      ```

      => Calling `f(50)` would create a type error since `50` can be implicitly converted both to `uint8` and `uint256` types



virtual

- 함수가 자식 contract에서 재정의 될 수 있음을 나타냄

- virtual 키워드가 붙은 함수는 상속받은 계약에서 `override` 키워드를 사용하여 재정의할 수 있음

payable

- 함수가 이더를 받을 수 있음을 나타냄
  - payable이 붙은 함수는 호출할 때 이더를 전송할 수 있음

- 이더를 받지 않는 함수에 이더를 보내려고 하면 트랜잭션이 실패함

- 따라서, 이더를 받아야 하는 함수에는 반드시 payable 키워드를 붙여야 함





### Events

- 개요

  - Solidity events give an abstraction on top of the EVM’s logging functionality
  - Applications can subscribe and listen to these events through the RPC interface of an Ethereum client.
  - Events can be defined at file level or as inheritable members of contracts

- 동작

  - When you call them, they cause the arguments to be stored in the transaction’s log
    - logs are associated with the address of the contract that emitted them, are incorporated into the blockchain, and stay there as long as a block is accessible

- 특징

  - The Log and its event data is not accessible from within contracts

- 토픽

  - You can add the attribute `indexed` to up to three parameters which adds them to a special data structure known as “topics” instead of the data part of the log
  - A topic can only hold a single word (32 bytes) so if you use a reference type for an indexed argument, the Keccak-256 hash of the value is stored as a topic instead.
    - All parameters without the `indexed` attribute are ABI-encoded into the data part of the log
  - Topics allow you to search for events
    - ex) when filtering a sequence of blocks for certain events
  - You can also filter events by the address of the contract that emitted the event.

- `anonymous` specifier

  - it is not possible to filter for specific anonymous events by name, you can only filter by the contract address.
  - The advantage of anonymous events is that they are cheaper to deploy and call

  ```solidity
  event MyEvent(uint indexed id, uint value) anonymous;
  ```

  

- Members of Event

  - `event.selector`
    - For non-anonymous events, this is a `bytes32` value containing the `keccak256` hash of the event signature, as used in the default topic







## Style Guide



### Function

- The modifier order for a function should be:
  1. Visibility
  2. Mutability
  3. Virtual
  4. Override
  5. Custom modifiers
- For short function declarations, it is recommended for the opening brace of the function body to be kept on the same line as the function declaration
- For long function declarations, it is recommended to drop each argument onto its own line at the same indentation level as the function body
  - The closing parenthesis and opening bracket should be placed on their own line as well at the same indentation level as the function declaration.
  - 





































