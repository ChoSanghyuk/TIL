# [Solana] 네트워크 동작 요소



## POH



### 배경

- In distributed systems, you need to be able to time in small units  to move fast and process transactions as soon as possible

- Ethereum, rely on outside programs to assign a “median” timestamp
  - use to validate transactions in the order they were received.



### POH

- 개요

  - allows timestamps to be built into the blockchain itself
  - This is done through a verifiable delay function, a VDF

- 동작

  - inserts data into the sequence by appending the hash of the data of the previously generated states. 
    - The state, input data, and count are all published — and impossible to recreate or create alternate versions of
  - sets up an upper bound on time 
    - Proof of History can reference previous hashes, 

  - sets up a lower bound of time. 
    - tell you exactly when in the past and future of the global state machine a transaction occurred

- 장점

  - gives the ledger this interesting property where you can infer when events occurred when you examine it
  - Every node has this local synchronized atomic clock and these clocks never need to be resynchronized
  - if communication links go down, our clocks never drift because they are logical based on this SHA256
  - the blockchain can be verified by a small piece of info, it means that it can be verified in parallel

  - ensures the integrity and accuracy of the blockchain’s timestamping process, enhancing its reliability and trustworthiness.

:memo: PoH is not a consensus algorithm, but rather a tool used by Solana’s consensus mechanism for synchronization.



### VDF (Verifiable Delay Function)

- 개요
  - a cryptographic function that demands significant computational effort to compute but can be swiftly verified
  - VDF won’t tell you it’s 12:02:01 PM
  - establishes a chronological order
- timestamp 생성 및 검증
  - timestamp computation runs on a single core of each validator
    - sequence generation is sequential and single-threaded
  - output can be verified in parallel, allowing for efficient verification on multi-core systems
    - timestamp is broadcast across the network and can be authenticated and stored by all network nodes.
  - Nodes within the network can easily confirm that timestamps
    - produced within the expected timeframe 
    - not pre-computed before block addition to the chain



### 비교

- PoW or PoS
  - nodes must synchronize their clocks, a time-consuming task limiting transaction throughput
- PoH
  - the absence of time synchronization issues allows for improved transaction throughput in PoH
    - even despite complex computations in PoH



:link: https://solana.com/news/proof-of-history

:link: https://unchainedcrypto.com/solana-proof-of-history/



## Solana Network



### 개요

- Block

  - referred to as a slot
  - 생성 주기
    - being created approximately every 400 milliseconds

  - 블록 크기
    - 128MB in size 
    - contains 48 million compute units

- Transaction 처리
  - transaction’s blockhash expires in 1 minute and 19 seconds (after 150 blocks)
    - RPC provider could retry sending the transaction for 1 minute and 19 seconds until it is included in a block
      - could spam the network, so not recommended
      - instead, retry every 2 seconds to avoid spamming
  - For a transaction to be considered final, 31 additional blocks must be built on top of it. 
- mempool-less
  - using Gulf Stream
  - transactions must reach the validator to be included in a block, and then be propagated to other validators using Turbine
- protocol
  - Solana uses QUIC, a reliable UDP protocol developed by Google for YouTube, instead of traditional TCP/UDP protocols.

- confirmation rule
  - Solana has two confirmation rules
    - short-term fork selection (*optimistic confirmation*)
    - full PoS consensus for finality (*finalized/rooted*)



### commitment status

- 3 specific commitment statuses for the block

  - Processed

  - Confirmed

  - Finalized

  | Property                              | Processed | Confirmed | Finalized |
  | ------------------------------------- | --------- | --------- | --------- |
  | Received block                        | X         | X         | X         |
  | Block on majority fork                | X         | X         | X         |
  | Block contains target tx              | X         | X         | X         |
  | 66%+ stake voted on block             | -         | X         | X         |
  | 31+ confirmed blocks built atop block | -         | -         | X         |

- confirmed vs finalized

  - **confirmed** 
    - not yet guaranteed to be part of the **canonical chain**
    - can be reverted
    - Validators can reorganize the chain to align with the **fork**-choice rule, effectively removing unrooted blocks
  - finalized (rooted)
    - part of the **canonical chain**
    - cannot be reverted (even forked network should contain it)

- 31-block rule

  - Immediate finality, while desirable, is not feasible in decentralized systems 
    - <= potential network delays, Byzantine faults, or malicious validators. 
  - The 31-block rule ensures:
    - Sufficient time for validators to reach a consistent state
    - Resistance to forks or reorganization attacks

  - 31 blocks take approximately **12.4 seconds** to finalize.

    - With Solana's high throughput and block time (~400ms)

    - This is significantly faster than many other blockchains (e.g., Ethereum’s finality on Proof of Stake can take several minutes).

 :link: ​https://docs.anza.xyz/consensus/commitments



### Node

#### Validator Node

- 개요

  - known as Consensus Nodes 

  - entities responsible for 
    - confirming if blocks are valid, and ultimately 
    - finalizing the transactions by voting on blocks produced by a leader node, or by being the leader
  - earn vote credit for performing voting as long as it successfully votes on blocks that are added to the blockchain

- delegated Proof-of-Stake protocol

  - Solana uses a delegated Proof-of-Stake protocol

  - Anyone who owns SOL can delegate it to a validator
    - whereby the validator then earns influence on the network which leads to them being assigned as a leader for more slots, as well as earning more rewards for voting

#### Leader Node

- 개요
  - part of validator nodes
  - elected to produce four consecutive blocks

- election
  - Leaders for each epoch are selected randomly based on their stake-weight
    - 1 epoch : comprising 432,000 slots (equivalent to 2–3 days)

- how to build a block

  - A validator uses a single-threaded scheduler that employs an algorithm called Prio-Graph. 

    - prioritizes transactions based on their priority fee
    - creates edges between transactions with lower priority that conflict with higher-priority ones 
      - conflict = touching the same state/account
    - allows non-conflicting transactions to run in parallel.

  - There are two threads for executing vote transactions and four threads for non-vote transactions 

    - Signature verification is the most compute-intensive stage in the TPU(Transaction Processing Unit) pipeline

    - Approximately half of the transactions in a block are vote transactions
      - prioritized to maintain network synchronization.

#### RPC node

- not participate in the cluster consensus by voting on the blocks 
- The RPC provider sends the transaction to both the current and next leaders (validator node)
- facilitate easy access for developers to send requests to and receive payloads from nodes on Solana's network 
  - instead of requiring Solana dApps to be responsible for their own node infrastructure



:link: https://www.alchemy.com/overviews/solana-nodes

:link: https://medium.com/@dattgoswami/understanding-transaction-inclusion-in-solana-from-wallets-to-validators-9e412ae792b3

:link: https://www.helius.dev/blog/consensus-on-solana



## SVM - Sealevel Virtual Machine



### 개요

- SVM
  - Solana’s parallel smart contracts runtime
  - Solana transactions describe all the states a transaction will read or write while executing
    - non-overlapping transactions & reading the same state transactions be executed concurrently
- 비교 (vs EVM)
  - EVM (& EOS’s WASM-based runtimes) : single threaded
    - one contract at a time modifies the blockchain state
  - SVM :  process transactions in parallel



### Cloudbreak 구조

- 개요
  - = accounts database 
  - = mapping of Public Keys to Accounts
- Accounts 
  - maintain balances and data
    - data is a vector of bytes
  - have an “owner” field = ProgramId
- Program
  - governs the state transitions for the account
  - are code and have no state
  - rely on the data vector in the Accounts



### Program Authority

- Program
  1. Programs can only change the data of accounts they own.
  2. Programs can only debit accounts they own.
  3. Any program can credit any account.
  4. Any program can read any account.
- System Program
  1. System Program is the only program that can assign account ownership.
     - :memo: By default, all accounts start as owned by the System Program
  2. System Program is the only program that can allocate zero-initialized data.
  3. Assignment of account ownership can only occur once in the lifetime of an account.

- Loader Program
  - 개요
    - A user-defined program is loaded by the loader program
    - able to mark the data in the accounts as executable
  - 동작 순서
    1. Create a new public key.
    2. Transfer coin to the key.
    3. Tell System Program to allocate memory.
    4. Tell System Program to assign the account to the Loader.
    5. Upload the bytecode into the memory in pieces.
    6. Tell Loader program to mark the memory as executable.

:bulb: The key insight here is that programs are code, and within our key-value store, there **exists some subset of keys that the program and only that program has write access.**



### Transactions 처리

- Transaction
  - Transactions specify an instruction vector
  - Each instruction contains 
    - the program
    - program instruction
    - list of accounts the transaction wants to read and write.

- Transaction Optimization

  - each instruction tells the VM which accounts it wants to read and write ahead of time

  - Interfaces such as readv or writev tell the kernel ahead of time all the memory the user wants to read or write

    => allows the OS to prefetch, prepare the device, and execute the operation concurrently if the device allows it

  - VM optimization

    1. Sort millions of pending transactions.
    2. Schedule all the non-overlapping transactions in parallel.



:link: https://solana.com/ko/news/sealevel---parallel-processing-thousands-of-smart-contracts





---





Fee 종류

Transaction Fees 

Prioritization Fees

Rent 

https://solana.com/docs/core/fees
