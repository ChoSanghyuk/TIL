# EIP-3009



## 개요



### EIP-3009

- 소개
  - A contract interface that enables transferring of fungible assets via a signed authorization.
  - A set of functions to enable **meta-transactions** and **atomic interactions** with ERC-20 token contracts via **signatures conforming** to the EIP-712 typed message signing specification.

- 기능

  - **delegate the gas payment to someone else**

  - pay for gas in the token itself rather than in ETH

  - perform one or more token transfers and other operations in a single atomic transaction

  - transfer ERC-20 tokens to another address, and have the recipient submit the transaction

  - batch multiple transactions with minimal overhead

  - create and perform multiple transactions without having to worry about them failing due to accidental nonce-reuse or improper ordering by the miner

:bulb: **meta-transaction** : 실 사용자가 가스를 지불하지 않는 트랜잭션

- 비교

  - EIP-2612 : meta-transaction 지원 but sequential nonce 사용

  - EIP-3009 : random 32-byte nonce 사용

    => 연속적인 거래 대납 요청이 있을 때, nonce 꼬이는 경우 방지 (이전 nonce를 또 사용하게 되거나, 이전 nonce를 가진 tx가 처리가 안 되어 처리가 지연되는 문제 등)





## 주요 함수



### `transferWithAuthorization`

  1. External Function Entry Point

       - Accepts transfer parameters and signature components (v, r, s)

       - Delegates to internal `_transferWithAuthorization` with the `TRANSFER_WITH_AUTHORIZATION_TYPEHASH`

     ```solidity
     // keccak256("TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)")
     bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cd...c1a2267;
     ```

  2. Internal Authorization Logic

     - Validation Checks:
       - Time validation: Ensures now > validAfter and now < validBefore
       - Nonce validation: Checks the nonce hasn't been used via `_authorizationStates[from][nonce]`

     - Signature Recovery Process:

         1. Data Encoding: Creates structured data using `abi.encode()` with:
           - typeHash (`TRANSFER_WITH_AUTHORIZATION_TYPEHASH`)
           - Transfer parameters: from, to, value, validAfter, validBefore, nonce
         2. EIP-712 Signature Recovery: Calls `EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data)`
         
         
       
       :bulb: `DOMAIN_SEPARATOR`: the value defined in a contract to prevent signature replay attacks across different contracts, chains, or versions.
       
       ```solidity
       // 예시
       DomainSeparator := Keccak256(ABIEncode(
         Keccak256(
           "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
         ),
         Keccak256("USD Coin"),                      // name
         Keccak256("2"),                             // version
         1,                                          // chainId
         0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48  // verifyingContract
       ))
       ```

3. EIP-712 Recovery Logic

   - Digest Creation:

       - Constructs EIP-712 compliant digest using `keccak256(abi.encodePacked("\x19\x01", domainSeparator, keccak256(typeHashAndData)))`

       - The `"\x19\x01"` prefix follows EIP-712 standard

         :bulb: 표준별 prefix

         - `"\x19\x00"` : EIP-191 version 0x00 (data with intended validator)
         - `"\x19\x01"` : EIP-712 (structured data signing)
         - `"\x19Ethereum Signed Message:\n"` : Personal message signing
   
   
      - Signature Recovery:
          - Delegates to `ECRecover.recover(digest, v, r, s)`
   


  4. ECDSA Recovery

     - Security Validations:

         - Signature malleability protection: Rejects high s values to prevent signature malleability

         - Recovery ID validation: Ensures `v` is either 27 or 28

     - Address Recovery:
     
         - Uses Solidity's built-in `ecrecover(digest, v, r, s)`
          
           :bulb:`ecrecover`은 digest와 v,r,s의 서명값이 일치하는 지 확인하고 일치된 경우 서명자 주소를 반환함.
          
           :bulb: `DomainSeparator`에서 작성된 version, chainId 등을 개별적으로 검증하는 것이 아닌, 서명이 컨트랙트 전용 도메인 형태로 된 것이 최종 해시 결과만 보고 확인
          
         - Validates recovered address isn't zero


  5. Authorization Completion

     - Final Verification:
       - Compares recovered address with from parameter
       - Reverts with "EIP3009: invalid signature" if mismatch

     - State Updates:
      
         - Marks nonce as used: `_authorizationStates[from][nonce] = true`
        
         - Emits `AuthorizationUsed` event
        
         - Executes the actual transfer via `_transfer(from, to, value)`





### 주요 내장 함수

- `abi.encode`
  
  - solidity 내장 함수로, 모든 데이터 타입을 EVM에서 직접 해석할 수 있는 바이트 형태로 인코딩
  - :bulb: `typeHash`를 사용해서 인코딩하는 것이 아님. 각 파라미터의 데이터 타입을 가지고 인코딩하며, `typeHash` 또한 인코딩되는 단순히 하나의 파라미터
  
- `abi.encodePacked`
  - solidity 내장 함수로, 모든 데이터 타입을 EVM에서 직접 해석할 수 있는 바이트 형태로 인코딩 (padding 없이)
    - `abi.encode` : uses 32-byte padding for all elements
    - `abi.encodePacked` : No padding - uses minimal bytes needed for each type
  - :bulb: dynamic types(`string`, `bytes`)은 hash collision 문제를 가지고 있음
    - ex) `abi.encodePacked("a", "bc")` 결과와 `abi.encodePacked("ab", "c")`결과가 같음

- `ecrecover`
  - 개요
  
    - a Solidity precompiled function that recovers the Ethereum address from an ECDSA signature and message hash
    - 사용자는 ecrecover()함수를 실행해서 나온 주소값와 데이터를 전송한 사용자의 주소값을 비교하여 일치하면 해당 데이터는 전송한 사용자가 서명한 데이터라고 검증
  
  - 서명값 (Ethereum signature)
  
    - 서명값은 v,r,s 로 구성
  
      ```
      [32 bytes r][32 bytes s][1 byte v]
      ```
  
  
    - v,r,s 값을 직접 계산 방법 (javascript)
  
      ```javascript
      signature = signature.substr(2); //remove 0x
      const r = '0x' + signature.slice(0, 64)
      const s = '0x' + signature.slice(64, 128)
      const v = '0x' + signature.slice(128, 130)
      ```
  
  
    - (번외) solidity 예시
  
      ```solidity
      v := byte(0, mload(add(signature, 0x60)))
      ```
  
      - signature은 signature bytes가 시작되는 포인터 값
      - `add(signature, 0x60)` => signature의 96번째 자리를 가르키는 포인터값 생성
      - `mload(add(signature, 0x60))` => loads 32 bytes (256 bits) from the calculated memory address
      - `byte(0, mload(add(signature, 0x60)))` => 0번째 자리부터 하나의 byte만 읽어서 반환
  
      :bulb: signature의 첫 byte 32자리는 길이에 대한 것이기에, v를 96번째 자리부터 읽음
  
  - `messageHash` in `ecrecover` 
  
    - **cryptographic hash of the original message** that was signed
    - EIP-712 표준 hash type

      ```solidity
      bytes32 structHash = keccak256(abi.encode(
          keccak256("Transfer(address to,uint256 amount,uint256 nonce)"),
          to,
          amount,
          nonce
      ));
      
      bytes32 messageHash = keccak256(abi.encodePacked(
          "\x19\x01",
          DOMAIN_SEPARATOR,
          structHash
      ));
      ```
      
      - 여러 hash types 존재함
      


