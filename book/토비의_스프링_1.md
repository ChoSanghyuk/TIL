# 토비의 스프링 1



## 들어가며




### 스프링이란 무엇인가

- **애플리케이션 기본 틀** : 스프링 컨테이너

  - 스프링 런타임 엔진
  - 설정 정보를 참고로 해서 애플리케이션 구성하는 오브젝트를 생성하고 관리

- **공통 프로그래밍 모델** : IoC/DI, 서비스 추상화, AOP

  - 코드가 어떻게 작성되어야 하는지 기준 제시

  1. IoC/DI
     - 오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델
  2. 서비스 추상화
     - 환경/서버/기술에 종속되지 않고 이식성이 뛰어나며, 유연한 애플리케이션 개발 
  3. AOP
     - 부가적인 기능을 독립적으로 모듈화하는 프로그래밍 모델

- **기술 API** 

  - 방대한 양의 기술 API 제공




### 스프링의 성공 요인

- 단순함
  - 가장 단순한 객체지향적인 개발 모델인 POJO 프로그래밍
- 유연성
  - 여러 프레임워크를 함께 사용하게 해줌 => 접착 프레임워크



## 1장. 오브젝트와 의존관계



### 1.1 초난감 DAO



### 1.2 DAO의 분리

- 관심사의 분리
  - 요구사항은 끊임없이 바뀌고 발전 => 어떻게 대비?
    - 변화의 폭을 최소한으로 줄여주는 것
    - 분리와 확장을 고려한 설계
    - 변화는 대체로 집중된 한 가지 관심에 대해 일어남
    - 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것
- UserDao 관심사항
  - DB와 연결을 위한 커넥션을 어떻게 가져올까라는 관심
  - 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행
  - 작업이 끝나면 resources close
- 상속을 통한 확장
  - 같은 클래스에 다른 메소드로 분리됐던 DB 커넥션 연결이라는 관심을 상속을 통해 서브클래스로 분리
  - 클래스 계층구조를 통해 두 개의 관심이 독립적으로 분리되면서 변경 작업 용이
  - 템플릿 메소드 패턴
    - 슈퍼클래스에 기본적인 로직의 흐름 (커넥션 가져오기, SQL 생성, 실행, 변환)을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 생성. 서브클래스에서 구현
  - 팩토리 메소드 패턴
    - 서브클래스에서 구체적인 오브젝트 생성 방법을 결정
  - UserDao는 Connection 오브젝트가 만들어지는 방법과 내부 동작 방식에는 상관없이, Connection 인터페이스를 통해 사용
  - 상속의 한계
    - 다중상속 X
    - (상하위 클래스끼리 )두 가지 다른 관심사에 대해 긴밀한 결합



### 1.3 DAO 확장

- 변화의 성격이 다르다는 건, 변화의 이유와 시기, 주기 등이 다름-

- 클래스의 분리

  - 상속 X. 완전히 독립적인 클래스로 분리
  - UserDao가 SimpleConnectionMaker라는 특정 클래스와 그 코드에 종속적이기 때문에 앞으로 납품 후에 고객이 DB 커넥션을 가져오는 방법을 자유롭게 확장하기가 힘들어졌다.

- 인터페이스의 도입

  - 추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업

    => 인터페이스

- 관계설정 책임의 분리

  - DAO 생성자 내부의 ` new DConnectionmaker()`라는 코드는 매우 짧고 간단하지만 그 자체로 충분히 독립적인 관심사를 담고 있음

  - 사용되는 오브젝트를 서비스, 사용하는 오브젝트를 클라이언트

  - UserDao의 클라이언트가 제 3 관심사항인 UserDao와 ConnectionMaker 구현 클래스의 관계를 결정해주는 기능을 분리해서 두기에 적절한 곳

  - 다형성을 통한 인터페이스 타입으로 참조

    - 클래스 사이의 관계는 코드에 다른 클래스 이름이 나타나기 때문에 생성

      =>  인터페이스 타입으로 참조 시, 느슨한 관계

    - 런타임 시점에는 모델링 시에 없었던(관계가 보이지 않던) 관계가 생성

  - 런타임 오브젝트 관계를 갖는 구조를 만들어주는 것이 클라이언트의 책임

  - 개방 폐쇄 원칙

    - 클래스나 모듈은 확장에는 열려 있고, 변경에는 닫혀 있어야 함

  - 높은 응집도와 낮은 결합도

    - 응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중
    - 낮은 결합도
      - 책임과 관심사가 다른 오브젝트과는 느슨하게 연결된 형태를 유지
      - 최소한의 방법으로 간접적인 형태로 제공, 나머지는 서로 독립적이고 알 필요 없게 만들어주는 것
      - 확장하기에도 매우 편리

  - 전략 패턴

    - 개방 폐쇄 원칙의 실현에도 가장 잘 들어맞는 패턴

    - 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리

    - 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용

      : 대체 가능한 전략



### 1.4 제어의 역전

- 팩토리
  - 객체의 생성 방법을 결정하고 반환
  - != 추상 팩토리 패턴 / 팩토리 메소드 패턴

- 설계도로서의 팩토리

  ![image-20230613081209726](토비의_스프링_1.assets/image-20230613081209726.png)

  [토비의 스프링 그림 1-8 오브젝트 팩토리를 활용한 구조]

  - DaoFactory를 분리했을 때의 장점
    - 컴포넌트 역할을 하는 오브젝트와 애플리케이션 구조를 결정하는 오브젝트를 분리 O

- 제어권의 이전을 통한 제어관계 역전

  - 프로그램의 제어 흐름 구조가 뒤바뀌는 것

  - **능동적 주체 => 수동적 주체**

    - 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정, 언제/어떻게 그 오브젝트를 만들지를 스스로 관장

      => 모든 제어 권한을 자신이 아닌 다른 대상에게 위임

  - 라이브러리 vs 프레임워크

    - 라이브러리 : 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어

    - 프레임워크 : 애플리케이션 코드가 프레임워크에 의해 사용. 프레임워크가 흐름을 주도

      => 프레임워크에는 분명한 제어의 역전 개념이 적용되어야 함



### 1.5 스프링의 IoC

- 오브젝트 팩토리를 이용한 스프링 IoC

  - 애플리케이션 컨텍스트와 설정정보

    - **빈** : 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
    - **빈 팩토리** : 빈의 생성과 관계 생성 같은 제어를 담당
    - **애플리케이션 컨텍스트** : IoC 방식을 따라 만들어진 일종의 빈 팩토리. 
      - = 빈 팩토리

  - DaoFactory를 사용하는 애플리케이션 컨텍스트

    - 어노테이션

      - `@Configuration` : 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스
      - `@Bean` : 오브젝트 만들어주는 메소드

    - 애플리케이션 컨텍스트를 적용한 UserDaoTest

      ```java
      public class UserDaoTest {
          public static void main(String[] args) throws ClassNotFoundException, SQLException {
              Application context = new AnnotationConfigApplicationContext(DaoFactory.class);
              UserDao dao = context.getBean("userDao", UserDao.class);
              // ...
          }
      }
      ```

      - `DaoFactory`에서 `@Bean` 어노테이션을 `userDao` 메소드에 부착 => 메소드 이름  = 빈 이름
      - `getBean()`은 기본적으로 Object 타입으로 리턴 => 다시 캐스팅

- 애플리케이션 컨텍스트의 동작방식

  - 애플리케이션 컨텍스트 ≈ IoC 컨테이녀 ≈ 스프링 컨테이너 ≈ 빈 팩토리

    ![image-20230613084213262](토비의_스프링_1.assets/image-20230613084213262.png)

    [토비의 스프링 1. 그림 1-9 애플리케이션 컨텍스트가 동작하는 방식]

  - 장점

    - 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다
    - 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
    - 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다



### 1.6 싱글톤 레지스트리와 오브젝트 스코프

- 오브젝트의 동일성과 동등성

  - 동일성 : 동일한 오브젝트 (`==`)
  - 등등성 : 동일한 정보를 담고있는 오브젝트 (`equals()`)

- 애플리케이션 컨텍스트가 싱글톤 레지스트리인 이유

  - 스프링 = 앤터프라이트 서버환경 => 요청마다 새로운 오브젝트 생성 ~> 서버 부하

- 자바에서의 싱글톤 구현 한계

  - 구현 방식
    - 생성자를 private
    - 자신과 같은 스태틱 필드 정의
    - 스태택 팩토리 메소드인 `getInstance()` 정의 후 해당 메소드를 통해 객체 반환
  - 한계
    - private 생성자 => 상속 X
      - 상속과 다형성과 같은 객체 지향적 특징 적용  X
    - 테스트의 어려움
      - 생성 방식이 제한적이기 때문에 목 오브젝트 등으로 대체 X
    - 서버 환경에서는 하나만 생성되는 것을 보장 X
      - 클래스 로드의 구성에 따라 하나 이상의 오브젝트 생성 O
      - 여러 개의 JVM에 분산돼서 설치 => 각각 독립적으로 오브젝트 생성
    - 바람직 하지 못한 전역 상태
      - 스태틱 메소드 => 언제든지 싱글톤에 접근 O

- 싱글톤 레지스트리

  - 스프링은 직접 싱글톤의 형태 오브젝트 만들고 관리

    => public 생성자 O + 디자인 패턴 제약 X

- 스프링 빈의 스코프

  - **빈의 스코프**
    - 빈이 생성되고 존재하고 적용되는 범위
  - 종류
    - 프로토타입 : 컨테이너에 빈 요청시 마다 새로 생성
    - 요청 스코프 : HTTP 요청시 마다 생성
    - 세션 스코프 : 웹의 세션과 스코프가 유사



### 1.7 의존관계 주입 (DI)

- 제어의 역전(IoC)과 의존관계 주입
  - DI의 핵심
    - 오브젝트 레퍼런스를 외부로부터 주입받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어짐

- 런타임 의존관계 설정

  - 의존 : 의존대상이 변하면, 자신에게 영향이 미치는 관계

  - 인터페이스에 대한 의존관계

    => 인터페이스 구현 클래스와의 느슨한 관계

    => 변화에 낮은 영향 = 낮은 결합도

  - 의존관계 주입의 3가지 조건
    1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 X
    2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정
    3. 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공

- 의존관계 검색과 주입

  - 의존관계 검색

    - 런타임 시에 의존관계 결정 

    - 외부로부터 주입 X, **스스로 검색**을 이용 

      ```java
      public UserDao(){
          DaoFacotry daoFactory = new DaoFactory();
          this.connectionMaker = daoFactory.connectionMaker(); // ConnectionMaker는 인터페이스
      }
      ```

      - 여전히 구체적인 connectionMaker는 알지 못하지만, IoC 컨테이너인 DaoFacotry에 요청
      - 스프링의 애플리케이션 컨텍스트라면 미리 정해놓은 이름을 전달해서 그 이름에 해당되는 오브젝트 반환
      - 코드 안에 오브젝트 팩토리 클래스 or 스프링 API 등장 => 의존관계 생성 (=> 대게는 주입 방식 권장)

    - 필요 경우

      - 서버 시 main()역할을 하는 서블릿에서 스프링 컨테이너에 담긴 오브젝트를 사용하기 위해서는 한 번은 검색 필요

    - 차이점

      - 검색의 경우, 검색하는 오브젝트는 자신이 스프링 빈일 필요가 없음. (UserDao는 빈일 필요 X)
      - 주입의 경우, UserDao도 반드시 빈 오브젝트
        - UserDao에 주입하기 위해선, UserDao에 대한 생성/초기화 권한 필요 => IoC 방식으로 생성되는 빈 오브젝트

  - 의존관계 주입 응용
    - 기능 구현의 교환
      - 테스트와 운영시 다른 DB 사용시 DAO가 connection 정보와 직접적으로 의존하면, 환경 변경 때 대규모 수정 필요
      - DI의 설정정보에 해당하는 DaoFactory만 다르게 만들어두면, 나머지 코드들은 수정 X, 각각 다른 런타임 오브젝트에 의존관계 생성 O
    - 부가기능 추가
      - connection 횟수를 counting 하고 싶다면 UserDao -> CountingConnectionMaker -> ConnectionMaker 의 의존관계를 통해, UserDao와 ConnectionMaker의 소스 수정없이 구현 O
      - DI의 장점은 관심사의 분리를 통해 얻어지는 높은 응집도
  - 메소드를 이용한 의존관계 주입
    - 수정자 메소드
    - 일반 메소드
      - 한번에 한개의 파라미터만 가질 수 있는 제약 회피 O



### 개념 사전

- DAO

  - 데이터를 조회하거나 조작하는 기능을 전담 오브젝트

- javaBean(자바빈)

  - 두 가지 관례를 따라 만들어진 오브젝트

    - 디폴트 생성자

      - 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트 생성

    - 프로퍼티

      - 이름을 가진 속성

      - getter/setter을 통해 조회/수정

- 디자인 패턴

  - 자주 만나는 문제를 해결 => 재사용 가능한 솔루션
  - 언급만으로 의도와 해결책을 함께 설명 O

- 템플릿 메소드 패턴

  - 상속을 통해 슈퍼클래스의 기능을 확장 시, 변하지 않는 기능은 슈퍼클래스에 두고, 자주 변경되면 확장할 기능은 서브클래스에서 구현
  - 훅(hook) 메소드 : 슈퍼클래스에서 디폴트 기능을 정의, 서브클래스에서 **선택적으로** 오버라이드할 수 있는 메소드

- 팩토리 메소드 패턴
  - 상속을 통해 확장하게 하는 패턴
  - 슈퍼클래스 코드에서는 서브클래스에서 구현할 메소드를 호출해서 인터페이스 타입의 오브젝트를 가져와 사용
  - 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드
- 팩토리 메소드 (별도)
  - 오브젝트를 생성하는 기능을 가진 메소드





## 테스트



### 테스트 필요성

- 복잡해져가는 애플리케이션에 대한 대응 전략

  1. 객체지향

     - 확장과 변화를 고려한 설계

       => IoC/DI

  2. 테스트

     - 코드에 대한 확신

  => 변화에 유연하게 대처 O



### 2.1 UserDaoTest 다시 보기

- 웹을 통한 DAO 테스트 방법의 문제점

  - 다른 모든 레이어의 기능 생성 후 테스트 가능
    - DAO 뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 
  - 어디서 문제 생겼는지 빠르게 확인 X

- 작은 단위의 테스트 : `단위 테스트`

  - 관심사의 분리 원리 적용 

    ​	=> 테스트의 관심이 다르다면, 테스트할 대상을 분리하고 집중해서 접근 필요

  - 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위

  - 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트 X라고 보기도 함

- 자동수행 테스트 코드

  - 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요

  - 자동 수행의 장점

    - 자주 반복 O

    - 빠르게 실행 O

      => 언제든지 코드를 수정하고 테스트

      => 지속적인 개선과 점진적인 개발 O

- UserDaoTest 문제점 ( main 메소드에서 print문을 통해 결과 확인하는 방법)

  - 수동 확인 작업의 번거로움
    - 콘솔에 나온 값을 보고 등록과 조회가 성공적으로 되는지 사람이 확인 
    - 양 / 복잡도 증가시 피로도 증가
    - 미세한 차이 식별 힘듦
  - 실행 작업의 번거러움
    - DAO 수만큼 main 메소드도 그만큼 생성
    - 각각의 main 메소드 수동 실행



## UserDaoTest 개선



### 테스트 검증의 자동화

- 테스트 결과 종류

  - 테스트 에러
    - 에러 발생
  - 테스트 실패
    - 기대한 결과값과 상이

- JUnit 테스트 전환 : 테스트의 효율적인 수행과 결과 관리

  - 테스트 메소드 전환
    - 제어권을 직접 가지는 main() 메소드 => JUnit의 형식의 일반 메소드
      1. public 메소드
      2. @Test 어노테이션 부착

  - 검증 코드 전환

    - `assertThat` 스태틱 메소드

      ```java
      assertThat(user2.getName(), is(user.getName()));
      ```

      - 매처(matcher)라는 조건으로 비교해서 일치 시, 패스
      - `is()` : `equals()`로 비교해주는 매처



### 2.3 개발자를 위한 테스팅 프레임워크 JUnit

-  테스트 결과의 일관성

  - 코드에 변경사항이 없다면, 테스트는 항상 동일한 결과를 내야함

    - 테스트는 외부 상태/이전 테스트에 독립적이어야 함

      - ex) 이전 테스트로 DB에 데이터 Insert 했을 시, 재테스트에는 중복에러 발생

      => deleteAll, getCount 기능 추가로 독립성 유지

    - 모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 낼 수 있도록 작성

- 예외조건에 대한 테스트

  - 특정 예외가 던져지면 테스트 성공 / 정상 시, 실패라 판단해야 하는 경우

    ```java
    @Test(expected=EmptyResultDataAccessException.class)
    public void getUserFailure() throws SQLException {
        // dao 테스트 코드
    }
    ```

    - `@Test(expected =  )` 안에  테스트 중에 발생할 것으로 기대하는 예외 클래스 지정

- 포괄적인 테스트

  - "항상 네거티브 테스트를 먼저 만들라" by 로드 존슨(스프링 창시자) 
  - 부정적인 케이스를 먼저 작성하는 습관 필요

- 테스트가 이끄는 개발 (TDD)

  - 기능설계를 위한 테스트

    | 구분 | 단계               | 내용                                      | 코드                                                     |
    | ---- | ------------------ | ----------------------------------------- | -------------------------------------------------------- |
    | 조건 | 어떤 조건을 가지고 | 가져올 사용자 정보가 존재하지 않는 경우에 | dao.deleteAll();<br />assertThat(dao.getCount(), is(0)); |
    | 행위 | 무엇을 할 때       | 존재하지 않는 id로 get()을 실행하면       | get("unknown_id");                                       |
    | 결과 | 어떤 결과가 나온다 | 특별한 예외가 던져진다                    | @Test(expected=EmptyResultDataAccessException.class)     |

    [표2-1 getUserFailure() 테스트 코드에 나타난 기능]

  - 테스트 주도 개발

    - = 테스트 우선 개발(Test First Development)

    - 기본 원칙 : "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다"

      => 모든 코드는 빠짐없이 테스트로 검증

    - 테스트의 작성과 테스트를 성공시키는 코드 작성의 주기를 최대한 짧게 유지

      => 개발한 코드의 오류를 빨리 발견

    - 장점

      - 전체적인 개발 속도 증진
        - 테스트는 상대적으로 작성하기 쉬움
        - 빠른 오류 해결 속도

  - 테스트 코드 개선

    - `@Before`

      - `@Test` 메소드가 실행되기 전에 먼저 실행돼야 하는 메소드를 정의

      - `@Test` 메소드에서 공통적으로 등장하는 변수는 인스턴스 변수로 선언한 후, `@Before`에서 정의

        => 반복적인 코드 제거

      ```java
      public class UserDaoTest{
          private UserDao dao;
          
          @Before
          public ovid setUp(){
              ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
              this.dao = context.getBean("userDao", UserDao.class);
          }
      }
      ```

    :bulb: JUnit 테스트 클래스 수행 방법 요약

    	1. 테스트 클래스에서 @Test 붙은 public이며, void형이고, 파라미터가 없는 테스트 메소드 모두 탐색
    	1. 테스트 클래스의 오브젝트 하나 생성
    	1. @Before 메소드 실행
    	1. @Test 붙은 메소드 한개 실행 및 결과 저장
    	1. @After 메소드 실행
    	1. 나머지 @Test 메소드들에 대해 2~5번 반복
    	1. 테스트 결과 종합하여 반환

    - 테스트 오브젝트

      - @Before, @Test, @After는 서로 독립적으로 수행 (서로가 서로를 호출 X)

        => 주고받을 정보는 인스턴스 변수 활용

      - 각 테스트 메소들 실행할 때 마다 새로운 테스트 클래스 오브젝트 생성

        => 각 테스트가 독립적으로 실행됨을 보장

    - 픽스처

      - 테스트를 수행하는 데 필요한 정보나 오브젝트
        - ex) User 객체들
      - 일반적으로 반복 사용 => @Before로 생성



### 2.4 스프링 테스트 적용

- 애플리케이션 컨텍스트 생성 

  - 방식
    - 모든 싱글톤 빈 오브젝트 초기화
  - 단점
    - 빈이 할당한 리소스 깔끔하게 정리 안될 경우 다음 테스트에 영향 
    - 많은 시간과 자원 소모

- 테스트를 위한 애플리케이션 컨텍스트 관리

  - JUnit을 이용하는 테스트 컨텍스트 프레임워크 => 모든 테스트가 공유 O

  ```java
  @RunWith(SpringJUnit4ClassRunner.class)
  @ContextConfiguration(locations="/applicationContext.xml")
  public class UserDaoTest{
      @Autowired
      private Application context;
      
      // ...
      
      @Before
      public void setUp(){
          this.dao = this.context.getBean("userDao", UserDao.class);
          // ...
      }
          
  }
  ```

  [리스트 2-17 스프링 테스트 컨텍스트를 적용한 UserDaoTest]

  - `@RunWith(SpringJUnit4ClassRunner.class)`

    - JUnit용 테스트 컨텍스트 프레임워크 확장 클래스 지정

  - `@ContextConfiguration` 
    - 애플리케이션 컨텍스트 설정파일 위치 지정

  - `@Autowired`
    - 스프링의 DI에 사용되는 특별한 애노테이션
    - 스프링 애플리케이션 컨텍스트는 초기화 시, 자기 자신도 빈으로 등록 => Autowired 사용 O

    

:bulb: JUnit 5 + ApplicationContext가 xml 파일이 아닌, `@SpringBootApplication`을 통해 bean을 자동 등록하는 경우

```java
@SpringBootTest
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = SpringApplication.class)
public class UserDaoTest{
    
    @Autowired
    private Application context;
```

:heavy_check_mark:  `@SpringBootTest` : 테스트에 Spring Application Context를 가져오기 위해 사용 

:heavy_check_mark: `@ExtendWith(SpringExtension.class)` : `@RunWith` 대체.  JUnit5과 Spring testing 기능 통합

:heavy_check_mark: `@ContextConfiguration` : SpringApplication 부분에 `@SpringBootApplication`가 붙은 시작클래스를 넣음

:heavy_check_mark:[참고] `@SpringBootApplication` = `@Configuration` + `@EnableAutoConfiguration` + `@ComponentScan`



- 테스트 코드에 의한 DI

  ```java
  @DirtiesContext
  public class UserDaoTest{
      @Autowired
      UserDao dao;
      
      @Before
      public void setUp(){
          // ...
          DataSource dataSource = new SingleConnectionDataSource("jdbc:mysql://localhost/testdb", "spring", "book", true);
          dao.setDataSource(dataSource);
          
          
      }
  }
  ```

  - `@DirtiesContext` 
    - 테스트 메소드에서 애플리케이션 컨텍스트의 구성이나 상태를 변경함을 테스트 컨텍스트 프레임워크에 알려줌
    - 테스트 컨텍스트는 해당 애노테이션이 붙은 테스트 클래스(혹은 메소드)에는 애플리케이션 컨텍스트 공유 X
    - 단점 > 장점
      - 애플리케이션 컨텍스트의 구성/상태를 테스트 내에서 변경하지 X 것이 원칙

  - :bulb: SingleConnectionDataSource
    - 스프링이 제공하는 가장 빠른 DataSource
    - DB 커넥션을 하나만 만들어두고 계속 사용

- 테스트를 위한 별도의 DI 설정

  - 테스트 전용 설정파일 생성

- 컨테이너 없는 DI 테스트

  - 스프링 컨테이너에서 UserDao가 동작하는지는 UserDaoTest의 기본 관심사 X
  - 스프링 컨테이너 없이 테스트 할 수 있는 방법을 가장 우선적으로 고려

  ```java
  public class UserDaoTest{
      UserDao dao;
      
      @Before
      public void setUp(){
          // ...
          dao = new UserDao();
          DataSource dataSource = new SingleConnectionDataSource("jdbc:mysql://localhost/testdb", "spring", "book", true);
          dao.setDataSource(dataSource);
      }
  }
  ```

  - UserDao도 유연한 테스트가 가능하게끔 설계
  - :bulb: 침투적 기술과 비침투적 기술
    - 침투적 기술
      - 애플리케이션 코드에 기술 관련 API 등장 or 특정 인터페이스나 클래스의 사용 강제
      - 기술에 종속적
    - 비침투적 기술
      - 애플리케이션 로직을 담은 코드에 아무런 영향 X 적용 가능
      - 기술에 비종속적 

  





















































