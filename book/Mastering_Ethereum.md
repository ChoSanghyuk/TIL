

# 마스터링 이더리움



## 1. 이더리움이란 무엇인가?



### 개요

- 이더리움은 스마트 컨트랙트라는 프로그램을 실행하는 오픈 소스에 기반을 둔, 전 세계에 걸쳐 탈중앙화된 컴퓨팅 인프라스트럭처

- 이더(Ether)라고 하는 암호화폐를 이용하여 실행 자원 비용을 측정하고 제한
  - 이더의 사용 목적은 월드 컴퓨터로서의 이더리움 플랫폼 사용료를 지불하기 위한 유틸리티 화폐

- 임의성과 무한 복잡성을 가진 코드를 실행할 수 있는 **가상 머신**을 운영하는 범용 프로그래밍

- **튜링 완전** 언어



### 비교

- vs 비트코인

  - 비트코인

    - 트랜잭션이 **상태 전이**(state transition)를 일으켜 코인의 소유권을 변경하는 탈중앙화된 합의 **상태 머신**(state machine)
    - 화폐 소유 상태만 추적

  - 이더리움

    - 탈중앙화된 합의 **상태 머신**(state machine)

    - 범용 데이터 저장소 **키-밸류 튜플**로 표현할 수 있는 모든 데이터를 저장

      => 상태 머신에 코드를 로드하고 그 코드를 실행하고 그 결과 상태를 저장할 수 있음

- 일반적인 범용 컴퓨터와의 차이

  - 이더리움의 상태 변화가 합의 규칙에 의해 관리
  - 상태가 전체적으로 배포



### 이더리움의 구성요소

- 피어투피어 네트워크 (P2P network)
- 합의 규칙
- 트랜잭션
  - 보낸 사람, 받는 사람, 값, 데이터 페이로드가 포함된 네트워크 메시지
- 상태 머신
  - 이더리움 상태 전이는 **바이트코드를 실행**하는 **EVM**(Ethereum Virtual Machine)에 의해 처리
- 데이터 구조
  - 머클 패트리샤 트리라고 하는 시리얼라이즈된 해시 데이터 구조
  - 각 노드의 데이터베이스에 저장
- 합의 알고리즘
- 경제적 보안성 (economic security)
- 클라이언트
  - 클라이언트 소프트웨어를 상호운용할 수 있는 몇 가지 구현체 존재
  - Geth, Parity



### 이더리움과 튜링 완전

- 튜링 완전 정의

  - 튜링은 순차적 메모리에서 기호를 읽고 쓰는 방식으로 기호를 조작하는 상태 머신으로 구성된 컴퓨터의 수학적 모델 만듬

  - 튜링 머신을 시뮬레이션하는 데 사용할 수 있다면, 시스템이 튜링 완전하다고 정의

- 기능으로서의 튜링 완전
  - 튜링 완전은 이더리움이 어떠한 복잡한 프로그램이라도 계산할 수 있음을 의미

​	 => 이러한 유연성은 보안과 자원 관리에 몇 가지 어려운 문제를 야기. (응답이 없는 시스템에 대한 재부팅 불가)

- 튜링 완전의 함축적 의미

  - 프로그램을 실행하지 않고서는 프로그램의 경로를 예측할 수 없다. 튜링 완전 시스템은 무한 루프에서 실행될 수 있다

  - 노드가 유효성 검사를 시도할 때 우연히 또는 의도적으로 스마트 컨트랜트가 영원히 지속하도록 만들 수 있음. 사실서 서비스 거부 공격 (Denial Of Service)

​	=> 스마트 컨트랙트가 사용하는 자원 제한 필요 => **가스**(gas)라는 과금 매커니즘 도입



### 가스

- 가스는 각 명령어의 비용을 일일이 계산

- 스마트 컨트랙트를 실행하는 데 사용할 수 있는 가스의 최대 사용량을 가지고 있어야 한다.

- 계산에 소비되는 가스의 총량이 트랜잭션에서의 가스 가용량을 초과한다면 EVM은 실행을 중지

  => 리소스 제한

- 트랜잭션의 부분 구성요소로서만 구매
  - 이더로만 살 수 있음





### 탈중앙화 애플리케이션 (DApp)

- 최소 구성 요소로서의 댑
  - 스마트 컨트랙트 + 웹 사용자 인터페이스

- 큰 의미로서의 댑
  - 공개되고 탈중앙화된 피어투피어 기반 서비스 위에 제공되는 웹 애플리케이션



:bulb: 스마트 컨트랙트는 단순하게 업그레이드할 수 없다. 새로운 애플리케이션을 배포하고, 사용자와 앱, 자금을 이전하고 다시 시작할 준비가 되어야 한다.





## 2. 이더리움 기초



### 이더 단위

- 이더리움의 화페 단위는 이더(ether)

  - 이더리움은 시스템, 이더가 화폐

- 이더는 웨이(wei)라는 가능한 가장 작은 단위까지 내려감

  - 1이더 = 10^18wei

  - 이더의 가치는 항상 이더리움 내부에서 웨이로 표시된 부호 없는 정숫값으로 표현



### 이더리움 지갑

- 이더리움 계정을 관리하는데 도움이 되는 소프트웨어 애플리케이션이라는 의미로 지갑이라는 용어 사용

- 지갑은 사용자의 키를 보유하고, 사용자를 대신해 트랜잭션을 생성하고, 브로드캐스트 O



### 통제와 책임

- 이더리움의 각 사용자가 자금 및 스마트 컨트랙트에 대한 접근을 제어하는 자체 개인키를 관리하고 제어할 수 있어야 한다는 것이다.

- 기본 원칙은 하나의 개인키가 하나의 계정과 동일



:bulb: 새 계정을 만들 때 새 주소로 작은 테스트 트랜잭션만 보내는 것으로 시작하라



### 외부 소유 계정(EOA) 및 컨트랙트

- 외부 소유 계정(Externally Owned Account, EOA)
  - 개인키가 있는 계정. 자금 또는 컨트랙트에 대한 접근 제어
  - 트랜잭션을 시작(initaite)할 수 있음

- 컨트랙트 계정(contract account) 

  - 단순한 EOA가 가질 수 없는 스마트 컨트랙트 코드가 있음
    - 스마트 컨트랙트 코드는 계정 생성 시 이더리움 블록체인에 기록되고 EVM에 의해 실행되는 소프트웨어 프로그램
  - 개인키가 없음. 대신, 스마트 컨트랙트의 코드의 로직으로 제어
  - 스마트 컨트랙트 실행
    - EOA와 마찬가지로, 주소가 있으며, 이더를 보내고 받을 수 있음. 
    - 트랜잭션 목적지가 컨트랙트 주소일 때 트랜잭션과 트랜잭션 데이터를 입력으로 사용하여 컨트랙트가 EVM에서 실행됨
      - 실행할 컨트랙트의 특정 함수와 해당 함수에 전달할 파라미터를 나타내는 데이터(data)가 포함될 수 있음
      - 트랜잭션은 컨트랙트 내의 함수를 호출(call)할 수 있음
  - 컨트랙트는 다른 컨트랙트를 호출해서 컨트랙트에 반응(react)할 수 있다.

  - 등록

    - 블록체인에 컨트랙트를 등록하는 것은 목적지 주소가 제로 어드레스인 특수 트랜잭션을 만드는 것이다. 
      - 제로 어드레스는 컨트랙트를 등록하고자 하는 이더리움 블록체인에 알리는 특별한 주소

    - 컨트랙트가 블록체인에 생성되면 이더리움 주소를 갖게 된다. 누군가가 컨트랙트 주소로 트랜잭션을 보낼 때마다 그 트랜색션을 입력값으로 하여 컨트랙트가 EVM에서 실행된다.





## 4. 암호학



이더리움 기반 기술 중 하나는 암호학



### 키와 주소

- 개인키

  - 개인키는 단순히 무작위로 선택한 숫자
  - 키를 생성하는 가장 중요한 첫 번째 단계는 엔트로피, 무작위성을 확보
  - 계정에 대한 제어권 제공
    - 개인키는 비공개로 유지

- 공개키

  - 이더리움 공개키는 개인키로부터 '단방향으로만' 계산할 수 있음

  - 개인키가 있는 경우 공개키를 계산하기는 쉽지만, 공개키에서 개인키를 계산할 수는 없음
  - 공개키는 타원 곡선 암호화를 통해 생성
  - 계정을 식별

- 계정 주소

  - 개인키에서 직접 파생, 개인키는 **계정**이라고도 불리는 단일 이더리움 주소를 고유하게 결정
  - 이더리움 주소는 해시 함수를 사용하는 공개키 또는 컨트랙트에서 파생한 고유 식별자

  - 모든 이더리움 주소가 공개키-개인키 쌍으로 나타나진 않음. 개인키로 뒷받침되지 않는 컨트랙트를 표시 O



### 공개키 암호화와 암호화폐

- 공개키 암호화
  - 공개키 암호화는 고유한 키를 사용하여 정보를 보호

  - 트랩 도어 함수 : 역산하기 위한 단축키로 사용할 수 있는 비밀 정보가 없으면 거꾸로 계산하기 어려움
  - 서명과 검증
    - 공개키 암호는 고유성을 가진 개인키를 이용해서 서명을 작성하는 행위(Sign)가 가능
    - 개인키로 한 행위에 대해서 상대방이 검증할 수 있는 과정도 필요하기 때문에 공개가 가능한 공개키는 누구나 검증(Verify) 할 수 있도록 공개

- 디지털 서명
  - 디지털 개인키, 이더리움 주소, 디지털 서명을 통해 외부 소유 계정의 이더 소유권을 확립
  - 디지털 서명을 통해 자금의 접근과 통제가 이루어짐
  - 이더리움 트랜잭션은 유효한 디지털 서명이 블록체인에 있어야 함
  - 디지털 서명은 개인키의 소유권을 증명
    - 개인키를 가진 누구나 해당 계정과 해당 계정이 가진 이더를 제어

- 이더리움 트랜잭션 검증

  - 트랜잭션은 기본적으로 특정 이더리움 주소로 특정 계정에 접근하는 요청

    - 이더리움 트랜잭션에선 트랜잭션 자체의 세부사항이 메시지로 사용. 
    - 암호 수학은 메시지를 개인키와 결합하여 개인키를 알아야만 만들 수 있는 코드 생성 방법을 제공 : 디지털 서명

    - 주소에 해당하는 개인키로 생성된 디지털 서명도 함께 보내야 함

  - 타원 곡선 수학이란, 디지털 서명, 트랜잭션 세부 정보, 접근하는 이더리움 주소가 일치하는 확인하여, 트랜잭션이 유효한지 확인할 수 있음을 의미
    - 검증 프로세스에서는 그 트랜잭션이 공개키에 대응되는 개인키에 의해 만들어졌음을 확증할 수 있음



### 암호화 해시 함수

- 해시 함수

  - 임의 크기의 데이터를 고정된 크기의 데이터로 매핑하는데 사용할 수 있는 모든 함수

  - 해시 함수에 대한 입력을 사전 이미지, 메시지, 입력 데이터라고 함

  - 그 결과를 해시라고 함

- 암호화 해시 함수의 주요 속성

  - 결정론 (determinism)
    - 주어진 입력 데이터는 항상 동일한 해시 결과를 생성
  - 검증성 (verifiability)
    - 메시지의 해시 계산은 효율적이다 (선형 복잡성)
  - 비상관성 (noncorrelation)
    - 메시지에 대한 작은 변화는 해시 출력을 너무 광범위하게 변경해야 해서, 원본 메시지의 해시와 상관 관계가 없다
  - 비가역성(irreversibility)
    - 해시로부터 메시지를 계산하는 것은 불가능

  - 충돌 방지 (collision protection)
    - 같은 해시 결과를 생성하는 2개의 서로 다른 메시지를 계산하는 것은 불가능


- 특성

  - 단방향 특성은 입력 데이터를 다시 작성하는 것이 계산적으로 불가능함을 의미

  - 동일한 결과에 해시 처리한 두 입력 데이터 집합을 찾는 것을 해시 충돌





## 5. 지갑



### 지갑

- 개요

  - 넓은 의미
    - 이더리움의 주요 사용자 인터페이스를 제공하는 소프트웨어 애플리케이션

  - 개발자 시작
    - 사용자의 키를 보관하고 관리하기 위해 사용되는 시스템
    - 모든 지갑은 키 관리 구성요소 有

- 지갑 기술의 개요

  - 설계 시 중요 고려사항

    - 편의성과 프라이버시 사이의 균형 맞추기

      - 극단적 편의성 : 하나의 개인키와 주소를 가지고 이를 재사용해서 모든 것을 처리

        => 프라이버시에 대한 악몽 可

      - 극단적 프라이버시 : 모든 트랜잭션에 새로운 키를 사용

        => 관리하기가 몹시 어렵

- 키체인

  - 지갑은 단지 키만 보유 이더 혹은 다른 토큰은 이더리움 블록체인에 기록
  - 이더리움 지갑은 개인키와 공개키 쌍을 포함하는 키체인과 같음

- 유형

  - 비결정적 지갑(nondeterministic wallet)

    - 각기 다른 무작위 수로부터 각각의 키를 무작위적으로 추출

  - 결정적 지갑(deterministic wallet).

    - 모든 키가 시드(seed)라고 하는 단일 마스터 키로부터 파생

    - 모든 키는 서로 관련이 있고, 원래의 시드를 갖고 있다면 다시 키를 파생시킬 수 있음

    - 여러 키 파생 방식 존재

    - 니모닉 코드 단어(mnemonic code words)로 시드 생성

      - 데이터 분실 위험에 따른 더 안전한 결정적 지갑 필요

        => 시드를 단어 목록으로 인코딩하여 생성

      - 복구 단어 목록은 아주 조심스럽게 다루고 절대로 컴퓨터나 휴대전화의 전자파일로 저장하지 말고 종이에 적어서 안전한 곳에 보관 권고



### 비결정적(무작위) 지갑

- 개요

  - 자금을 받을 때마다 새로운 주소(새로운 개인키가 필요)를 사용

    - 이더리움 주소의 재사용을 피하는 것이 좋은 지침으로 간주됨

  - 정기적으로 키 목록을 증가

    => 정기적인 백업이 필요

- 단점

  - 백업 전 데이터를 잃어버리면 자금과 스마트 컨트랙트에 접근할 수 없게 됨
  - 다루기 어려움

:memo:  **키저장소(keystore)**

- 이더리움 클라이언트는 암호문으로 암호화된 단일(무작위 생성된) 개인키가 들어 있는 JSON 인코딩 파일인 키저장소 사용

- 키저장소 형식은 무차별(brute-force), 사전(dictionary), 레인보우 테이블(rainbow table) 공격을 대비해 암호 확장 알고리즘으로 알려진 키 파생 함수(key derivation function, KDF) 사용

:bulb: 간단한 테스트 외에는 비결정적 지갑은 사용 권장 X





### 결정적 지갑

- 개요

  - 단일 마스터 키 또는 단일 시드로부터 파생된 개인키를 포함

  - 시드는 모든 파생된 키를 복구할 수 있다.

- **HD 지갑**
  - 개요
    - HD 지갑은 BIP-32 표준으로 정의된 결정적 지갑
    - 트리 구조로 파생된 키들을 가지고 있음
  - 장점
    - 트리 구조
      - 분기별 다른 용도 지정이 가능하여 구조적인 의미를 표현 O
    - 개인키에 접속하지 않고 사용자가 공개키 시퀀스 생성 O
      - HD 지갑은 보안상 안전하지 않는 서버, 보기 전용, 수신 전용의 용도로 사용 O
      - 자금을 움직이는 개인키를 들어 있지 않게 가능

- 시드와 니모닉 코드(BIP-39)

  - 니모닉
    - 올바른 순서로 단어 시퀀스가 입력되면 고유한 개인키를 다시 만들 수 있음
    - BIP-39에 의해서 표준화

  - 장점
    - 다루기 쉬움
      - 실용적인 측면에서, 16진수 시퀀스를 기록할 때에는 오류가 발생한 확률이 매우 높음
      - 단어 목록은 중복성이 커서 다루기가 매우 쉬움

  - 보안
    - 시드는 종이에 써서 보관할 것을 추천

- 지갑의 모범 사례

  - 유연한 지갑을 만들기 위한 일반적인 사업 표준 등장

    - BIP-39 : 니모닉 코드 단어

    - BIP-32 : HD 지갑

    - BIP-43 : 다목적 HD 지갑 구조

    - BIP-44 복수화폐 및 복수계정 지갑



### 니모닉 코드 단어(BIP-39)

- 용도

  - 니모닉 코드 단어는 결정적 지갑을 파생하기 위해 시드로 사용되는 난수를 인코딩하는 단어 시퀀스

  - 단어 시퀀스는 시드를 다시 만들어내고, 파생된 키들을 재생성할 수 있다.

- 선택적 암호문

  - BIP-39 표준은 시드의 표준에 선택적 암호문을 사용할 수 있음

  - 암호문의 유무 및 암호문의 값을 어떻게 입력하냐에 따라서 각기 다른 시드를 생성

  - 본질적으로 잘못된 암호문은 없음

    - 모든 암호문은 유효하며, 각각 다른 시드를 만듬
    - 가능한 한 초기화되지 않은 많은 지갑을 형성

  - 특징

    - 니모닉 자체만으로는 의미가 없어짐. 니모닉 도난으로부터 보호
      - 협박 받았을 시, 그럴 듯한 가짜 암호문을 제공

    - 암호문의 사용은 손실의 위험 또한 동반
      - 니모닉과 암호문 둘 중 하나만 분실해도 계정 및 자금을 잃어버림
      - 소유자가 암호문을 시드와 동일한 위치에 백업하는 것은 2차 팩터의 목적에 어긋남

​		=> 복구할 수 있는 가능성을 고려해, 신중한 계획 필요



### HD 지갑(BIP-32)과 경로(BIP-43/44)

- 키의 확장

  - 개요
    - BIP-32의 용어로, 키는 확장(extended)될 수 있음
    - 적절한 수학적 연산을 사용하여 확장된 부모키는 자식키를 파생시킬 수 있게 되고, 키와 주소의 계층 구조를 만들 수 있게 됨

  - 체인코드

    - 키를 확장하는 것은 키 자체를 가져와서 특수 **체인 코드**를 추가하는 것
    - 체인 코드는 자식키를 생성하기 위해 각 키와 혼합된 256비트 이진 문자열이다. 

    - 활용

      - 접두어 xprv  => **확장된 개인키**

      - 접두어 xpub => **확장된 공개키**는

- 공개키 생성
  - 부모 공개키에서의 자식 공개키 파생
    - HD 지갑의 매우 유용한 특징으로 부모 공개키에서 자식 공개키를 파생할 수 있음
    - 매우 안전한 공개키 전용 배포 만드는데 사용 O
    - 단지 그 주소로 보낸 돈은 쓸 수 없음
  - 자식 개인키로부터 직접 파생하는 방법과 부모 공개키로부터 직접 파생하는 방법
    - 확장된 공개키는 해당 분기에서 모든 공개키(단지 공개키들만)를 파생하는 데 사용될 수 있다.

- 강화된 자식 키의 파생

  - 확장된 공개키에서의 공개키 분기는 잠재적 위험 존재
    - xpub이 체인 코드를 포함하므로, 만약 하위 개인키가 유출될 경우, 다른 모든 자식 개인키를 파생 O
  - **강화 파생**
    - 부모 공개키와 자식 체인 코드 간의 관계를 끊는 대체 가능 파생 함수
    - 강화 파생 함수는 자식 체인 코드를 파생하기 위해 부모 공개키 대신에 **부모의 개인키를 사용**

  - 보안 권고 사항

    - 유출된 체인 코드의 위험에 노출되지 안고 편리하게 xpub을 이용해 공개키의 분기를 파생하기 위해서는 일반적인 부모가 아닌 강화된 부모로 공개키 분기를 파생

    - 마스터 키의 유출을 방지하기 위해서는 항상 강화 파생으로 파생된 마스터 키의 1단계 자식 사용을 강력히 추천

- 인덱스 번호

  - 개요

    - 여러 개의 자식 키를 파생

    - 관리하기 위해 인덱스 번호 사용

    - 각 인덱스 번호는 부모 키와 결합될 때 각각 다른 자식 키를 만들어냄

  - 분리
    - 0 ~ 2^31-1 : 일반 파생용 인덱스
    - 2^31 ~ 2^32-1 : 강화 파생용 인덱스

  - 표기
    - 다만, 인덱스 번호를 좀 더 읽기 쉽도록 표시하기 위해, 강화 인덱스도 0부터 시작하는 것으로 표현(대신 `'` 붙임) 
    - ex) 첫 번째 강화된 자식(0x80000000)은 `0'`, 두 번째 강회된 자식(0x80000001)은 `1'`으로 표기

- HD 지갑 키 식별자(경로)

  - HD 지갑의 키는 경로 이름 규칙을 사용하여 식별, 트리의 각 레벨은 슬래시(/) 문자로 구분

  - 마스터 개인키에서 파생된 개인키는 m으로 시작하며, 마스터 공개키에서 파생된 공개키는 M으로 시작됨

| HD 경로     | 키 설명                                                      |
| ----------- | ------------------------------------------------------------ |
| m/0         | 마스터 개인키(m)의 첫 번째(0) 자식 개인키                    |
| m/0/0       | 첫 번째 자식(m/0)의 첫 번째 자식 개인키                      |
| m/0'/0      | 첫 번째 강화된 자식(m/0')의 첫 번째 일반 자식                |
| m/1/0       | 두 번째 자식(m/1)의 첫 번째 자식 개인키                      |
| M/23/17/0/0 | 24번째 자식의 18번째 자식의 첫 번째 자식의 첫 번째 자식 공개키 |



### HD 지갑 트리 구조 탐색

- 개요

  - HD 지갑 트리 구조는 대단히 유연함. 무한한 복잡성을 허용

    - 각 부모의 확장 키는 40억 개의 자식을 가질 수 있음

    - 그 자식들은 각각 40억개의 자식들을 가질 수 있음

    => 무한한 세대가 될 수 있음

- BIP-43 / BIP-44

  - HD 지갑의 표준을 만들어 잠재적인 복잡성을 관리할 수 있는 방법을 제공

  - BIP-43

    - 강화된 첫 번째 자식 인덱스를 트리 구조의 목적을 나타내는 특수 식별자로 사용하도록 제안

    - 트리의 구조와 나머지 레벨의 네임스페이스를 식별 => 지갑의 목적을 정의하는 인덱스 번호와 함께 트리 레벨 1 분기만 사용

  - BIP-44

    - 개요

      - 확장된 사양 제공
      - 목적 번호를 44로 설정하여, 복수화폐 복수계정 구조를 제안

    - 구조

      - BIP-44를 따르는 모든 HD 지갑 구조는 하나의 트리 분기(m/44'/*)만을 사용

      - 다섯 가지 트리 레벨로 구성된 구조를 지정

        ```
        m/ purpose' / coin_type' / account' / change / address_index
        ```

        - `purpose'`
          - 항상 `44'`로 설정
        - `coin_type'`
          -  암호화폐의 동전의 유형
          - 이더리움 : `60'`
          - 비트코인 : `44'`
        - `account'`
          - 회계 또는 조직 목적을 위한 별도의 논리적 하위 계좌로 세분화
        - `change`
          - 비트코인을 위한 필드로 특이점(quirk) 포함
          - 2개의 하위 트리
            - 입금 주소 작성용 : 0
            - 잔액 주소 작성용 : 1 ??
          - 이더리움은 단지 입급 경로만 사용 (0 고정)
          - 일반 파생 사용
        - address_index
          -  인덱스 값

    - ex) `M/44'/60'/0'/0/2`
      - 주 메인 계정에서 이더리움 지급을 위한 세번째 입금 주소

























