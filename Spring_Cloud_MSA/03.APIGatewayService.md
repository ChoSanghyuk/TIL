# API Gateway Service



## API Gateway Service

### 역할 및 기능

- proxy 역할
  - 라우팅 설정에 따라서 client 대신 endpoint에 요청을 보내고 응답을 전달함
  - 시스템 내부는 숨기고, 외부의 요청에 적절한 응답
- 기능
  - 인증 및 권한 부여
  - 서비스 검색 통합
  - 응답 캐싱
  - 정책, 회로 차단기 및 Qos 다시 시도
  - 속도 제한
  - 부하 분산
  - 로깅, 추적, 상관 관계
  - 헤더, 쿼리 문자열 및 청구 변환
  - IP 허용 목록에 추가



### Netflix Ribbon

- Spring Cloud에서의 MSA간 통신

  - RestTemplate

  - Feign Client

- Ribbon : Client side Load Balancer

  - 서비스 이름으로 호출
  - Health Check
  - 비동기 방식과 적합 X => 최근 사용 X



## Netflix Ribbon과 Zuul



### zuul 구현

```yml
server:
	port: 8000

spring:
	application:
		name : my-zuul- service

zuul:
	routes:
		first-service:
			path: /first-service/**
			url: http://localhost:8081
		second-service:
			path: /second-service/**
			url: http://localhost:8081
```

- 해당 url에 매핑되는 서비스를 이름으로 접속 O
- zuulFilter을 통해서 logging O









## Spring Cloud Gateway - 기본



### 필요 dependency

- gateway
- eureka-client
- devtools



### application.yml

```yml
server:
  port: 8000

eureka:
  client:
    register-with-eureka: false
    fetch-registry: false
    service-url:
      defaultZone: http://localhost:8761/eureka

spring:
  application:
    name: gateway-service
  cloud:
    gateway:
      routes:
        - id: first-service
          uri: http://localhost:8081/
          predicates: #조건명시
            - Path=/first-service/**
        - id: second-service
          uri: http://localhost:8082/
          predicates:
            - Path=/second-service/**
```

- predicates에 명시된 Path로 요청이 온다면 등록된 uri로 이동
- 이때, 요청된 Path가 그대로 uri뒤에 붙는 방식으로 진행 => 해당 서비스의 controller에서 매핑이 필요



## Spring Cloud Gateway - Filter

spring cloud gateway -filter 적용 2:10



#### Tip

- @Configuration을 표시한 class 안에 @Bean을 등록하게 해주면, 시스템이 가동 전에 설정이 이루어짐



### FilterConfig.java : Filter using Java Code

```java
@Configuration
public class FilterConfig {
    @Bean
    public RouteLocator gatewayRoutes(RouteLocatorBuilder builder){
        return builder.routes()
                .route(r -> r.path("/first-service/**")
                        .filters(f -> f.addRequestHeader("first-request","first-request-header")
                                .addResponseHeader("first-response","first-response-header"))
                        .uri("http://localhost:8081"))
                .route(r -> r.path("/second-service/**")
                        .filters(f -> f.addRequestHeader("second-request","second-request-header")
                                .addResponseHeader("second-response","second-response-header"))
                        .uri("http://localhost:8082"))
                .build();
    }
}
```

- yml 파일 있던 routing 정보는 블락 처리 후 코드 등록



### Service Controller 예제

```java
@RestController
@RequestMapping("/first-service")
@Slf4j
public class FirstServiceController {

    @GetMapping("/welcome")
    public String welcome(){
        return "Welcome to the first service";
    }

    @GetMapping("/message")
    public String message(@RequestHeader("first-request") String header){
        log.info(header);
        return "Hello World in First Service";
    }
}
```





## Spring Cloud Gateway - Eureka 연동



## Spring Cloud Gateway - Load Balancer

