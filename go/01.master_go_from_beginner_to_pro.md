# Master Go (Golang) from Beginner to Pro



## Getting Started



### Main 패키지

- 실행가능한 모듈의 패키지 이름은 main
- **main 안에는 main func이 포함되어야 함**

:bulb: Convention

- `main.go`은 `package main`으로 명명하는것이 컨벤션
- 폴더 이름이 패키지 이름이 되는 것이 컨벤션



### Compile & Build & Run

- `run`
  - it compiles and runs the application. It **doesn’t produce an executable**
  - 코드
    - `go run file.go` 
    - `go run -x main.go` : with detail
- `build`
  - it just compiles the application. It **produces an executable**
  - 코드 
    - `go build file.go` : compiles a bunch of Go source files. It compiles packages and dependencies
    - `go build` :  compile the files in the current directory and will produce an executable file with the name of the current working directory
    - `go build -o app` : produce an executable file called app
      - `go build -o 이름.exe main.go`
  - 타 OS 파일로 생성하기
    - Compiling for Windows: `GOOS=windows GOARCH=amd64 go build -o winapp.exe`
    - Compiling for Linux: `GOOS=linux GOARCH=amd64 go build -o linuxapp`
    - Compiling for Mac: `GOOS=darwin GOARCH=amd64 go build -o macapp`
- `install`
  - it just compiles the application. It **produces an executable**
  - vs build
    - `go build`
      - place the resulting executable in the current directory
    - `go install`
      - move the executable to GOPATH/bin
      - you use paths relative to GOPATH/src



### formatting

- 개요

  - Go strongly suggests certain styles
  - `gofmt` formats a program's source code in an idiomatic way that is easy to read and understand.
  - VSCode 사용 시, 파일 저장 때 마다 자동 실행

- 코드

  - `gofmt -w main.go`
    - -w : overrite the source

  - `gofmt -w -l 폴더명`
    - 폴더명 내 파일 대상

  - `go fmt`
    - 현재 폴더 전체 대상



## Go Basics



### Variable

- 개요

  - created at runtime.
  - **A declared variable must be used** or we get an error
  - `_` is the **blank identifier** and mutes the compile-time error returned by unused variables

- 선언하기 (declare)

  1. var keyword
     - `var x int = 7`
     - `var s1 string; s1 = "Learning Go!"`
  2. Short Declaration Operator
     - `age := 30`

  :bulb: `Go`는 `C`와 기타 언어와 다르게 변수 선언을 왼쪽에서 오른쪽으로 읽을 수 있도록하여 가독성을 높임

- 주요 사용법 및 특징

  - `;`는 한 라인에 여러개 statement  작성용

  - `:=`를 통해 한번에 여러개 선언할 때 선언 변수 중 새거가 하나만 있으면 됨

  - Short declaration은 package scope에서 사용 X

  - Go는 statically typed language

    - complie 시 타입 체크

    - 타입이 명시되어 있거나 추론 가능해야 함

  - Strong type language
    - 다른 타입으로 입력 X



### Naming Convention

- Names start with a letter or an underscore (_)

- Case matters: quickSort and QuickSort are different variables

- Go keywords (25) can not be used as names

- Use the first letters of the words 

  - `var mv int //mv -> max value`

- Use fewer letters in smaller scopes and the complete word in larger scopes 

  ```go
  var packetsReceived int // NOT OK, too verbose 
  var n int //OK -> number of packets received 
  var taskDone bool //ok in larger scopes
  ```

- **Don’t use _** , it’s not idiomatic in GO

  - use camelCase rather than underscores to write multi word names
  - applicable to variables, constants or functions

  ```go
  const MAX_VALUE = 100 // NOT OK
  const N = 100 //OK, IDIOMATIC
  ```

- An **uppercase first letter** has special significance to go

  - it will be **exported**

- write acronyms(두문자어) in all caps

  ```go
  writeToDB // recommended
  writeToDb // not recommended
  ```

- packages are given lower case, single-word names

-  doesn't provide automatic support for getters and setters

  - If you have a field in a struct called owner, 

    => the **getter method** should be called **Owner** (upper case, exported)

    =>  A **setter function**, if needed, will likely be called **SetOwner**.

- one-method interfaces are named by the method name plus an -er suffix: Reader, Writer, Formatter, etc





### Package fmt

:link: https://pkg.go.dev/fmt#Printf

- `Printf`

  - 개요

      ```go
      func Printf(format string, a ...any) (n int, err error)
      ```

      - formats according to a format specifier and writes to standard output
      - 자동 new line X
      
  - format
  
      - `%+d` : 숫자 앞에 `+` 표기하며 출력
  
      - `%.3f` : 소수점 3자리까지만 표기
  
      - `%q` : quoted String
  
      - `%v` : any type
  
          - `%#v` : 타입 + 값
  
      - `%T` : print Type
  
      - `%t` : bool
  
      - `%p` : pointer (address in base 16, with leading 0x)
  
      - `%b` : base2 (2진수)
  
          - `%08b` : 8bit 형식으로 base2 출력 (앞을 0으로 채움)
  
      - `%x` : hexadecimal (16진수)
  
      - `%c` : char (rune) represented by the corresponding Unicode code point
  
          



### Constants

- 개요

  - represent fixed (unchanging) values

  - use constants to avoid possible errors (variables that change when they shouldn’t) or to replace a value only in one place instead of in many places

  - All basic literals (1, 3.4, “hello”, true) are in fact **unnamed constants**

  - **A constant belongs to compile time** and it’s created at compile time

    - Go can not detect runtime errors at compile-time but constants belong to compile time 

      => errors can be detected earlier

- Constant Rule

  1. 수정 불가
  2. runtime에 초기화 불가
  3. constant를 초기화 하는데 varaible 사용 불가
     - 단, string 값에  `len` 메소드를 사용하는 것과 같이 compile 시 값을 알 수 있는 경우는 메소드 사용 가능

- 주요 특징

  - 선언 후 사용 X => 에러  X
  - declare과 동시에 초기화 필요

  :bulb: const 로 선언 불가

- 다중 선언

  ```go
  // 1
  const n, m int = 4, 5
   
  // 2
  const (
      a         = 5   // untyped constant
      b float64 = 0.1 // typed constant
  )
  
  // 3
  const (
      min1 = 500
      max1 //gets its type and value form the previous constant. It's 500
      max2 //in a grouped constants, a constant repeats the previous one -> 500
  )
  ```

- Constant Expression : Typed vs Untyped

  ```go
  const x = 5				// untyped (typeless)
  const y float64 = 1.1	// typed
  
  fmt.Println(x * y) // No Error because x is untyped and gets its type when its used first time (float64).
  ```

  - untyped로 초기화 시, 첫번째 사용에 의해서 implicitly converted되어서 type 지정됨

    :bulb: 일반 variable의 경우, 초기화 시 default type으로 배정

- Iota

  - `const ( )` 내에서 0부터 증가하는 값으로 사용 O
  - 다른 `const ( )` 에서는 다시 처음부터 0부터 증가
  - 중간값을 스킵하고 싶을 때엔 `_` 활용

  ```go 
  // IOTA
  // iota is number generator for constants which starts from zero 
  // and is incremented by 1 automatically.
  
  const (
      c1 = iota
      c2 = iota
      c3 = iota
  )
  fmt.Println(c1, c2, c3) // => 0 1 2
  ```

  



### Data Type

- 개요

  - A type determines a set of values together with operations and methods specific to those values

- 종류

  - predeclared types
  - introduced types 
    - with type declarations 
  - composite types: 
    - ex) array, slice, map, struct, pointer, function, interface, channel types

- **predeclared types (Built-in types)**

  - Numeric types

    - int8, int16, int32, int64
    - uint8, uint16, uint32, uint64
      - used to represent unsigned (positive) integers
    - uint
      - alias for uint32 or uint64 based on platform
    - int
      - alias for int32 or int64 based on platform
    - float32, float64
      - zero before the decimal point separator can be omitted
        - ex)  -.5
      - 정수를 float으로 명시하기 위해서는 숫자 뒤에 `.`
    - complex64, complex128
    - byte
      - alias for uint8
      - used for character value
    - rune
      - alias for int32
      - used for character value

    :bulb: data type 범위 넘어가는 수 입력 시, compile error

  - Bool type

    - pre-defined constants true and false

  - String type

    - Unicode chars written enclosed by double-quotes
    - A string value is a (possibly empty) sequence of bytes

- **Introduced Types**

  - introduce new types using the `type` keyword

- **Composite Types:**

  - Array and Slice Type

    -  a numbered sequence of elements of a single type

    - array : a fixed length

      ```go
      var numbers = [4]int{4, 5, -9, 100}
      fmt.Printf("%T\n", numbers) // =>  [4]int
      ```

    - slice : dynamic length (can shrink or grow )

      ```go
      var cities = []string{"London", "Bucharest", "Tokyo", "New York"}
      fmt.Printf("%T\n", cities) // => []string
      ```

  - Map Type

    - unordered group of elements of one type, indexed by a set of unique keys of another type

    ```go
    balances := map[string]float64{
        "USD": 233.11,
        "EUR": 555.11,
    }
    ```

  - Struct Type (User defined type)

    - A struct is a sequence of named elements, called fields, each of which has a name and a type

    ```go
    type Car struct {
     brand string
     price int
    }
    ```

  - Pointer Type

    -  a variable that stores the memory address of another variable
    - The value of an uninitialized pointer is nil.

  - Function and Interface Type

  - Channel Type

    - provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type



### Operations on Types

- Arithmetic and Bitwise Operators
  - +, -, *, /, %, &, |, ^, <<, >>
- Assignment Operators
  - +=, -=, *=, /=, %=
- Increment and Decrement Statements
  - ++, --
- Comparison Operators
  - ==, !=, <, >, <=, >=
- Logical Operators
  - &&, || , !
- Operators for Pointers
  - &
- Channels
  - <-

:bulb: `Println(x++)` 는 허용 X



### Overflows

- Go는 c, c++, java과 같이 overflow 체크하지 않음
  - 효율성 문제
- int 타입의 경우, overflow 발생 시, 다시 초기값부터 순환
- float 타입의 경우, `+Inf`로 넘어감 (Infinite)



### Converting Numeric Types

- Go에서는 Casting이 아닌 Converting이라 표현

- Go에서는 다른 이름의 type이면 다른 Type

  - int, int64 사이에도 converting이 필요
  - 단, alias 제외

- converting 예시

  - string(99) 

    - int to rune (Unicode code point)

      => the ascii code for symbol c

  - `fmt.Sprintf(format string, a ...any)`

    - 포맷에 변수들을 대입하여 string으로 반환

  - `strconv`

    - common numeric conversions

        ```go
        i, err := strconv.Atoi("-42") 	// string to int
        s := strconv.Itoa(-42)			// int to string
        ```
    
    - ParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values
    
        ```go
        b, err := strconv.ParseBool("true")
        f, err := strconv.ParseFloat("3.1415", 64)
        i, err := strconv.ParseInt("-42", 10, 64)		// 값, 진수, bitSize. 진수가 0일 경우, 값을 보고 유추
        u, err := strconv.ParseUint("42", 10, 64)
        ```
    
        - The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss:
    
    - FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:
    
      ```go
      s := strconv.FormatBool(true)
      s := strconv.FormatFloat(3.1415, 'E', -1, 64)
      s := strconv.FormatInt(-42, 16)
      s := strconv.FormatUint(42, 16)
      ```



### Defined Types (named type)

- 개요

  - a new type created by the programmer from another existing type which is called the **underlying** or **source type**
  - A new defined type must have a new name and can have its new methods
  - The underlying type provides the representation, operations and size of the newly defined type
  - Even though the defined type and the source type share the same representation, operations and size, **they are different types**
  - a completely new type and a type can be **converted** to another type if they share the same underlying type

  - no type-hierarchy in Go

- 용도

  - **attach methods** to newly defined types

  - **Type safety**

    - We must convert one type into another to perform operations with them

  - **Readability**

    - `type usd float64` 

      =>  know that new type represents the US Dollar

- 예시

  ```go
  // new type speed (underlying type uint)
  type speed uint
  
  // s1, s2 of type speed
  var s1 speed = 10
  var s2 speed = 20
  
  // convert
  var x uint
  x = uint(s1)
  ```



### Aliases

- form
  - `type T1 = T2`
    - T2에 대해 새 이름 T1 소개

- 개요
  - **same type with a new name**
  - can be used together in operations without type conversions
  - **shoud use it with caution**, it's not for everyday use



## Program Flow Control in Go



### If, Else If, Else Statement

- 기본
    ```go
    if condition_that_evaluates_to_boolean{
         perform action1
    }else if condition_that_evaluates_to_boolean{
         perform action2
    }else{
         perform action3
    }
    ```
	- non bool value는 조건식에 사용 X

- Simple If Statement

  ```go
  if initialization statement ; condition{
       perform action1
  }else if initialization statement ; condition{
       perform action2
  }else{
       perform action3
  }
  ```

  => 주요 error handling에 이용

  ```go
  // i and err are variables scoped to the if statement only
  if i, err := strconv.Atoi("34"); err == nil {
      fmt.Println("No error. i is ", i)
  } else {
      fmt.Println(err)
  }
  ```

  



### Command Line Arguments: os.Args

- 개요

  - 터미널에서 `go run main.go` 이후의 문자열을 string 배열에 담아서 출력시킴
  - space 단위로 separate
  - 첫번째 인자는 파일의 path, 두번째 인자부터 command argument

- 샘플

  ```go
  fmt.Println("os.Args:", os.Args) // os.Args is slice of strings ([]string)
   
  // accessing command line arguments using indexes
  fmt.Println("Path:", os.Args[0])
  fmt.Println("1st Argument:", os.Args[1])
  fmt.Println("2nd Argument:", os.Args[2])
  fmt.Println("No. of items inside os.Args:", len(os.Args))
  ```



### For Loops

- 개요

  - Go에는 while loop 없음. 오직 for 문

- 형태

  - 기본 형식

  ```go
  for initialization statement ; testing boolean expression ; post statement {
      perform action
  }
  ```

  - post statement은 내부로 이동 O


  ```go
  for initialization statement ; testing boolean expression {
      perform action
      post statement
  }
  ```

  - while 문처럼 사용


  ```go
  for testing boolean expression {
      perform action
      post statement
  }
  ```

  - iterate


  ```go
  for index, value := range arrayVar {
  
  }
  ```

-  기타 문법

  - continue, break문은 타 언어와 동일



### Label Statement

- 개요
  - 코드의 특정 부분을 label로 지정할 수 있음
  - Labels are used in break, continue, and goto statements.
  - It is illegal to define a label that is never used.
  - In contrast to other identifiers, labels are not block scoped and do not conflict with identifiers that are not labels. 
    - They live in another space.
    - label은 변수명과 충돌나지 않음 (ex. outer라는 변수가 존재하여도 outer라는 lable 사용 O)
  - The scope of a label is the body of the function in which it is declared and excludes the body of any nested function.
  - Most of the time labels are used to terminate outer enclosing loops
    - 다중 loop에서 loop에 label을 붙일 수 있음 => 특정 label break

- 코드

    ```go
    outer:	// label, it doesn't conflict with other names
        for index, name := range people {  
            for _, friend := range friends { 
                if name == friend {
                    fmt.Printf("FOUND A FRIEND: %q at index %d\n", friend, index)
                    break outer //breaking outside the outer loop which terminates
                }
            }
        }
    ```

    

### go to statement

- 개요

  - 같은 함수 내 label로 이동
  - `break`, `continue`는 for, switch에서만 사용 가능한 것에 비해 `go to`는 제약 X
  - for문 처럼 사용 O

  :bulb: 단, 새 변수가 선언된 곳 이후의 label로는 `go to` 불가

- 코드

  ```go
  i := 0
  loop: // label
      if i < 5 {
          fmt.Println(i)
          i++
          goto loop
      }
  ```

  

### switch

- 특징

  - case 문 안에 `break` 명시할 필요 X
  - `case A , B :` => A or B와 일치 시 실행

- 코드

  - 기본 형식

      ```go
      language := "golang"
      
      switch language {
          case "Python": //values must be comparable (compare string to string)
              fmt.Println("You are learning Python! You don't use { } but indentation !! ")
          case "Go", "golang": //compare language with "Go" OR "golang"
              fmt.Println("Good, Go for Go!. You are using {}!")
          default:
              // and gets executed if no testing condition is true.
              fmt.Println("Any other programming language is a good start!")
      }
      ```

  - comparing bool

      ```go
      n := 5
      // comparing the result of an expression which is bool to another bool value
      switch true {
          case n%2 == 0:
              fmt.Println("Even!")
          case n%2 != 0:
              fmt.Println("Odd!")
          default:
              fmt.Println("Never here!")
      }
      ```

      - 이때 swtich 옆 true를 생략해도 같은 구문

  - Switch simple statement

      ```go
      switch n := 10; true {
          case n > 0:
              fmt.Println("Positive")
          case n < 0:
              fmt.Println("Negative")
          default:
              fmt.Println("Zero")
      }
      ```




### Scopes in Go

- 개요
  - Scope means visibility.
  - The scope or the lifetime of a variable is the interval of time during which it exists as the program executes.
  - **A name cannot be declared again in the same scope** (for example a function in the package scope), but it can be declared in another scope.
    - scope가 다르면 덮어쓰기 가능
- 종류
  - File Scope
    - import statements
  - Package Scope
    - 블록 밖 선언 (함수 포함)
    - Package Scope에서 선언된 변수는 사용 X해도 에러 나지 않음
  - Block (local) Scope
    - 함수 블록 or 여타 블록 내



## Arrays & Slice



### Arrays

- 개요

  - An array is a composite, indexable type that stores a collection of elements of same type

  - An array has a fixed length

  - Every element in an array (or slice) must be of same type

  - Go stores the elements of the array in continuous memory locations and this way it’s very efficient

  - The length and the elements type determine the type of an array. 
    - The length belongs to array type and it’s determined at compile time
    - `accounts := [3]int{50, 60, 70 }` 
      - The array called accounts that consists of 3 integers has it’s type `[3]int`.

- 코드

  ```go
  var a1 = [4]float64{}                           //initialized with defaults (0)
  var a2 = [3]int{5, -3, 5}                       //initialized with the given values
  a3 := [4]string{"Dan", "Diana", "Paul", "John"} //short declaration syntax
  a4 := [4]string{"x", "y"}                       //initializing only the first 2 elements
  a5 := [...]int{1, 4, 5}							//initializing by using the ellipsis operator (...) 
  a6 := [...]int{1,								// declare an array on multiple lines
      2,
      3,
  }
  balances := [2][3]int{							// declaring a multi-dimensional arrays
      [3]int{5, 6, 7}, 							//[3]int is optional
      {8, 9, 10},
  }
  ```

  - ellipsis operator(...)
    - array 길이 지정을 compiler에게 맡김 => 자동 지정
  - multiple lines declaration
    - for better readability
    - **the ending comma is mandatory**

- Arrays with keyed elements

  ```go
  // each key corresponds to an index of the array
  grades := [3]int{ //the keyed elements can be in any order
      1: 10,
      0: 5,
      2: 7,
  }
  
  // un unkeyed element gets its index from the last keyed element
  cities := [...]string{
      5:        "Paris",
      "London", // this is at index 6
      1:        "NYC",
  }
  ```
  
  - 특정 인덱스의 값을 지정할 수 있음
  
  - 키 미지정 시 default 값
  
    => 대부분이 default값이고 몇몇 index만 값을 가질 때 유용
  
  - ellipsis로 길이 지정 시, 최대 key index값을 기준으로 길이 확정
  - key 미지정하고 값 추가시, 마지막 key index 다음부터의 값으로 추가

- 특징

  - array는 `=`로 복사 시, 깊은 복사
  
    <=> slice는 얕은 복사



### array vs slice

- 차이점

  | Array                                                        | Slice                                                        |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | Has a fixed length defined at compile time                   | Has a dynamic length (it can shrink or grow)                 |
  | The length of an array is part of its type, defined at compile time and cannot be changed | The length of a slice is not part of its type and it belongs to runtime |
  | By default an uninitialized array has all elements equal to zero | An uninitialized slice is equal to nil (its zero value is nil) |

- 공통점

  - Both a slice and an array can contain only the same type of elements
  - We can create a keyed slice like a keyed array



:bulb: nil은 value의 부재를 의미하는 것이 아닌, value가 initialize 되지 않았음을 의미

​	=> slice가 nil인 것은 0 capacity slice인 것을 의미

```go
var nn []int
fmt.Println(nn == nil, cap(nn)) // true

// empty slice but initialized, not equal to nil
mm := []int{}
fmt.Println(mm == nil, cap(mm)) //false
```





### slice

- 초기화

  ```go
  numbers := []int{2, 3, 4, 5} // on the right hand-side of the equal sign is a slice literal
  nums := make([]int, 2)		 // creating a slice with 2 int elements initialized with zero.
  ```
  
- 특징

  - slice에서의 index는 길이보다 작은 값에 한해서 사용 O

    => 길이 초과하는 index 접근 => error

  - `변수 := slice[i]`와 같이 index로 하나의 값을 복사했을 때에는 깊은 복사

  - slice는 오직 nil과만 비교 될 수 있음

    - `==`를 통한 비교는 nil과만 가능

- index

  - slice에서 index는 길이보다 작은 값에 한해서 사용 O

    => 아닐 시 에러

- 비교

  - `==` 는 오직 `nil`하고만 가능
    
    - slice 끼리 `==`를 통한 비교 X
    
  - loop를 통한 비교

    ```go
    var eq bool = true
    if len(a) != len(b) {
        eq = false
    }
    
    for i, valueA := range a {
        if valueA != b[i] {
            eq = false // don't check further, break!
            break
        }
    }

- 복사
  - `dst := src`
    - 얕은 복사
  - `copy(dst,src)`
    - src의 값을 dst로 깊은 복사
    - src와 dst 중 최소 길이 만큼만 복사됨
  - `변수 := slice[i]` 
    - 깊은 복사



### Slice’s Backing (Underlying) Array

- 개요
  - When creating a slice, behind the scenes Go creates a hidden array called Backing Array.
  - The backing array stores the elements, not the slice.
  - Go implements a slice as a data structure called slice header.
- Slice Header 구성
  - **the address** of the backing array (pointer)
  - **the length** of the slice. 
    - `len()` returns it.
  - **the capacity** of the slice. 
    - 해당 slice의 시작 위치부터 backing array의 끝 부분까지의 길이
    - 즉, 얼마큼까지 재할당이 필요없는지를 나타냄
    - `cap()` returns it
- 특징
  - Slice Header is the runtime representation of a slice.
  - A nil slice doesn't a have backing array.
  - slice 변수 자체는 header로 구성되어 있기에, array보다 사이즈가 작을 수 있음



### slice expression

- 개요

  - a slice expression is formed by specifying a start or a low bound and a stop or high bound 
    - `s1[start:stop]`
  - arrays, slices and strings are sliceable
  - slicing doesn't modify the array or the slice, it returns a new one

- 특징

  - **새로운 backing array 생성 X**, backing array 공유

    => 하나만 바뀌어도, backing array를 공유하는 모든 변수들 같이 변경

  - 최대 자신의 capacity만큼 slicing으로 접근 O

    ```go
    s1 := []int{1, 2, 3, 4, 5}
    s2 := s1[:3]
    fmt.Println(s2[:5]) // backing array의 기준 최대치까지 slice 가능
    ```

    :bulb: 단, index로는 자신의 최대 길이까지만 접근 O. `s2[4]` 불가


### append
- 개요

  - slice 마지막 부분에 요소 추가

- 코드

  - `append(s1,e1)` 
    - 단일 요소 추가
  - `append(s1,e1,e2)` 
    - 복수 요소 추가
  - `append(s1,s2...)` 
    - 복수 요소 추가 with ellipsis operator

- 특징

  - capacity를 벗어나지 않는다면, backing array를 수정

    ```go
    s1 := []int{1, 2, 3, 4, 5}
    s2 := s1[0:3]
    s3 := append(s2, 6) // s1 : {1,2,3,6,5}
    ```

  - capicity를 벗어나는 `append`에 대해서는 **새로운 backing array 생성**





## String

### String

- 개요

  - Golang doesn’t have a char data type. It uses byte and rune to represent character values.
    - **byte** and **rune** data types are used to distinguish characters from integer values
  - Characters or rune literals are expressed in Go by enclosing them in single quotes, as in 'x' or '\n' . 
    - Rune literals such as ‘a’ , ‘b’, ‘c’, ‘x’ or ‘\n’ are represented using **Unicode Code** Points. 
    - A code point is a numeric value that represents a rune literal.
  - The character encoding scheme ASCII which is a Unicode subset, comprises 128 code points.
  - A string is a series of bytes values. 
    - A string is a slice of bytes and any byte slice can be encoded in a string value.

- 주요 사용법

  - raw string

      ```go
      s2 := `Hi 
      there Go!` // => `` 안에 있는 형태 그대로 출력
      ```

  - concatenating strings
  
      - `s1 + s2`
  
- 특징

  - **string is immutable** in Go
    - concatenate 시, 완전 새로운 문자열 생성
    - 수정 불가. `s3[5] = 'x' // => error`
  
  - Unicode byte의 series
    - indexing 시, 실제 값이 아닌 Unioce 값 조회
    - `len(s1)` 시, 실제 문자열 길이가 아닌, bytes의 길이 조회
  
- 인코딩

  - `utf8` package

    - `utf8.RuneCountInString(str)` 

      - 실제 문자열 길이 반환

    - `r, size := utf8.DecodeRuneInString(str[i:])`

      - i부터 시작하는 하나의 문자열 반환. 이때 사용된 byte 개수 반환
  
  
  ```go
  for i := 0; i < len(str); {
      // it returns the rune in string in variable r and its size in bytes in variable size
      r, size := utf8.DecodeRuneInString(str[i:]) 
      fmt.Printf("%c", r) 		       // printing out each rune
      i += size           			   // incrementing i by the size of the rune in bytes
  }
  ```
  
  - `range`로 bytes => string
  
    ```go
    str := "안녕하세요"
    
    for i, r := range str { //the first value returned by range is the index of the byte in string where rune starts
        fmt.Printf("%d -> %c", i, r) // => 안녕하세요
    }
    ```
  
  - slicing the rune slice
  
    ```go
    s1 := "안녕하세요"
    fmt.Println(s1[0:3]) // -> 안 - the unicode representation of bytes from index 0 and 2.
    
    // 1st step: converting string to rune slice
    rs := []rune(s1)
    
    // 2st step: slicing the rune slice
    fmt.Println(string(rs[0:3])) // => 안녕하
    ```
  
    - `[]rune(s2)` 로 변환 시, 한 글자씩 표현 가능
  



### String 메소드

- 포함 여부

  - `strings.Contains("I love Go Programming!", "love")`
  - `strings.ContainsAny("success", "xy")`
  - `strings.ContainsRune("golang", 'g')`

- 갯수 카운팅

  - `strings.Count("cheese", "e")`

    :bulb:`strings.Count("five", "")`  => 5

    - if the substr is an empty string, Count() returns 1 + the number of runes in the string

- 변환

  - `strings.ToLower("Go Python Java")`
  - `strings.ToUpper("Go Python Java")`

- 비교

  - `"go" == "go"`
  - `strings.EqualFold("Go", "gO")` 
    - case insensitive하게 비교

- 반복

  - `strings.Repeat("ab", 10)`

- 치환

  - `strings.Replace("192.168.0.1", ".", ":", 2)`
    - `.`을 `:`으로 앞 두개만 치환
  - `strings.Replace("192.168.0.1", ".", ":", -1)`
    - 마지막 인자가 -1일 시, 전부 치환
  - `strings.ReplaceAll("192.168.0.1", ".", ":")`
    - 전부 치환

- 분할

  - `strings.Split("a,b,c", ",")`
    - returns a slice of the substrings
  - `strings.Split("Go for Go!", "")`
    - separator가 `""`일 시, UTF-8 rune literal마다 쪼갬
  - `strings.Fields(myStr)`
    - splitting a string by whitespaces and newlines

- 합침

  - `strings.Join(s, "-")`
    - slice s를 요소 사이사이에 -를 추가해서 반환

- 양 옆 제거

  - `strings.TrimSpace("\t Goodbye Windows, Welcome Linux!\n ")`
    - 공백 제거
  - `strings.Trim("...Hello, Gophers!!!?", ".!?")`
    - 두번째 인자에 나열된 모든 문자를 양 옆에서 제거 (순서 상관 X)




## Maps in Go



### Map

- 개요

  - collection type which stores `key:value` pairs.
  - add, get and delete operations take **constant expected time**.
  - All the keys and the values in a Map are statically typed and must have the same type.
  - The keys in a map must be unique, but the values don’t have to be unique.
  - A Map allows us to quickly access a value using a unique key!
  - We can use any **comparable type as a key** map. 
    - A comparable type is that type that supports the comparing operator which is the double equals sign.
      - slice : X , array : O
    - Even if it’s possible, it’s not recommended to use a float as a key. 
      - A **float has some comparable issues**.
  - We can not compare a map to another map. We can only compare a map to nil.
  - Maps are unordered data structures in Go

- 선언 및 초기화

  ```go
  // declaring a map with keys of type string and values of type string
  var employees map[string]string
  
  // declaring and initializing a map using a map literal
  people := map[string]float64{} // empty map
  // declaring and initializing a map using the make() function:
  map1 := make(map[int]int)
  // declaring and initializing a map using a map literal
  balances := map[string]float64{
  "USD": 233.11,
  "EUR": 555.11,
  "CHF": 600, //this last comma (,) is mandatory when declaring the map on multiple lines
  }
  
  // 에러!! 
  // initializing a map with duplicate keys
  n := map[int]int{1: 3, 4: 5, 6: 8, 1: 4} // => 에러
  ```

- 특징

  - 없는 키로 접근 시,  value type의 zero value 반환

  - if the key exists it updates its value and if the key doesn't exist it adds the key: value pair

    ```go
     balances["USD"] = 500.5
    ```

- 활용

  - comma ok

    - "comma ok" idiom is used to distinguish between a missing key:value pair and an existing key with value zero

    ```go
    v, ok := balances["RON"]
    ```

    - ok : boolean type value which is **true if the key exists** and false otherwise

  - iterate

    ```go
    // iterating over a map
    for k, v := range balances {
        fmt.Printf("Key: %#v, Value: %#v\n", k, v)
    }
    ```

    :bulb: looping through Map is not indicated

    - key, value order changes
    - Map is designed for fast lookup time, not fast looping

  - comparing

    - String으로 전환 후 비교

      ```go
      s1 := fmt.Sprintf("%s", a) // a : Map
      s2 := fmt.Sprintf("%s", b) // b : Map
      s1 == s2
      ```

  - 복사

    - 얕은 복사

      ```go
      // both maps reference the same data structure in memory
      friends := map[string]int{"Dan": 40, "Maria": 35}
      neighbors := friends
      ```

      - When creating a map variable Go creates a pointer to a map header value in memory.
      - The key: value pairs are stored in memory at the address referenced by the map header

    - 깊은 복사

      ```go
      for k, v := range friends {
          colleagues[k] = v
      }
      ```



## Files in Go



### File Package

- 기본 package
  - os
- 추가 기능 제공 package
  - io, bufio
  - ioutil(deprecated)
  - 더 많은 기능을 제공하지만, executable file의 size가 증가



:bulb: `log.Fatal(err)`

- idiomatic way to log error and exit program

- thread safe

```go
if err != nil {
    // log the error and exit the program
    log.Fatal(err) // the idiomatic way to handle errors

}
```



### CREATING A FILE

- `os.Create()`

  - creates a file if it doesn't already exist. If it exists, the file is truncated.

  ```go
  // it returns a file descriptor which is a pointer to os.File and an error value.
  newFile, err := os.Create("a.txt")
  ```



### TRUNCATING A FILE

- `os.Truncate(파일, i:int64)`

  - i만큼의 byte만 남기고 파일 삭제

  ```go
  err = os.Truncate("a.txt", 0) // 0이면 모든 내용 삭제
  ```

- `os.Create()`로 중복 생성



### OPEN & CLOSE AN EXISTING FILE

- Open : `os.Open()`

  ```go
  file, err := os.Open("a.txt") // open in read-only mode
  file, err = os.OpenFile("a.txt", os.O_APPEND, 0644) //OPENING a FILE WITH MORE OPTIONS
  ```

  - flag

    - `os.O_RDONLY` : Read only
    - `os.O_WRONLY` : Write only
    - `os.O_RDWR` : Read and write
    - `os.O_APPEND` : Append to end of file
    - `os.O_CREATE` : Create if none exist
    - `os.O_TRUNC` : Truncate file when opening

    :bulb: can open attributes combined using an `|`(OR) between them

  - file permission mode
    - 개요
      - `notation`,`owner`,`group`,`others`
      - owner, group, others에 대한 권한은 3자리 2진수로 표시되며, 각각 read,write,execute 권한을 나타냄
    - 예시
      - `0`: The leading zero indicates octal notation.
      - `6`: The first digit (from left to right) represents the owner's permission. In octal, `6` is equivalent to `110` in binary, which means read and write permissions are granted to the owner.
      - `4`: The second digit represents the group's permission. In octal, `4` is equivalent to `100` in binary, which means only read permission is granted to the group.
      - `4`: The third digit represents the others' (or public) permission. In octal, `4` is equivalent to `100` in binary, which means only read permission is granted to others.

- Close : `file.Close()`

  ```go
  file.Close() // file은 변수
  ```
  
  :bulb: `defer file.Close()` : `defer`로 메소드의 실행을 현재 메소드의 끝 부분으로 미룰 수 있



### GETTING FILE INFO

- `os.Stat`

  ```go
  var fileInfo os.FileInfo
  fileInfo, err = os.Stat("a.txt")
  ```

  - 기능
    - `fileInfo.Name()`
    - `fileInfo.Size()`
    - `fileInfo.ModTime()`
      - Last modified Time
    - `fileInfo.IsDir()`
    - `fileInfo.Mode()`



### CHECKING IF FILE EXISTS

- `os.IsNotExist(err)`

  ```go
  fileInfo, err = os.Stat("b.txt")
  // error handling
  if err != nil {
      if os.IsNotExist(err) {
          log.Fatal("The file does not exist")
      }
  }
  ```

  

### RENAMING AND MOVING A FILE

- Rename : `os.Rename()`

  ```go
  err = os.Rename(oldPath, newPath) // oldPath, newPath : String
  // error handling
  if err != nil {
      log.Fatal(err)
  }
  ```

- REMOVING A FILE : `os.Remove("aa.txt")`

  ```go
  err = os.Remove("aa.txt")
  // error handling
  if err != nil {
      log.Fatal(err)
  }
  ```

  

### WRITING TO A FILE

- WRITING BYTES TO FILE by `file.Write()`

  ```go
  byteSlice := []byte("I learn Golang! 传")   // converting a string to a bytes slice
  bytesWritten, err := file.Write(byteSlice) 
  ```

  - `bytesWritten`엔 작성된 byte 수 반환

- WRITING BYTES TO FILE by `os.WriteFile()`

  ```go
  bs := []byte("Go Programming is cool!")
  err = os.WriteFile("c.txt", bs, 0644) // ioutil.WriteFile() :  deprecated
  // error handling
  if err != nil {
      log.Fatal(err)
  }
  ```

- WRITING TO FILES USING BUFFER

  - Creating a buffered writer from the file variable using `bufio.NewWriter()`

    ```go
    bufferedWriter := bufio.NewWriter(file)
    bs := []byte{97, 98, 99}						// declaring a byte slice
    bytesWritten, err := bufferedWriter.Write(bs)	// writing the byte slice to the buffer in memory
    ```

  - checking the available buffer

    ```go
    bytesAvailable := bufferedWriter.Available()
    log.Printf("Bytes available in buffer: %d\n", bytesAvailable)
    ```

  - writing a string (not a byte slice) to the buffer in memory

    ```go
    bytesWritten, err = bufferedWriter.WriteString("\nJust a random string")
    ```

  - checking how much data is stored in buffer, just waiting to be written to disk

    ```go
    unflushedBufferSize := bufferedWriter.Buffered()
    log.Printf("Bytes buffered: %d\n", unflushedBufferSize)
    ```

  - Writing from buffer to file.

    ```go
    bufferedWriter.Flush()
    ```

    

### READING FROM A FILE

- READING INTO A BYTE SLICE USING `io.ReadFull()`

  - slice의 크기만큼 읽어서 slice에 담음
  - io.ReadFull() returns an error if the file is smaller than the byte slice.

  ```go
  byteSlice := make([]byte, 2)	 // declaring a byte slice and initializing it with a length of 2
  numberBytesRead, err := io.ReadFull(file, byteSlice)	
  ```

  - numberBytesRead : Number of bytes read

- READING WHOLE FILE INTO A BYTESLICE USING `io.ReadAll()`

  -  reads every byte from the file and return a slice of unknown size

  ```go
  data, err := io.ReadAll(file)
  ```

- READING WHOLE FILE INTO MEMORY USING `os.ReadFile()`

  - reads a file into byte slice
  - this function handles opening and closing the file

  ```go
  data, err = os.ReadFile("test.txt")
  ```

- READING FILES **USING DELIMITER**

  ```go
  scanner := bufio.NewScanner(file)	// file from os.Open()
  // scanner.Split(bufio.ScanLines) : default
  for scanner.Scan() {
      fmt.Println(scanner.Text())
  }
  ```



### READING FROM A CONSOLE

- by scanner

  ```go
  scanner := bufio.NewScanner(os.Stdin)
  scanner.Scan() //it waits for the input and buffers the input untill a new line
  
  // gettting the scanned data
  text := scanner.Text()   // string type
  bytes := scanner.Bytes() // uint8[] slice type
  ```

  - `scanner.Scan() ` : returns false when the scan stops, either by reaching the end of the input or an error



## Struct



### Structs in Go

- 개요
  - A struct is a sequence of **named elements**, called **fields**. 
    - Each of them has a name and a type.
  - similar with class in OOP
    - Unlike traditional Object-Oriented Programming, Go does not have a class-object architecture. 
    - Rather we have structs which hold complex data structures.
  - A structs is nothing more that a schema containing a blueprint of data a structure will hold. 
    - This blueprint is fixed at compile time. 
    - It’s not allowed to change the name or the type of the fields at runtime. 
    - You can’t add or remove fields from a struct at runtime.

- creating a struct type

  ```go
  type book struct {
      title  string //the fields of the book struct
      author string //each field must be unique inside a struct
      year   int
  }
  ```

  ```go
  // combining different fields of the same type on the same line
  type book1 struct {
      title, author string
      year, pages   int
  }
  ```

- initializing 

  - without field name(order matters)

    ```go
    lastBook := book{"The Divine Comedy", "Dante Aligheri", 1320}
    ```

  - :heavy_check_mark:Declaring a new book value by specifying field: value (order doesn't matter)

    ```go
    bestBook := book{title: "Animal Farm", author: "George Orwell", year: 1945}
    ```

    - if we create a new struct value by omitting some fields, they will be zero-valued according to their type

- access to field
  - selecting a field : `lastBook.pages`
  - updating a field : `lastBook.author = "The Best"`
- 비교
  - it can be compared by `==` with each other
- 복사
  - 깊은 복사



### anonymous struct & fields

- anonymous struct

  - a struct with no explicitly defined struct type alias.

    ```go
    diana := struct {
        firstName, lastName string
        age                 int
    }{
        firstName: "Diana",
        lastName:  "Muller",
        age:       30,
    }
    ```

- anonymous fields

  - fields type becomes fields name.

    ```go
    type Book struct {
        string
        float64
        bool
    }
    ```

    ```go
    // mixing anonymous with named fields:
    type Employee1 struct {
        name   string
        salary int
        bool
    }
    ```

    :bulb: 같은 타입을 여러 개 anonymous로 지정 X



### EMBEDDED STRUCTS

- a struct that acts like a field inside another struct.

  ```go
  type Contact struct {
      email, address string
      phone          int
  }
  
  // define a struct type that contains another struct as a field
  type Employee struct {
      name        string
      salary      int
      contactInfo Contact
  }
  ```

  ```go
  john := Employee{
      name:   "John Keller",
      salary: 3000,
      contactInfo: Contact{
          email:   "jkeller@company.com",
          address: "Street 20, London",
          phone:   042324234,
      },
  }
  ```





## Function



:bulb: Go does **not have pass-by-reference** semantics because Go does **not have reference variables**

- reference variables

  - 개념

    - 같은 메모리 주소를 공유하는 변수

        ```c++
        int a = 10;
        int &b = a;
        int &c = b;
        
        printf("%p %p %p\n", &a, &b, &c); // 0x7ffe114f0b14 0x7ffe114f0b14 0x7ffe114f0b14
        ```

  - In Go

    - 변수끼리 같은 메모리 주소를 공유 불가능

    - 같은 메모리 주소를 pointing은 가능

      ```go
      var a int
      var b, c = &a, &a
      fmt.Println(b, c)   // 0x1040a124 0x1040a124
      fmt.Println(&b, &c) // 0x1040c108 0x1040c110
      ```

- pass-by-reference

  - 메소드 파라미터로 넣을 때, 넣는 변수의 메모리 주소를 그대로 쓰는 메소드 변수 (같은 메모리 주소에 대한 alias)




### function

- 개요

  - A function is a small piece of code that is dedicated to a perform a particular task based on some input values.

  - Go recommends writing function names in simple word or camelCase.

  - Within the same package function names must be unique!

  - One of Go's features is that functions and methods **can return multiple values**.

  - Go **doesn’t support function overloading**.

  - main() and int() are predefined function names.

    ```go
    func (receiver) name(parameters) (returns) { //code -> function body here }
    ```

- 선언

  ```go
  // defining a function with no parameters (return 타입 명시는 필수 아님)
  func f1() {
      fmt.Println("This is f1() function")
  }
  
  // defining a function with return type
  func f4(a float64) float64 {
      return math.Pow(a, a)
  }
  
  // defining a function that have two parameters of type int and returns two values of type int
  // 여러 개 return type 반환 가능. 이 경우 ( )로 type들 묶어서 정의
  func f5(a, b int) (int, int) {
      return a * b, a + b
  }
  ```

- short hand notation

  ```go
  func f3(a, b, c int, d, e float64, s string) {
      fmt.Println(a, b, c, d, e, s)
  }
  ```

- named return type

  - return type에 변수명 부여 가능
  - 활용
    - 메소드 내에서 해당 변수 사용 가능
    - short hand notation on return type
    - naked-return (return 키워드 이후 생략 시, 자동으로 named return 반환)
    - short func에서만 사용 권장

  ```go
  func sum(a, b int) (s int) {
      fmt.Println("s:", s) // -> s is a variable with the zero value inside the function
      s = a + b
   
      // it automatically return s
      return // This is known as a "naked" return.
  }
  ```

  

### Variadic functions

- 개념
  - functions that take a variable number of argument
- use case
  1. don't know the number of parameters
  2. don't want to create temporary slice to pass it to function

- 사용법

  - Ellipsis prefix

    - `...` in front of the parameter type makes a function variadic

      => The function may be called with zero or more arguments for that parameter.

  - If the function takes parameters of different types, only the last parameter of a function can be variadic.

- code case

  - creating a variadic function

    ```go
    func f1(a ...int) {
        fmt.Printf("%T\n", a) // => []int, slice of int
        fmt.Printf("%#v\n", a)
    }
    ```

  - mixing variadic and non-variadic parameters

    ```go
    // non-variadic parameters are always before the variadic parameter
    func personInformation(age int, names ...string) string {
        fullName := strings.Join(names, " ")
        returnString := fmt.Sprintf("Age: %d, Full Name:%s", age, fullName)
        return returnString
    }
    ```

    

### Defer

- defer/postpone the execution until the end of surrounding function

- defer 호출 시, stack에 쌓임

  => 먼저 defer한 실행일 수록 나중에 수행



### Anonymous Functions

- 개념

  - which doesn’t contain any name and is declared inline using a function literal
  - can be used as closures.
  - can return function

- 예시

  - declare & execute

    ```go
    func(msg string) {
        fmt.Println(msg)
    }("I'm an anonymous function!")
    ```

  - return function

    ```go
    // function that takes an int as an argument and returns another function that returns an int
    func increment(x int) func() int {
        return func() int {
            x++
            return x
        }
    }
    ```



:bulb: **closure**

- 함수 바깥에 있는 변수를 참조하는 함수값(function value)

  - 함수는 바깥의 변수를 마치 함수 안으로 끌어들인 듯이 그 변수를 읽거나 쓸 수 있다

- 예시

  ```go
  func nextValue() func() int {
      i := 0
      return func() int {
          i++
          return i
      }
  }
   
  func main() {
      next := nextValue()
   
      println(next())  // 1
      println(next())  // 2
      println(next())  // 3
   
      anotherNext := nextValue()
      println(anotherNext()) // 1 다시 시작
      println(anotherNext()) // 2
  }
  ```

  - 익명함수 자체가 로컬 변수로 i 를 갖는 것이 아님 (만약 그렇게 되면 함수 호출시 i는 항상 0으로 설정된다) 
  - 외부 변수 i 가 상태를 계속 유지하는 즉 값을 계속 하나씩 증가시키는 기능 수행





## Pointer



### Pointer 개요

- A pointer is a variable that stores the memory address of another variable.

  - Everything the CPU does is fetching and storing values into memory cells

  - A variable is just a convenient, alphanumeric nickname or label for a memory location.

- A pointer value is the address of a variable or nil if it hasn’t been initialized yet.
- Unlike C, Go has no pointer arithmetic.

:bulb: Go는 Primitive type도 address 다 달라짐



### Pointer 사용

- the `&`(ampersand) operator also known as address of operator returns the memory address of a variable.

  ```go
  name := "Andrei"
  fmt.Println(&name) // -> 0xc0000101e0
  ```

- 초기화

  ```go
  // declaring a pointer without initializing it
  // its zero value is nil
  var ptr1 *float64
  _ = ptr1
  ```

  ```go
  // creating a pointer using new() built-in function.
  p := new(int) // it creates a pointer called p that is a pointer to an int type
  x = 100
  p = &x // initializing p
  ```

- THE DEREFERENCING OPERATOR

  - `*` in front of a pointer is called the dereferencing operator

  ```go
  *p = 10        // If I write *p = 10, this is equivalent to x = 10
  *p = *p / 2    // dividing x through the pointer
  fmt.Println(x) // -> 5
  ```



### Passing pointer to function

- declaring a function that takes in pointers

  - the function **makes a copy of each pointer but they point to the same address** as the originals

  ```go
  func changeValuesByPointer(quantity *int, price *float64, name *string, sold *bool) {
      //changing the values the pointers point to is seen outside the function
      *quantity = 3
      *price = 500.5
      *name = "Mobile Phone"
      *sold = false
  }
  ```

- function that takes pointer to struct

  ```go
  // declaring a function that takes in a pointer to struct value and modifies the value
  func changeProductByPointer(p *Product) {
      (*p).price = 300
      p.productName = "Bicycle"  // (*p).productName 의 축약 버전
      // the changes are seen to the outside world
   
  }
  ```

- :bulb: slice와 map은 pointer로 입력하지 않아도, function에서의 조작이 원래 변수에 반영됨

  - don't store actual data but reference. => pass by value ~> point to same reference

- :bulb: Array는 함수로 pass 권장 X
- :bulb: pass by value is cheaper than pass by reference
  - pass by reference puts pressure on garbage collector



## Methods and Interfaces In Go (OOP)



### Receiver Function 샘플

```go
func (n names) print() {
    // iterating and printing all names
    for i, name := range n {
        fmt.Println(i, name)
    }
}
```

- `n` is called method's receiver

- `n` is the actual copy of the names we're working with and is available in the function.

- `n` is like this or self from OOP
  - Go에는 self 같이 자기 명시 X
  - Input 이름으로 지정하며 주로 type의 앞 글자 사용
- any variable of type names can call this function on itself like `variable_name.print()`



### Receiver Function 개요

- Go doesn't have classes, but you can define methods on defined types
  -  a type may have a method set associated with it which enhances the type with extra behaviour
- receiver belong to type
  - func belong to package

- recevier도 pass by value

  - pointer로 넘겨져야 변경 O

    ```go
    func (c *car) changeCar(newBrand string, newPrice int) {
        (*c).brand = newBrand
        (*c).price = newPrice
        // the changes are seen the outside world
    }
    
    myCar.changeCar // short-cut of (&myCar).changeCar
    ```

- named type이 pointer type일 때에는 receiver 등록 불가

  ```go
  type distance *int
  
  // ERROR ->  invalid receiver type *distance (distance is a pointer type)
  func (d *distance) f() {
  	fmt.Println("say something")
  }
  ```


:bulb: Receiver는 value type과 pointer type 둘 다 선언 가능. 단, value type에 선언된 receiver는 value type과  pointer type 둘 다에서 사용 가능. 이에 반해, pointer type에서 선언된 receiver는 pointer에서만 사용 가능



### Interface

- 개요

  - an interface contains only the signatures of the methods, but not their implementation

    ```go
    type shape interface {
        area() float64
        perimeter() float64
    }
    ```

- 특징

  - Go에서는 Interface implements 명시할 필요 없음
    - 해당 Interface의 모든 메소드를 정의하면, 자동으로 implement 취급


  - dynamic type & polymorphism

    - Interface value는 runtime 중 dynamic하게 하위 타입으로 바뀔 수 있음
      - 단, Interface의 명시된 메소드만 사용 가능

  - zero value for Interface is nil

    

### type assertion

- 개요

  - provides access to an interface’s concrete value

- 사용

  ```go
  // declaring an interface value that holds a circle type value
  var s shape = circle{radius: 2.5}
  
  ball, ok := s.(circle)
  if ok == true {
  fmt.Printf("Ball Volume:%v\n", ball.volume())
  }
  ```

  - 직접적으로 `s.(circle).volume()`을 사용할 수도 있으나, 안전하게 성공 여부 확인 권장



### type switch

- 개요

  - permits several type assertions in series

- 사용

  ```go
  switch value := s.(type) {
  case circle:
      fmt.Printf("%#v has circle type\n", value)
  case rectangle:
      fmt.Printf("%#v has rectangle type\n", value)
  
  }
  ```

  

### Interface Embedding

- 개요

  - Interface 정의 시, 내부에 타 Interface 명시

- 특징

  - Embedding한 Interface의 메소드 모두 사용 O
  - recurssive embedding => compile error

- 사용

  ```go
  type geometry interface {
      shape	// interface
      object	// interface
      getColor() string
  }
  ```

  - shape와 object에서 명시하는 method들 모두 포함됨



### Empty Interface

- 개요

  - 어떠한 method도 정의되지 않은 빈 interface
  - Any Go type satisfies the empty interface => it can represent any value.

  - An empty interface may hold values of any type.

- 사용

  - declaring an empty interface

    ```go
    type emptyInterface interface {
    }
    ```

  - declaring an empty interface value

    ```go
    var empty interface{}
    
    empty = 5
    empty = "Go"
    ```

  - declaring a new struct type which has one field of type empty interface

    ```go
    type person struct {
        info interface{}
    }
    ```

    - unknown type handling

- 주의

  - 꼭 필요한 경우에만 사용
    - runtime 돌리기 전까지 명확한 type알지 못함 => hard to maintain



## Concurrency



### Concurrency vs Parallelism

- Concurrency 
  - Independently executing processes or dealing with multiple things at once
  - load more goroutines at a time. 
    - If one goroutine blocks, another one is picked up and started. 
  - On single core CPU you can run ONLY concurrent applications but they are not run in parallel.
- Parallelism
  - the simultaneous execution of processes
  - multiple goroutines executed at the same time. 
  - It requires multiple CPUs.



### Goroutine

- lightweight thread of execution
  - goroutines are key ingredients to achieve concurrency in Go
  - Goroutines are far smaller that threads, they typically take around 2kB of stack space to initialize compared to a thread which takes a fixed size of 1-2Mb.
- a function that is capable of running concurrently with other functions. 
  - To create a goroutine we use the keyword `go` followed by a function invocation
- a goroutine stack size shrinks and grows as needed.
  - An OS Thread Stack is fixed size
- Scheduling a goroutine is much cheaper than scheduling a thread.
  - OS threads are scheduled by the OS kernel, but goroutines are scheduled by its own Go Scheduler using a technique called m:n scheduling
    - it multiplexes (or schedules) m goroutines on n OS threads.
- Goroutines have no identity
  - There is no notion of identity that is accessible to the programmer.

- maintains the local variable of active and suspended function calls
  - same with Threads



### runtime package

- `NumCPU()`

  - returns the number of logical CPUs or cores usable by the current process.

  ```go
  fmt.Println("No. of CPUs:", runtime.NumCPU()) // => No. of CPUs: 4
  ```

- `NumGoroutine()`

  - returns the number of goroutines that currently exists.

  ```go
  fmt.Println("No. of Goroutines:", runtime.NumGoroutine()) // => No. of Goroutines: 1
  ```

- `GOOS` & `GOARCH`

  - environment variables

  ```go
  fmt.Println("OS:", runtime.GOOS)     // => OS: linux
  fmt.Println("Arch:", runtime.GOARCH) // => Arch: amd64
  ```

- `GOMAXPROCS(n)`

  - sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting.
    - n < 1  : return current setting
    - n >=1 : sets the maximum number of CPUs that can be executing simultaneously

  ```go
  fmt.Println("GOMAXPROCS:", runtime.GOMAXPROCS(0)) // => GOMAXPROCS: 4
  ```

  

### Goroutines and WaitGroups

- 개요

  - main 안에 Goroutine 사용 시, 실행은 되지만 main이 기다려주지 않음
  - main이 다시 실행되고, main 종료 시 다른 Goroutine 종료됨
  - Goroutine 실행을 완료시키기 위해, WaitGroup 사용

- 사용

  1. Create a new variables of a `sync.WaitGroup` (wg)

  2. Call `wg.Add(n)` where `n` is the number of goroutines to wait for
  3. pass the wg as a pointer to function
  4. Execute `defer wg.Done()` in each goroutine to indicate to the WaitGroup that the goroutine has finished executing
  5. Call `wg.Wait()` in main() where we want to block.

- 코드

  ```go
  func f1(wg *sync.WaitGroup) { // wg is passed as a pointer
      fmt.Println("f1(goroutine) execution started")
      for i := 0; i < 3; i++ {
          fmt.Println("f1, i=", i)
          // sleep for a second to simulate an expensive task.
          time.Sleep(time.Second)
   
      }
      fmt.Println("f1 execution finished")
   
      //4.Before exiting, call wg.Done() in each goroutine
      // to indicate to the WaitGroup that the goroutine has finished executing.
      wg.Done() // (*wg).Done()  
  }
   
  func main() {
      fmt.Println("main execution started")
   
      // 1.Create a new instance of sync.WaitGroup (we’ll call it symply wg)
      // This WaitGroup is used to wait for all the goroutines that have been launched to finish.
      var wg sync.WaitGroup
   
      // 2.Call wg.Add(n) method before attempting to launch the go routine.
      wg.Add(1) //  n which is 1 is the number of goroutines to wait for
   
      // Launching a goroutine
      go f1(&wg) // 3. it takes in a pointer to sync.WaitGroup
   
      // 5.
      // Finally, we call wg.Wait()to block the execution of main() until the goroutines
      // in the WaitGroup have successfully completed.
      wg.Wait()
   
      fmt.Println("main execution stopped")
  }
  ```

  

### Data race

- 개요
  - 여러 쓰레드/프로세스가 공유자원에 동시에 접근하려 할 때, 일어나는 경쟁 상황
- 감지
  - `go run -race main.go`으로 실행 시, Data race 발생 감지함



### Mutex

- 개요

  - mutual exclusion
  - make sure only one goroutine can access a variable at a time to avoid conflicts
  -  define a block of code to be executed in mutual exclusion by surrounding it with a call to `Lock` and `Unlock`

- 사용

  1. Declaring a mutex. It's available in sync package
  2. Lock the access to the shared value
  3. Unlock the variable after it's incremented (or use defer)

- 코드

  ```go
  func main() {
   
      const gr = 100
      var wg sync.WaitGroup
      wg.Add(gr * 2)
   
      // declaring a shared value
      var n int = 0
   
      // 1.Declaring a mutex. It's available in sync package
      var m sync.Mutex
   
      for i := 0; i < gr; i++ {
          go func() {
              time.Sleep(time.Second / 10)
   
              // 2.Lock the access to the shared value
              m.Lock()
              n++
   
              // 3.Unlock the variable after it's incremented
              m.Unlock()
   
              wg.Done()
          }()
   
          // Doing the same for the 2nd goroutine
          go func() {
              time.Sleep(time.Second / 10)
              m.Lock()
              defer m.Unlock()
              n--
              wg.Done()
          }()
   
      }
      wg.Wait()
   
      // printing the final value of n
      fmt.Println(n) // the final final of n will be always 0
  }
  ```

  

### channel

- 개요

  - goroutine 간 데이타를 주고 받는 통로
  - make() 함수를 통해 미리 생성되어야 하며, 채널 연산자 <- 을 통해 데이타를 보내고 받는다.
  - blocking operation
    - 상대편이 준비될 때까지 채널에서 대기함으로써 별도의 lock을 걸지 않고 데이타를 동기화하는데 사용
    - 수신자와 송신자가 서로를 기다리는 속성 => Go루틴이 끝날 때까지 기다리는 기능을 구현 O

- 코드

  - Declare & Initialize

    ```go
    // Declaring a channel of type `chan int`
    var c1 chan int
    fmt.Println(c1) // => nil (its zero value is nil)
    
    // Initializing the channel
    c1 = make(chan int)
    fmt.Println(c1) // => 0xc000078060 (the channel stores an address)
    
    // Declaring and initializing a channel at the same time
    c2 := make(chan int)
    
    // Declaring and initilizing a RECEIVE-ONLY channel
    c3 := make(<-chan string)
    
    // Declaring and initilizing a SEND-ONLY channel
    c4 := make(chan<- string)
    ```

  - The **arrow** indicates the direction of data flow

    ```go
    // Sending a value into the channel
    c1 <- 10
    
    // Receiving a value from the channel
    num := <-c1
    ```

  - Waiting for a value to be sent into the channel

    ```go
    fmt.Println(<-c1)
    ```

  - Closing a channel

    ```go
    close(c1)
    ```

    - channel이 closed 되어도, receive에는 문제가 없음
    - 무조건적으로 close 해야하는 것이 아니며, close할 경우 더 이상 send되지 않음을 명시 (range의 끝 정해짐)

  - range channel

    ```go
    for url := range c { 				//It means "wait for the channel to return some values"
        go func(u string) {
            time.Sleep(2 * time.Second) // pause for 2 seconds
            checkURL(u, c)
        }(url)
    }
    ```

- channel에서 응답이 있으면 처리 및 모든 쓰레드까지 끝날때까지 응답이 없었다면 패스

  ```go
  wg.Wait()
  close(ch)
  
  for err := range ch {
    if err != nil {
      return c.Status(fiber.StatusInternalServerError).JSON(
        parameters.NewErrorResponse(
          err.Error(),
        ),
      )
    }
  }
  ```

  





### Unbuffered vs Buffered Channel

- Unbuffered Channel

  - buffer 명시 없이 생성 시, Unbuffered Channel로 생성

    ```go
    c1 := make(chan int) //unbuffered channel
    ```

  - 하나의 값을 send 하였다면, receive 될 때까지 기다림

  -  give stronger synchronization guarantees because every send operation is synchronized with its corresponding receive

- Buffered Channel

  - 생성 시, buffer 크기 명시

    ```go
    c1 := make(chan int, 3)
    ```

  - the sender of this buffered channel will block only when there is no empty slot in the channel

    

### select statement

- 개요

  - the select statement lets a goroutine wait on multiple communication operations
  - A select blocks until one of its cases can run, then it executes that case.
  - can use select with a default clause to implement non-blocking sends, receives
  - Select is only used with channels.

- 코드

  ```go
  go func() {
      time.Sleep(2 * time.Second)
      // sending a message into the channel
      c1 <- "Hello!"
  }()
  
  // starting the second goroutine using an anonymous function
  go func() {
      time.Sleep(1 * time.Second)
      // sending a message into the channel
      c2 <- "Salut!"
  }()
  
  // using select to wait on both goroutines
  for i := 0; i < 2; i++ {
      select {
      case msg1 := <-c1:
          fmt.Println("Received", msg1)
      case msg2 := <-c2:
          fmt.Println("Received", msg2)
  //    case default:			// channel에 값이 없다면 바로 실행됨 => goroutine 기다리지 않음
  //        fmt.Println("no activity", msg2)
      }
      
      
  }
  ```

  - total execution time is only ~2 seconds **since the goroutines executed concurrently**.





## Packages and Moduels



### gopath

- workspace
  - Go programmers typically keep all their Go code in a single workspace.
  - A workspace is nothing more than a directory in your file system whose path is stored in the environment variable called GOPATH.
    - On Windows , it's in %USERPROFILE%\go (For Example: c:\Users\ad\go)
    - On Mac & Linux, it's in: ~/go (For Example: /home/john/go)
  - You can print out the values of the environment variables by running the `go env` command
- Go Workspace (GOPATH) 
  - The workspace directory (GOPATH) contains the following 3 subdirectories at its root
    - src
      - contains the source files for your own or other downloaded packages.
    - pkg
      - contains go package objects a.k.a. package archives. 
      - These are non-executable files or shared libraries ending in .a
    - bin
      - contains compiled and executable Go programs. 
      - When you run go install on a program directory, Go will put the executable file under this folder 
- Go Packages
  - A package is a project directory containing .go files with the same package statement at the beginning. 
  - A package contains many source files each ending in .go extension and belonging to a single directory
  - There are 2 types of packages
    - **executable packages** that generate executable files which can be run. The name of an executable package is predefined and is **called main**.
    - **non-executable packages** (libraries or dependencies) that are used by other packages and can have any name. They can not be executed, only imported.



### Package

- files in same directory should belong to same package
- import 시, directory name으로 명시
  - name of the files in the packages doesn't matter (package directory가 중요)
  - package 내용 사용할 때에는 package 이름으로 접근
  - :memo: directory name과 package name 같게 설정 권장
  
- import paths are relative to `$GOPATH/src`
  - :memo: 경로에 non-ASCII코드 있으면 에러 가능성 有 => `$GOROOT/src` 참조

- Function's name should start with capital letter to be exported
  - public function
- 동일한 package도 alias만 설정한다면 중복 import O



### scope

- file scope
  - import 문

- package scope
  - const, variable, function

- local scope





### init method

- 개요
  - 파라미터, return type 없음
  - pakcage initialize 될 때 실행
  - `main()`보다 항상 먼저 실행
  - 별도 실행 불가
  - multiple init func O
- 용도
  - initialize global varaiable that can not be initialized otherwise in global context
    - ex) array, slice를 for문으로 값 설정 (for 문은 method 밖에서 실행 X)



### Module

- 개요
  
  - 모듈은 패키지(Package)의 모음으로써, 한 개의 모듈은 다수의 패키지를 포함할 수 있음 (Go path 대체 O)
  - 패키지들의 종속성을 관리
  - 패키지를 트리 형식으로 관리하며, 루트(root) 폴더에 `go.mod` 파일을 생성하여 모듈을 정의하고, 종속성 정보를 관리
    - A file called `go.mod` defines the module’s path, which is also the import path, and its dependency requirements
  
- 모듈 생성

  - `go mod init MODULE_NAME`

    - 모듈의 이름은 유니크해야 함

      => GitHub 저장소 주소를 활용 or URL 사용

- 모듈 import

  - 공통
    - package 단위로 import
    - 외부 패키지를 사용할 땐, 모듈 내에서 `go mod tidy`로 외부 패키지를 다운로드 필요  (필요한건가???)
  - local 모듈
    - 모듈을 원격에서 가져오는 것이 아닌, local에서 가져옴을 명시해야 함
    - `go mod edit -replace MODULE_NAME=../greeting`
  - 원격 모듈
    - github url 앞 http 생략

- 모듈 버전 관리

  - 모듈 git repository에 올릴 때 버전 표시

    ```bash
    git tag v1.0.0
    git push origin master -- tags
    ```

    ```
    git tag v1.0.1
    git push --tag ???
    ```

  - 새 버전의 모듈 사용 시, 사용하고자 하는 모듈의 폴더에서 manually update 필요

    - 특정 버전 사용 시, 뒤에 `@버전` 첨부

      ```bash
      go get MODULE_NAME@v1.0.1
      ```

    - 최신 버전 사용 시

      ```bash
      go get -u MODULE_NAME
      ```

  - :bulb: Semantic Version

    - major.minor.patch version

- 모듈 변경 사항 적용

  ```bash
  go mod tidy
  ```

  1. **Adds Missing Dependencies**
     - add dependencies which are necessary but are not yet listed in your `go.mod` file.
  2. **Removes Unused Dependencies**
     - removes any dependencies listed in your `go.mod` file that are not necessary
  3. **Updates Module Dependencies**
     - updates the module's dependencies according to the versioning rules specified in your `go.mod` file.
  4. **Prunes Unnecessary Versions**
     - removes any versions of dependencies that are no longer necessary





2.. git에서 버전관리하면서 모듈 활용  (stored locally in GOPATH/pkg/mod   ===> 안되던데... git에 올려보면서 확인해봐)

3.. checksum 파일 역할 및 왜 안 생기는지  (checksum ??? "Importing and Using go module" 7분대)



