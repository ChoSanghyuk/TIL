# GO í™œìš©



## ì„¤ì¹˜ / ì—…ë°ì´íŠ¸



### ì„¤ì¹˜

- Linuxì—ì„œëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ` /usr/local/`ì— ì„¤ì¹˜í•¨
- `sudo tar -C /usr/local -xzf go{ë²„ì „}.tar.gz`

- ì´í›„ í™˜ê²½ ë³€ìˆ˜ ì„¤ì • í•„ìš” : 
  - `export PATH=$PATH:/usr/local/go/bin`
- í•„ìš”ì‹œ, go ëª¨ë“ˆ í™˜ê²½ ë³€ìˆ˜ ë“±ë¡
  - `export PATH=$PATH:$(go env GOPATH)/bin`



### ì—…ë°ì´í„°

- ì—…ë°ì´í„° = ì‚­ì œ + ì¬ì„¤ì¹˜
- ì‚­ì œ : `sudo rm -rf /usr/local/go`



## Convention



### íŒ¨í‚¤ì§€

- íŒ¨í‚¤ì§€ëŠ” ê°ê° ê³ ìœ ì˜ ëª¨ë“ˆë¡œì„œ ê¸°ëŠ¥. ë†’ì€ ì‘ì§‘ë„ì™€ ë‚®ì€ ê²°í•©ë„ ì¶”êµ¬

  - íƒ€ íŒ¨í‚¤ì§€ì˜ structë¥¼ ì‚¬ìš©í•  ê²½ìš°, ë‚´ë¶€ì— í•„ìš”í•œ ê¸°ëŠ¥ë§Œì„ ê°€ì§„ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•˜ê³  íƒ€ íŒ¨í‚¤ì§€ êµ¬í˜„ì²´ëŠ” ë³„ë„ë¡œ ì£¼ì…ë°›ì•„ì„œ ì‚¬ìš©

    => íŒ¨í‚¤ì§€ê°„ ì§ì ‘ì ì¸ ì˜ì¡´ë„ë¥¼ ë‚®ì¶¤

  - ë‹¤ë§Œ, handlerì™€ modelê³¼ ê°™ì€ ê²½ìš°ì—ëŠ” ê°•í•œ ê²°í•©ì„ ê°€ì§ˆ í•„ìš”ë„ ìˆë‹¤ê³  íŒë‹¨ë¨

- ë¶ˆí•„ìš”í•œ ë‚´ë¶€ íŒ¨í‚¤ì§€ ìƒì„±ì€ ì§€ì–‘ë¨

  - Goì—ì„œ ë‚´ë¶€ íŒ¨í‚¤ì§€ëŠ” í•˜ìœ„ ëª¨ë“ˆì˜ ê°œë…ë³´ë‹¤ëŠ” ë³„ë„ì˜ ëª¨ë“ˆë¡œ ì·¨ê¸‰



### ì—ëŸ¬

- Golangì—ì„œ errorëŠ” callerê°€ ì²˜ë¦¬í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•¨

  > Avoid duplication. If you return an error, itâ€™s usually better not to log it yourself but rather let the caller handle it. The caller can choose to log the error, or perhaps rate-limit logging using rate.

- ì—ëŸ¬ ì¤‘ì²©

  - `errors.Wrap(err, message)`: í˜¸ì¶œ ìŠ¤íƒ ì¶”ê°€
  - `errors.WithMessage(err, message)`: í˜¸ì¶œ ìŠ¤íƒì€ ì¶”ê°€í•˜ì§€ ì•Šê³  messageë§Œ ì¶”ê°€
  - `fmt.Errorf("%w", err)`
  - `errors.Join`
  
- ì—ëŸ¬ ë©”ì‹œì§€

  - ì—ëŸ¬ ë©”ì‹œì§€ëŠ” ì²« ê¸€ì ì†Œë¬¸ìë¡œ




### ì„¤ì •íŒŒì¼

- ê³ ë ¤ì‚¬í•­
  - í”„ë¡œì íŠ¸ì˜ ë³µì¡ë„ë¥¼ ê³ ë ¤í•´ì„œ, íŒ¨í‚¤ì§€ ê°„ ê²°í•©ë„ë¥¼ ì¡°ì •
- ë°©ì•ˆ
  1. config íŒ¨í‚¤ì§€ì˜ ë³€ìˆ˜ë¥¼ íƒ€ íŒ¨í‚¤ì§€ì—ì„œ ì§ì ‘ì ìœ¼ë¡œ ì˜ì¡´
     - ë§¤ìš° ê°•í•œ ê²°í•©ë„ë¡œ, ì¼ë°˜ì ìœ¼ë¡œ ì§€ì–‘ë¨
     - ë‹¨ì 
       - Tight Coupling ê°•í•œ ê²°í•©ë„ë¡œ ì¸í•´, íƒ€ íŒ¨í‚¤ì§€ ì˜í–¥ë„ ì—†ì´ config ë³€ìˆ˜ ìˆ˜ì •ì´ ì–´ë ¤ì›Œì§
       - Global State Issue : íƒ€ íŒ¨í‚¤ì§€ì—ì„œ ì§ì ‘ì ìœ¼ë¡œ ë³€ìˆ˜ ìˆ˜ì •ì´ ê°€ëŠ¥í•´ì ¸, ì˜ˆìƒì¹˜ ëª»í•œ ìˆ˜ì •ì´ ì´ë£¨ì–´ì§ˆ ìˆ˜ ìˆìŒ
       - Testing Challenges : í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ëª© ìƒì„±ì˜ ì–´ë ¤ì›€
  2. config íŒ¨í‚¤ì§€ì˜ ë³€ìˆ˜ íƒ€ì…ë§Œì„ ì˜ì¡´í•˜ê³ , ì‹¤ì œ ë³€ìˆ˜ëŠ” ì™¸ë¶€ì—ì„œ ì£¼ì…ë°›ìŒ
     - ì¼ì • ìˆ˜ì¤€ ë””ì»¤í”Œë§ëœ êµ¬ì¡°ë¡œ, config íŒŒì¼ì— ê²°í•©ë„ë¥¼ ê°€ì§„ í”„ë¡œì íŠ¸ì—ì„  í¸ì˜ì„±ê³¼ ì•½í•´ì§„ ê²°í•©ë„ ì¸¡ë©´ì—ì„œ ì‚¬ìš© ê°€ëŠ¥
     - ë‹¨ì 
       - config ìˆ˜ì • ì‹œ, íƒ€ íŒ¨í‚¤ì§€ ì˜í–¥ë„ ì¡´ì¬
  3. ê° íŒ¨í‚¤ì§€ë§ˆë‹¤ í•„ìš”í•œ  interfaceë¥¼ ì •ì˜í•˜ê³ , config ë³€ìˆ˜ë¥¼  interfaceì˜ êµ¬í˜„ì²´ë¡œì¨ ì™¸ë¶€ì—ì„œ ì£¼ì…ë°›ì•„ ì‚¬ìš©
     - ë§¤ìš° ë‚®ì€ ê²°í•©ë„ë¡œ, ì´ë¡ ìƒ ì§€í–¥ë¨
     - ë‹¨ì 
       - ì¼ë°˜ì ìœ¼ë¡œ í”„ë¡œì íŠ¸ëŠ” config íŒŒì¼ì— ê°•í•œ ê²°í•©ë„ë¥¼ ê°€ì§€ê¸° ë•Œë¬¸ì—, ë¶ˆí•„ìš”í•œ interface ì •ì˜ì™€ êµ¬í˜„ì´ ìˆ˜ë°˜ë  ìˆ˜ ìˆìŒ





## API

### urlì— hanlder ë¶€ì°©

```go
func main() {
	http.HandleFunc("/", messageHandler)
}

func messageHandler(w http.ResponseWriter, r *http.Request) {
	// ...
}
```



### Http methodë³„ ë¶„ë¦¬

```go
func messageHandler(w http.ResponseWriter, r *http.Request) {

	switch r.Method {
	case "GET":
		// ...
	case "POST":
		// ...
	}

}
```



### Get ìš”ì²­ ë°˜í™˜

```go
func messageHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello, this is the message from the API!")
}
```



### Struct type request Bodyì— ì €ì¥í•˜ì—¬ ìš”ì²­ë³´ë‚´ê¸°

```
query, err := json.Marshal(besuQuery) // besuQuery : struct
if err != nil {
  panic(err)
}

req, err := http.NewRequest("POST", url, bytes.NewReader(query))
if err != nil {
  panic(err)
}

req.Header.Set("Content-Type", "application/json")

client := &http.Client{}
resp, err := client.Do(req)
```







### Postë¡œ ë°›ì€ Json Body ì €ì¥í•˜ê¸°

```go
type Post struct {
	ID    int    `json:"id"`
	Title string `json:"title"`
	Body  string `json:"body"`
}

func messageHandler(w http.ResponseWriter, r *http.Request) {
	var newPost Post
    err := json.NewDecoder(r.Body).Decode(&newPost)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    } else {
        fmt.Printf("%v\r", newPost)
    }
}
```

:bulb: **struct tags**

- `json:"id"`, `json:"title"`, `json:"body"` ë“±ì€ ê°ê°ì˜ í•„ë“œì— ëŒ€í•œ struct tag
- JSON encoderì™€ decoderì—ê²Œ ê°€ì´ë“œë¥¼ ì£¼ëŠ” ì—­í• ë¡œ, encodingê³¼ decoding ì‹œ, jsonê³¼ í•´ë‹¹ structì„ ì–´ë–»ê²Œ ë§¤í•‘í•  ì§€ ì•Œë ¤ì¤Œ
- ì˜ˆë¥¼ ë“¤ì–´, POST bodyë¡œ id, title, bodyì˜ í‚¤ ê°’ì€ ê°ì ë§¤í•‘ëœ ë³€ìˆ˜ì— ë“¤ì–´ê°€ë©°, ì´ì™¸ì˜ í‚¤ë¡œ ì˜¨ ê°’ë“¤ì€ ë³€ìˆ˜ì— ì €ì¥ X



### Response Body Stringìœ¼ë¡œ ì½ê¸°

```go
res, err := http.Get(url)
if err != nil {
    log.Fatal(err)
}
defer res.Body.Close()

// show me the content of body
body, err := io.ReadAll(res.Body)
if err != nil {
    fmt.Println("Error:", err)
    return
}

// Convert the response body to a string and print it
fmt.Println(string(body))
```







## íŒŒì¼ ì‹œìŠ¤í…œ



### íŒŒì¼ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°

- pwd ê²½ë¡œ

  ```go
  pwd, err := os.Getwd()
  if err != nil {
      os.Exit(1)
  }
  ```

- í•´ë‹¹ í•¨ìˆ˜ ì‹¤í–‰í•˜ê³  ìˆëŠ” íŒŒì¼ ê²½ë¡œ

  ```go
  _, f, _, ok := runtime.Caller(0)
  if !ok {
      panic("runtime Caller Error")
  }
  dir := filepath.Dir(f)		// ê²½ë¡œë§Œ ê°€ì ¸ì˜¤ê¸°
  ```

  

### íŒŒì¼ ì½ê¸°

```go
k, err := os.ReadFile(dir + "/key.json")
if err != nil {
    panic(err)
}
```



### Json Handling

- Json => Map

  ```go
  var BesuKey = make(map[string]map[string]string)
  json.Unmarshal(k, &BesuKey)
  ```

  

## ì‹œê°„



### í˜„ì¬ ì‹œê° êµ¬í•˜ê¸°

- mili second

  ```go
  s := time.Now().UnixMilli()
  ```


- `YYYYMMDDHH24MISS` í¬ë§· ì¶œë ¥

  ```
  time.Now().Format("20060102150405")
  ```

  



## ëª¨ë“ˆí™”



### ëª¨ë“ˆ ê´€ë¦¬

- ëª¨ë“ˆ ìƒì„±
  - `go mod init {ëª¨ë“ˆì´ë¦„}`
- ëª¨ë“ˆì— í•„ìš”í•œ ì¢…ì†ì„± ë‹¤ìš´
  - `go mod tidy`
- ì¢…ì†ì„± ë²¤ë”ë¡œ ê´€ë¦¬
  - `go mod vendor`











## í…ŒìŠ¤íŠ¸



### í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„±

- ìƒì„± ìœ„ì¹˜ 

  1. ë³„ë„ Test package ìƒì„±

     => ìš´ì˜ packageì— ì‹¤ ì‚¬ìš© íŒŒì¼ë“¤ë§Œ ë“¤ì–´ìˆê²Œ ë¨. ë‹¨, private ë©”ì†Œë“œ í…ŒìŠ¤íŠ¸ ë¶ˆê°€

  2. í˜„ì¬ packageì—ì„œ test íŒŒì¼ ìƒì„±

     => private ë©”ì†Œë“œ í…ŒìŠ¤íŠ¸ O

- íŒŒì¼ ì´ë¦„

  - `{ê¸°ì¡´íŒŒì¼}_test.go`



### í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œ 

```go
func Testí•¨ìˆ˜ì´ë¦„(t *testing.T) {
	// ìˆ˜í–‰ ì½”ë“œ
}
```



### í…ŒìŠ¤í¬ ì„±ê³µ ê²°ê³¼ ì§€ì •

- ë¹„êµ ì‹œ, ì¼ì¹˜

  ```go
  assert.Equal(t, var1, var2)
  ```

  



### í…ŒìŠ¤íŠ¸ ì»¤ë§¨ë“œ ì‹¤í–‰

- ë‹¨ì¼ ë©”ì†Œë“œ ì‹¤í–‰
  - `go test -run {regexp}`
- timeout ì„¤ì •
  - `go test -timeout {minute}`
    - 0ìœ¼ë¡œ ì„¤ì • ì‹œ, no timeout
- ì¶œë ¥ ì„¤ì •
  - `go test -v`
    - í…ŒìŠ¤íŠ¸ ì„±ê³µ ì‹¤íŒ¨ ì—¬ë¶€ì™€ ìƒê´€ ì—†ì´ ì½˜ì†” ì¶œë ¥ (defaultëŠ” ì„±ê³µ ì‹œ print X)



### í…ŒìŠ¤íŠ¸ ìºì‹œ ì‚­ì œ

```text
go clean -testcache
```





## ë¡œê¹…: zerolog



### custom logger ìƒì„±

```go
zerolog.New(os.Stdout).With().Str("Module", "EventHandler").Timestamp().Logger()
```



### ê¸°ë³¸ log api ì‚¬ìš©

```go
import "github.com/rs/zerolog/log"

log.Info().Str("endpoint", c.Path()).Msg("Request endpoint")
```

- `io.Writer` interfaceì— ì‘ì„±í•˜ë©°, `os.Stderr` ì„ ì‚¬ìš©í•¨



### `os.Stdout` vs `os.Stderr`

| Use Case                            | `os.Stdout`      | `os.Stderr`               |
| ----------------------------------- | ---------------- | ------------------------- |
| Print app results                   | âœ…                | ğŸš«                         |
| Log info/debug                      | âœ…                | âœ…                         |
| Log warnings/errors                 | ğŸš«                | âœ…                         |
| Output to a file: `./app > out.txt` | âœ… (goes to file) | âŒ (still shows on screen) |



:link: https://betterstack.com/community/guides/logging/zerolog/
