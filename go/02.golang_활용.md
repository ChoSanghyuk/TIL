# GO 활용



## 설치 / 업데이트



### 설치

- Linux에서는 기본적으로 ` /usr/local/`에 설치함
- `sudo tar -C /usr/local -xzf go{버전}.tar.gz`

- 이후 환경 변수 설정 필요 : 
  - `export PATH=$PATH:/usr/local/go/bin`
- 필요시, go 모듈 환경 변수 등록
  - `export PATH=$PATH:$(go env GOPATH)/bin`



### 업데이터

- 업데이터 = 삭제 + 재설치
- 삭제 : `sudo rm -rf /usr/local/go`



## API

### url에 hanlder 부착

```go
func main() {
	http.HandleFunc("/", messageHandler)
}

func messageHandler(w http.ResponseWriter, r *http.Request) {
	// ...
}
```



### Http method별 분리

```go
func messageHandler(w http.ResponseWriter, r *http.Request) {

	switch r.Method {
	case "GET":
		// ...
	case "POST":
		// ...
	}

}
```



### Get 요청 반환

```go
func messageHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello, this is the message from the API!")
}
```



### Post로 받은 Json Body 저장하기

```go
type Post struct {
	ID    int    `json:"id"`
	Title string `json:"title"`
	Body  string `json:"body"`
}

func messageHandler(w http.ResponseWriter, r *http.Request) {
	var newPost Post
    err := json.NewDecoder(r.Body).Decode(&newPost)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    } else {
        fmt.Printf("%v\r", newPost)
    }
}
```

:bulb: **struct tags**

- `json:"id"`, `json:"title"`, `json:"body"` 등은 각각의 필드에 대한 struct tag
- JSON encoder와 decoder에게 가이드를 주는 역할로, encoding과 decoding 시, json과 해당 struct을 어떻게 매핑할 지 알려줌
- 예를 들어, POST body로 id, title, body의 키 값은 각자 매핑된 변수에 들어가며, 이외의 키로 온 값들은 변수에 저장 X



### Response Body String으로 읽기

```go
res, err := http.Get(url)
if err != nil {
    log.Fatal(err)
}
defer res.Body.Close()

// show me the content of body
body, err := io.ReadAll(res.Body)
if err != nil {
    fmt.Println("Error:", err)
    return
}

// Convert the response body to a string and print it
fmt.Println(string(body))
```







## 파일 시스템



### 파일 경로 가져오기

- pwd 경로

  ```go
  pwd, err := os.Getwd()
  if err != nil {
      os.Exit(1)
  }
  ```

- 해당 함수 실행하고 있는 파일 경로

  ```go
  _, f, _, ok := runtime.Caller(0)
  if !ok {
      panic("runtime Caller Error")
  }
  dir := filepath.Dir(f)		// 경로만 가져오기
  ```

  

### 파일 읽기

```go
k, err := os.ReadFile(dir + "/key.json")
if err != nil {
    panic(err)
}
```



### Json Handling

- Json => Map

  ```go
  var BesuKey = make(map[string]map[string]string)
  json.Unmarshal(k, &BesuKey)
  ```

  

## 시간



### 현재 시각 구하기

- mili second

  ```go
  s := time.Now().UnixMilli()
  ```

  



## 모듈화



### 모듈 관리

- 모듈 생성
  - `go mod init {모듈이름}`
- 모듈에 필요한 종속성 다운
  - `go mod tidy`
- 종속성 벤더로 관리
  - `go mod vendor`











## 테스트



### 테스트 파일 생성

- 생성 위치 

  1. 별도 Test package 생성

     => 운영 package에 실 사용 파일들만 들어있게 됨. 단, private 메소드 테스트 불가

  2. 현재 package에서 test 파일 생성

     => private 메소드 테스트 O

- 파일 이름

  - `{기존파일}_test.go`



### 테스트 메소드 

```go
func Test함수이름(t *testing.T) {
	// 수행 코드
}
```





### 테스트 커맨드 실행

- 단일 메소드 실행
  - `go test -run {regexp}`
- timeout 설정
  - `go test -timeout {minute}`
    - 0으로 설정 시, no timeout
- 출력 설정
  - `go test -v`
    - 테스트 성공 실패 여부와 상관 없이 콘솔 출력 (default는 성공 시 print X)

