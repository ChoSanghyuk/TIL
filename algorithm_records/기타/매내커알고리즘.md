# Manacher's algorithm

## 개요

​	Manacher 알고리즘은 문자열이 주어졌을 때, 문자열 안에서 가장 긴 회문(palindrome)을 찾는 알고리즘이다. 기본 방식으로는 길이가 홀수인 회문만 찾을 수 있으며, 길이가 짝수인 회문이 존재하는 경우, 문자열 양끝과 모든 문자 사이에 `#`과 같은 임의의 문자를 넣어서 회문을 찾을 수 있다. 여기서는 길이가 홀수인 회문의 경우로 한정하겠다. 



## 기본 원리

​	동작 원리는 다음과 같다.

1. 문자열을 순서대로 탐색하며 해당 글자를 중심으로 회문이 형성되어 있는지 확인한다.

2. 회문임이 판독된다면, 그 회문의 반지름과 끝나는 지점, 중심점을 기록한다.

3. 발견한 가장 긴 회문의 영역안에서 또다른 회문이 발견된다면 해당 경우는 다음 3가지 경우로 한정된다.

   현재 위치를 i , 이전 회문의 중심을 j라 할 때,

   1. i를 중심으로한 회문이 j를 중심으로 하는 회문에 완전히 포함되는 경우
   2. i를 중심으로한 회문이 j를 중심으로 하는 회문과 일부 겹치는 경우
   3. i를 중심으로한 회문이 j를 중심으로 하는 회문을 완전히 포함하는 경우

4. 1번의 경우, j 회문 안에 i와 똑같이 대칭되는 회문이 `반드시` 존재한다. 고로 대칭되는 회문의 정보를 받아와 저장한다.

5. 2,3번의 경우, i회문과 j회문의 겹치는 부분까지는 j 회문안에 대칭되는 회문이 존재한다. (최소한의 회문이 보장되어 있다.) 고로 j회문의 끝 지점부터 이후에도 회문인지 판독을 한다.

6. 이 순서를 반복하며 진행한다.



## 코드

```java
// i를 중심으로 하는 회문의 반지름을 저장합니다.
static int[] arr = new int[234567]

public static void manacher(String s, int len){
    // rad : 탐색된 가장 긴 회문의 끝 지점 cen : 탐색된 가장 긴 회문의 중심
    int rad=0;
	int cen=0;
    // 탐색 시작
    for(int i=0; i<len; i++){
        // i <= rad : 발견된 가장 긴 회문의 안에 있음. 이 경우 초기값 설정 (아래 #1번에서 부가 설명)
        if(i <= rad) arr[i] = min(rad-i, arr[2*cen-i]);
        // 발견된 회문 밖이라면 0부터 탐색 시작
        else arr[i] = 0;
        
        // 회문이 문자열 범위 안이고 초기값을 기준으로 대칭이 이뤄진다면 계속 반지름 증가
        while(i-arr[i]-1>=0 && i+arr[i]+1<len && s[i-arr[i]-1] == s[i+arr[i]+1]) arr[i]++;
        
        // 이전 회문보다 긴 회문이 발견시, rad 와 cen값 재설정
        if( rad < i+arr[i]){
			rad = i+arr[i];
			cen = i;
		}
    }
}
```

- #1 회문 안에서 회문의 끝점과 i까지의 거리(위의 2,3번 경우)와 i와 대칭되는 회문의 반지름 값(위의 1번 경우) 중 작은 값을 초기값으로 설정함. 여기서 선택된 값이 해당 케이스를 의미.(예를 들어, 대칭되는 회문의 반지름 값이 선택됐다면 1번의 경우였던 것임)