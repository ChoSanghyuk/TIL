# 백준 계단 오르기 문제풀이


### 문제

계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. <그림 1>과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.

![img](https://upload.acmicpc.net/7177ea45-aa8d-4724-b256-7b84832c9b97/-/preview/)

<그림 1>

예를 들어 <그림 2>와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.

![img](https://upload.acmicpc.net/f00b6121-1c25-492e-9bc0-d96377c586b0/-/preview/)

<그림 2>

계단 오르는 데는 다음과 같은 규칙이 있다.

1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
3. 마지막 도착 계단은 반드시 밟아야 한다.

따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.

각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.

### 입력

입력의 첫째 줄에 계단의 개수가 주어진다.

둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.

### 출력

첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.



## 문제 풀이

​	포도주 문제와 매우 유사한 문제이다. 다만 포도주 시식 문제와의 차이점은 1. 마지막 계단은 꼭 밟아야 함. 2. 2연속으로 건너 뛸 수 없음. 이렇게가 있겠다. 포도주 시식 문제풀이 코드에서 저 두가지를 반영하여 문제를 해결하였다. 

​	기본적인 개념은 i번째 발판을 밟았을 때, 이전 발판을 연속해서 밟았는지 아니면 이전 발판을 건너뛰고 온지에 따라서 경우의 수가 달라진다는 것이다. 경우에 따른 i번째의 선택은 다음과 같다.

- 이전 발판을 건너뛰고 i번째 도착한 경우 : 1. 해당 발판을 밟고 한 칸이동 또는 2. 해당 발판을 밟고 다음칸 스킵
- 이전 발판을 밟고 i번째 도착한 경우 : 1. 해당 발판을 밟고 다음칸 스킵 2. 해당 발판을 스킵하고 다음 발판 이동

여기서 i번째에 영향을 미치는 것은, i 이후의 순서 발판들의 최적 결과 값이다. 이에 역순으로 dp를 진행해 준다. 

## 전체 코드

```java
import java.util.Scanner;
import java.lang.Math;
class Main{
	
	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int[] points = new int[N];
		for(int i = 0 ; i < N ; i++) {
			points[i] = sc.nextInt();
		}
		sc.close();
		
		if(N==1) {
			System.out.println(points[0]);
			return ;
		}
		
		int[][] dp = new int[2][N];
		dp[0][N-1] = points[N-1];
		dp[1][N-1] = points[N-1];
		dp[0][N-2] = points[N-2] + points[N-1];
		dp[1][N-2] = points[N-1];

				
				
		for(int i = N-3 ; i >= 0 ; i--) {
			dp[0][i] = Math.max(points[i] + dp[1][i+1] , points[i] + dp[1][i+2]  ) ;
			dp[1][i] = Math.max( points[i] + dp[0][i+2] , dp[0][i+1]  );
		}
		
		System.out.println(Math.max(dp[1][0], dp[0][0]));
		
		
	}

}
```



## 다른 코드와 비교

​	정답 이후 다른 사람의 코드를 보던 중, 가장 많이 보이는 코드는 다음과 같았다. 

```java
int dp[] = new int[N+1];

dp[1] = points[1];
dp[2] = points[2]+points[1];
dp[3]= Math.max(points[1]+points[3], points[2]+points[3]);
for(int i=4; i<=T; i++){
dp[i] = Math.max(dp[i-3]+points[i]+points[i-1], dp[i-2]+points[i]);
}
System.out.println(cache[N]);


```

​	이 코드는 i번째가 마지막 발판일 때, 밟을 수 있는 최대값을 i에 저장해 두는 방식이다. 만약 i가 마지막 발판이라면, 그 발판의 마지막 과정은 다음과 같다. 

1. 3칸 전의 발판을 밟음 -> 1칸전의 발판 밟고 -> 지금 발판 밟음
2. 2칸 전 발판을 밟음 -> 지금 발판 밟음

​	이 방식에서는 i의 결정에 영향을 주는 것은 이전 발판의 최적 결과 값이다. 그렇기에 앞에서부터 진행되는 것을 볼 수 있었다. 

