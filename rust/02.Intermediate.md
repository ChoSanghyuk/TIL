# Rust Intermediate Concept



## Idiomatic Rust



### rustfmt

- rust에 맞는 포맷으로 code를 리팩토링 해줌

- 설치
  - `rustup component add rustfmt`
- 사용
  - `cargo fmt`
- Customize
  - root 폴더에 `.rustfmt.toml` 파일을 둠으로써, 커스터마이징 가능



### clippy

- 사용

  - `cargo clippy`

- 용도

  - 실제로 코드를 컴파일 => 450여 가지의 문제들에 대해서 체크해줌

- 대표 영역

  1. Style

     - rust convention에 맞는 방식으로 유도

  2. Correctness

     - outright wrong or very useless 한 코드에 대한 warning

  3. Complexity

     - 복잡한 코드를 간결하게 변경할 수 있도록 권고

     - certain / guess 하는 경우로 나누어짐

       :bulb: clippy의 경고를 무시하기 위해서는 `#[allow(clippy::경고이름)]` attribute를 소스에 추가

  4. Performance

:bulb: `clippy lints`를 검색해서 문서를 본다면, rust를 더 잘 작성하기 위한 tip들을 얻을 수 있음



###  :bulb:attribute

- 구조
  - `#[attribute]`
- 종류
  - `outer attribute`
    - it applies to the next item that it is outside of
    - 해당 attribute 바로 다음 소스에 대해서만 적용



## Documentation



### documentation

- 실행
  - `cargo doc`
  - `cargo doc --no-deps --open`
    - `--no-deps` : generate your library's documentation without generating all the documentation for all your dependencies
    - `--open` : automatically opens the index page of the generated documentation in your default browser
      - or `target/doc/packagename/index.html` 을 직접 열어야 함
- 대상
  - default로는 public 요소만 생성
  - private 요소도 생성하기 위해서는 별도 명령어 필요
- Tip
  - 항상 description을 최상단에 작성한 이후에 header들과 section 작성
  - 주로 implementation block에는 작성하지 X (주로 변수 작성 시에 대부분 내용이 들어감)



### Outer Documentation Comments

- 작성

  1. 라인

  ```rust
  /// Number of pieces in the puzzle
  ///
  /// #History
  ///
  /// - 블라블라
  pub const PUZZLE_PIECES:u32 = 42;
  ```

  2. 블록 

  ```rust
  /**
  Number of pieces in the puzzle
  
  #History
  ~~
  
  - Clickable link : [`PUZZLE_PIECES`]
  - 블라블라
  **/
  pub const PUZZLE_PIECES:u32 = 42;
  ```

- markdown 어법 사용

  - 예외

    - intra-doc links 

      - hyperlink to other parts of the documentation

      - [`PUZZLE_PIECES`] (`은 optional)

      - `[다른 문구](PUZZLE_PIECES)` 로도 가능

        :bulb: 만약 link 대상이 scope 안에 있지 않다면, absolute path로 지정 O

  



### Inner Documentation Comments

- 용도
  - document main library, module that you're inside of
  - 변수, 메소드 바로 위에 작성하는 것이 아닌, 파일 전체에 관련한 내용 작성
  
- 작성
  - 라인 : `//!`
  - 블록 : `/*!   !*/`



## Publishing



### publish crate

- 특징

  - permanent

    :bulb: private credential, SSH key, AWS access token과 같은 정보 유의

  - Package name should be `Unique`
  - publish 후 `docs.rs`에 documentation 자동 등재

- 방법

  1. crates.io 접속

  2. Login
  3. Account Settings => API Access & get Token
  4. run `cargo login` & enter Token (once for a machine)
  5. `Cargo.toml` 작성
  6. run `cargo publish`

- `Cargo.toml` 설정 내역

  - 필수
    - name
    - version
  - 권장
    - description
    - edition
    - homepage
    - repository
    - readme
    - keyworks
      - 5개까지 검색 키워드 입력 O
      - `["game", "engine", "graphics"]`
    - categories
      - 5개까지 카테고리 등록 O. 
      - 카테고리 등록시 ,  `All Valid Category Slugs` 페이지의 해당 카테고리에서 볼 수 있음
      - `["game-engines"]`
    - license
      - package의 license 등록
      - 1개 초과 시, " " 안에서 `OR`로 구분 가능
      - `"MIT OR Apache-2.0"`



## Iterator



### iterator

```rust
let v = vec![6,7,8,9];

for num in v {
    println!("{}", num);
}
```

- for loop는 iterator을 탐색함
- 여기서 `v`는 iterator가 아닌데, 이 경우 `v.into_iter()` 자동으로 수행

- `into_iter()`
  - returns an iterator which **takes ownership** of the collection



### iterator with closure

```rust
let v = vec![6,7,8];

v.into_iter().for_each(|num| println!("{}", num));
```

- 장점
  -  `for loop`보다 빠름
  - Iterator Adaptors 사용 O



### Iterator Adaptors

- 개념

  - functional programming paradigm에서 제공하는 tool로, argument를 가지고 action을 수행 후 결과 반환
  - 대부분의 iterator trait의 메소드는 iterator adapters

- 특징

  - lazy

    - consumed 되기 전까진 실행 X

      => 마지막은 Iterator Consumer로 consume

- 기본 예제

  ```rust
  let v = vec![6,7,8];
  
   v.into_iter()
      .map(|x: i32| x*3)
      .filter(|y: &i32| *y%2 == 0)
      .for_each(|z| println!("{}", z));
  ```

  - map

    - value의 ownership 받아서 처리

  - filter

    - recieves an immutable reference to the value

      :bulb: filter는 true/false를 반환하는데, true인 값들을 이후에도 사용하기 위함

- Iterator Consumer



### Iterator Consumer

- iterator을 받아서 결과 처리 / 반환

- 반환 시, 타입 명시 필요

  - Type을 받을 때 generic으로 정의되어 있어, output의 type을 결정하는데 문제가 있음

  - 방법
  
    1. return 값을 받는 변수에 타입 명시
    2. 메소드 자체에 turbofish로 type 지정
    
    ```rust
    let v = vec![6,7,8];
    
    // 방법 1
    let total: i32 = v
    	.into_iter()
    	.map(|x: i32| x*3)
    	.filter(|y: &i32| *y%2 == 0)
    	.sum();
    
    // 방법 2
    v.into_iter()
    .map(|x: i32| x*3)
    .filter(|y: &i32| *y%2 == 0)
    .sum::<i32>();
    ```
    

- 종류
  - `sum()`
  - `for_each`
  - `collect`
    - gather all the items and put them into a new collection
    - element에 대한 타입은 알 수 있는 경우 `_`로 대체 가능
      -  `Vec<_>`
      - big, complicated item type 다룰 때 유용



### turbofish

- `::<>`

- specify the type of the generic parameter or parameters for a generic function or method

- 위치

  - between the method or function name and the argument list
  - `.sum::<i32>()`

  :bulb: rust syntax 상 가장 비선호되는 문



### iterator 전환 종류

- `into_iter()`

  - consumes v, returns owned items
  - sugar form : `for _ in v`

- `iter()`

  - returns immutable references
  - sugar form : `for _ in &v`

- `iter_mut()`

  - returns mutable references
  - sugar form : `for _ in &mut v`

  :bulb: reference type으로 반환할 경우, 단순 for loop를 수행하여도 소유권 전환 X



### drain()

- 사용

  - empty out a collection without consuming the collection itself
  - In all cases, returns an iterator that takes ownership of some or all items in the collection

- 특징

  - item을 제거할 순 있어도 collection 자체는 intact 하게 내버려 둠 => can continue to use it
  - collction 종류에 따라 받는 argument 다름

- case

  - vector

    - `v.drain(..)`
    - vector에서 drain할 범위를 받음

    :bulb: `..`의 경우 전체를 의미

    - drain한 결과를 반환하고, 기존 vector에는 drain 안된 요소들이 남아있음

    ```rust
    let mut v = vec![1, 2, 3, 4, 5];
    
    let removed = v.drain(1..4);
    
    assert_eq!(v, vec![1, 5]); // v now only contains the elements outside of the removed range
    assert_eq!(removed.collect::<Vec<_>>(), vec![2, 3, 4]); // removed contains the elements that were removed
    
    ```

  - hash map

    - `h.drain()`
    - take no argument
    - returns all of the key value pairs



### Common Traits

- 4 things which can Implement traits

  - struct
  - enum
  - closure (only few)
  - function(only few)

- Derivable Traits

  - `derived macro`가 정의되어 있으면, 사용 O
  
  - Debug
    - One of the most common traits to derive
    - struct / enum에 `#[derive(Debug)]` 적용 시 사용 O
    - 모든 primitive 타입 & 대부분 library 타입들은 already Debug
    - 사용
      - Debug Formatting
        - `println!("{:?}", puzzle)`
      - Pretty Debug Formatting
        - `println!("{:#?}", puzzle)`
    
  - Clone
    - `#[derive(Clone)]` => `.clone()` 사용 O
    
    :bulb: 여러 개 적용 시 `,`로 구분 : `#[derive(Clone, Debug)]`
    
  - Copy
    - Clone과 비슷
    - move situation에서, move 되지 않고, copy됨
    - small values which fit entirely on the stack : primitive Type
    - Heap 영역에 저장되는 Type들은 사용 X
    - subtrait of a Clone => `#[derive(Clone, Copy)]`
    
    :bulb: If you implement a trait, you have to implement all of its parent trait as well
  
  

### How to manually implement a trait

- Bring the Trait Into Scope
  - use `use` statement
- Boilerplate
  - IDE generate
  - go documentation and copy it
- Implementation
  - 직접 구현



### maually implement : `Default`

1. 코드로 가져오기

   - `default`는 in the standard prelude 

     => by default, it gives you zero numbers, empty string and empty collection

     => not I want

2. 적용하고자 하는 struct에 Boilerplate 적용

   ```rust
   impl Default for Puzzle {
       fn default() -> Self {
           todo!() // panic!("not yet implemented");
       }
   }
   ```

   - `todo!()` macro는 panic하도록 설정되어 있음

3. Replace body of the function

   ```rust
   impl Default for Puzzle {
       fn default() -> Self {
           Puzzle {
               num_pieces : PUZZLE_PIECES,
               name : "Forest Lake".to_string(),
           }
       }
   }
   ```

   - Puzzle을 새로 생성 시의 기본값으로 활용

   - Puzzle의 잔여 필드들  기본값으로 활용 : `struct update syntax`

     ```rust
     let puzzle = Puzzle {
         num_pieces: 3000,
         ..Default::default()
     };
     ```

     - `..` : range operator. 



### PartialEq / Eq

- PartialEq

  - triat that does the actual calculations to test for equality

    ```rust
    impl PartialEq for Puzzle {
        fn eq(&self, other: &Self) -> bool {
            (self.num_pieces == other.num_pieces) && (self.name == other.name)
        }
    }
    ```

    - eq method takes an `immutable reference to self` and an `immutable reference to the other value` 

    :bulb:`&self` = `self: &Self`, `Self` = `Puzzle`

- Eq

  - marker trait that you can implement if the equality logic is `reflexive`, `transitive`, `symmetric`

  - if every possible value is not equal to itself, cannot have Eq marker trait

  - ex) floating point type은 `NaN` 값을 가질 수 있는 `NaN != NaN` 으므로 Eq implement X

    ```rust
    imple Eq for Puzzle {}
    ```

    - now can use a Puzzle as a key in a hash map
    - 몇몇 특수한 경우에 사용 가능하지만, 주로 비교는 `PartialEq`를 통해서 진행.
    - 오히려 `Eq`를 안 함으로, 더 flexible한 `PartialEq` 활용이 가능해짐



### From / Into

- `From`만 implement하면 `into`는 자동으로 implement

- standard prelude안에 포함. import 필요 X

- 기본 구현 형태

  ```rust
  From<T> for U
  Into<U> for T
  ```

  ```rust
  impl From<Puzzle> for String {
      fn from(_: Puzzle) -> Self { // It didnt' pick up parameter name => replace it with puzzle
          todo!() // puzzle.name
      }
  }
  
  let puzzle = Puzzle::default();
  let s = String::from(puzzle);
  let t: String = puzzle.into();
  ```

- Generic function which takes generic variables of `Into`

  ```rust
  pub fn show<T: Into<String>>(s: T) {
      println!("{}", s.into());
  }
  
  show(puzzle);
  ```

- Both `From`, `Into` traits consume the variable

  ```rust
  impl From<&Puzzle> for String {
      fn from(puzzle: &Puzzle) -> Self {
          puzzle.name.clone()
      }
  }
  show(&puzzle)
  ```

  - 이후에도 객체를 사용하고자 한다면 `clone` 필요. But, 객체 전체를 clone해서 사용하는 것은 `비싼` 작업
  - use immutable reference & clone only using fields
    - can't move the field out an immutable reference
  - immutable reference로 변경했다고 해서 위의 `show` function이 바뀔 필요는 X

​	:bulb: references to types are their own types => references to things can have different traits implemented from the things









## 코드 예제



### closure-iterators

```rust
// Yes, yes, we know. It's an exercise, compiler, we want it that way!
#[allow(unused_mut)]

fn main() {
    // 1. Uncomment the code below. Create a closure that returns the square of an integer (the
    // number multiplied by itself), and assign the closure to the "square" variable. Then run the
    // code and make sure it works.

    let square = |x| x*x;
    println!("5 squared is {}", square(5));

    // 2. Uncomment the code below.  Finish the .map() iterator adaptor call by passing it a closure
    // which takes a tuple of two integers as a parameter, and returns a tuple with the first
    // integer incremented by 1, and the second integer left alone.  For example, if given the input
    // (0, 1), it should return (1, 1). Run the code and make sure it works.

    let pairs = vec![(0, 1), (2, 3), (4, 5)];
    pairs
        .into_iter()
        .map( |t| (t.0+1, t.1) )
        .for_each(|t| println!("{:?}", t));

    // 3. Uncomment the code below. There is a mutable vector named `numbers`. Use an iterator over
    // mutable references to multiply each of the values in `numbers` by 3.
    // Hint 1: You'll need .iter_mut() -- bonus points if you use the shorter, syntactic sugar form!
    // Hint 2: `x` will be a mutable reference, so remember to dereference it to use it

    let mut numbers = vec![1, 2, 3, 4];
    for x in &mut numbers {
        *x = *x*3 // multiply the value by 3 via the mutable reference x
    }
    println!("{:?}", numbers); // should print [3, 6, 9, 12]

    // 4. Uncomment the code below.  Take the vector of words and
    // - Convert the vector into an iterator with .into_iter()
    // - Use .filter() to remove any word that contains the letter "h" -- use .contains()
    // - Use .map() to convert all the words to uppercase -- use .to_uppercase()
    // - Use .collect() to put the transformed words back into a vector
    //
    // Hint: .to_uppercase() is a method on `str` which returns a String

    let words = vec!["autobot", "beach", "car", "decepticon", "energon", "frothy"];
    let transformed: Vec<_> = words.into_iter()   // do the stuff here
            .filter(|&x| !x.contains("h"))
            .map(|x| x.to_uppercase())
            .collect();
    
    println!("Transformed: {:?}", transformed);

    // Challenge:
    //
    // - Rewrite the code in #2 as a for loop
    // - Rewrite the code in #3 in functional style (without a for loop).  Hint: There are multiple
    // ways to accomplish this, but they all end with an iterator consumer.
}

```















