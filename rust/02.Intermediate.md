# Rust Intermediate Concept



[TOC]



## Idiomatic Rust



### rustfmt

- rustì— ë§ëŠ” í¬ë§·ìœ¼ë¡œ codeë¥¼ ë¦¬íŒ©í† ë§ í•´ì¤Œ

- ì„¤ì¹˜
  - `rustup component add rustfmt`
- ì‚¬ìš©
  - `cargo fmt`
- Customize
  - root í´ë”ì— `.rustfmt.toml` íŒŒì¼ì„ ë‘ ìœ¼ë¡œì¨, ì»¤ìŠ¤í„°ë§ˆì´ì§• ê°€ëŠ¥



### clippy

- ì‚¬ìš©

  - `cargo clippy`

- ìš©ë„

  - ì‹¤ì œë¡œ ì½”ë“œë¥¼ ì»´íŒŒì¼ => 450ì—¬ ê°€ì§€ì˜ ë¬¸ì œë“¤ì— ëŒ€í•´ì„œ ì²´í¬í•´ì¤Œ

- ëŒ€í‘œ ì˜ì—­

  1. Style

     - rust conventionì— ë§ëŠ” ë°©ì‹ìœ¼ë¡œ ìœ ë„

  2. Correctness

     - outright wrong or very useless í•œ ì½”ë“œì— ëŒ€í•œ warning

  3. Complexity

     - ë³µì¡í•œ ì½”ë“œë¥¼ ê°„ê²°í•˜ê²Œ ë³€ê²½í•  ìˆ˜ ìˆë„ë¡ ê¶Œê³ 

     - certain / guess í•˜ëŠ” ê²½ìš°ë¡œ ë‚˜ëˆ„ì–´ì§

       :bulb: clippyì˜ ê²½ê³ ë¥¼ ë¬´ì‹œí•˜ê¸° ìœ„í•´ì„œëŠ” `#[allow(clippy::ê²½ê³ ì´ë¦„)]` attributeë¥¼ ì†ŒìŠ¤ì— ì¶”ê°€

  4. Performance

:bulb: `clippy lints`ë¥¼ ê²€ìƒ‰í•´ì„œ ë¬¸ì„œë¥¼ ë³¸ë‹¤ë©´, rustë¥¼ ë” ì˜ ì‘ì„±í•˜ê¸° ìœ„í•œ tipë“¤ì„ ì–»ì„ ìˆ˜ ìˆìŒ



###  :bulb:attribute

- ê°œìš”
  - metadata or directives that provide additional information to the compiler. 
  - They can modify how the compiler interprets the code, apply behaviors, or provide information for tools like documentation generators or serialization frameworks.

- êµ¬ì¡°
  - `#[attribute_name(arguments)]`
- ì¢…ë¥˜
  - `outer attribute`
    - it applies to the next item that it is outside of
    - í•´ë‹¹ attribute ë°”ë¡œ ë‹¤ìŒ ì†ŒìŠ¤ì— ëŒ€í•´ì„œë§Œ ì ìš©
- ì˜ˆì‹œ
  - `#[derive]`
    - Used to automatically implement certain traits for a struct, enum, or union.







## Documentation



### documentation

- ì‹¤í–‰
  - `cargo doc`
  - `cargo doc --no-deps --open`
    - `--no-deps` : generate your library's documentation without generating all the documentation for all your dependencies
    - `--open` : automatically opens the index page of the generated documentation in your default browser
      - or `target/doc/packagename/index.html` ì„ ì§ì ‘ ì—´ì–´ì•¼ í•¨
- ëŒ€ìƒ
  - defaultë¡œëŠ” public ìš”ì†Œë§Œ ìƒì„±
  - private ìš”ì†Œë„ ìƒì„±í•˜ê¸° ìœ„í•´ì„œëŠ” ë³„ë„ ëª…ë ¹ì–´ í•„ìš”
- Tip
  - í•­ìƒ descriptionì„ ìµœìƒë‹¨ì— ì‘ì„±í•œ ì´í›„ì— headerë“¤ê³¼ section ì‘ì„±
  - ì£¼ë¡œ implementation blockì—ëŠ” ì‘ì„±í•˜ì§€ X (ì£¼ë¡œ ë³€ìˆ˜ ì‘ì„± ì‹œì— ëŒ€ë¶€ë¶„ ë‚´ìš©ì´ ë“¤ì–´ê°)



### Outer Documentation Comments

- ì‘ì„±

  1. ë¼ì¸

  ```rust
  /// Number of pieces in the puzzle
  ///
  /// #History
  ///
  /// - ë¸”ë¼ë¸”ë¼
  pub const PUZZLE_PIECES:u32 = 42;
  ```

  2. ë¸”ë¡ 

  ```rust
  /**
  Number of pieces in the puzzle
  
  #History
  ~~
  
  - Clickable link : [`PUZZLE_PIECES`]
  - ë¸”ë¼ë¸”ë¼
  **/
  pub const PUZZLE_PIECES:u32 = 42;
  ```

- markdown ì–´ë²• ì‚¬ìš©

  - ì˜ˆì™¸

    - intra-doc links 

      - hyperlink to other parts of the documentation

      - [`PUZZLE_PIECES`] (`ì€ optional)

      - `[ë‹¤ë¥¸ ë¬¸êµ¬](PUZZLE_PIECES)` ë¡œë„ ê°€ëŠ¥

        :bulb: ë§Œì•½ link ëŒ€ìƒì´ scope ì•ˆì— ìˆì§€ ì•Šë‹¤ë©´, absolute pathë¡œ ì§€ì • O

  



### Inner Documentation Comments

- ìš©ë„
  - document main library, module that you're inside of
  - ë³€ìˆ˜, ë©”ì†Œë“œ ë°”ë¡œ ìœ„ì— ì‘ì„±í•˜ëŠ” ê²ƒì´ ì•„ë‹Œ, íŒŒì¼ ì „ì²´ì— ê´€ë ¨í•œ ë‚´ìš© ì‘ì„±
  
- ì‘ì„±
  - ë¼ì¸ : `//!`
  - ë¸”ë¡ : `/*!   !*/`



## Publishing



### publish crate

- íŠ¹ì§•

  - permanent

    :bulb: private credential, SSH key, AWS access tokenê³¼ ê°™ì€ ì •ë³´ ìœ ì˜

  - Package name should be `Unique`
  - publish í›„ `docs.rs`ì— documentation ìë™ ë“±ì¬

- ë°©ë²•

  1. crates.io ì ‘ì†

  2. Login
  3. Account Settings => API Access & get Token
  4. run `cargo login` & enter Token (once for a machine)
  5. `Cargo.toml` ì‘ì„±
  6. run `cargo publish`

- `Cargo.toml` ì„¤ì • ë‚´ì—­

  - í•„ìˆ˜
    - name
    - version
  - ê¶Œì¥
    - description
    - edition
    - homepage
    - repository
    - readme
    - keyworks
      - 5ê°œê¹Œì§€ ê²€ìƒ‰ í‚¤ì›Œë“œ ì…ë ¥ O
      - `["game", "engine", "graphics"]`
    - categories
      - 5ê°œê¹Œì§€ ì¹´í…Œê³ ë¦¬ ë“±ë¡ O. 
      - ì¹´í…Œê³ ë¦¬ ë“±ë¡ì‹œ ,  `All Valid Category Slugs` í˜ì´ì§€ì˜ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì—ì„œ ë³¼ ìˆ˜ ìˆìŒ
      - `["game-engines"]`
    - license
      - packageì˜ license ë“±ë¡
      - 1ê°œ ì´ˆê³¼ ì‹œ, " " ì•ˆì—ì„œ `OR`ë¡œ êµ¬ë¶„ ê°€ëŠ¥
      - `"MIT OR Apache-2.0"`



## Iterator



### iterator

```rust
let v = vec![6,7,8,9];

for num in v {
    println!("{}", num);
}
```

- for loopëŠ” iteratorì„ íƒìƒ‰í•¨
- ì—¬ê¸°ì„œ `v`ëŠ” iteratorê°€ ì•„ë‹Œë°, ì´ ê²½ìš° `v.into_iter()` ìë™ìœ¼ë¡œ ìˆ˜í–‰

- `into_iter()`
  - returns an iterator which **takes ownership** of the collection



### iterator with closure

```rust
let v = vec![6,7,8];

v.into_iter().for_each(|num| println!("{}", num));
```

- ì¥ì 
  -  `for loop`ë³´ë‹¤ ë¹ ë¦„
  - Iterator Adaptors ì‚¬ìš© O



### Iterator Adaptors

- ê°œë…

  - functional programming paradigmì—ì„œ ì œê³µí•˜ëŠ” toolë¡œ, argumentë¥¼ ê°€ì§€ê³  actionì„ ìˆ˜í–‰ í›„ ê²°ê³¼ ë°˜í™˜
  - ëŒ€ë¶€ë¶„ì˜ iterator traitì˜ ë©”ì†Œë“œëŠ” iterator adapters

- íŠ¹ì§•

  - lazy

    - consumed ë˜ê¸° ì „ê¹Œì§„ ì‹¤í–‰ X

      => ë§ˆì§€ë§‰ì€ Iterator Consumerë¡œ consume

- ê¸°ë³¸ ì˜ˆì œ

  ```rust
  let v = vec![6,7,8];
  
   v.into_iter()
      .map(|x: i32| x*3)
      .filter(|y: &i32| *y%2 == 0)
      .for_each(|z| println!("{}", z));
  ```

  - map

    - valueì˜ ownership ë°›ì•„ì„œ ì²˜ë¦¬

  - filter

    - recieves an immutable reference to the value

      :bulb: filterëŠ” true/falseë¥¼ ë°˜í™˜í•˜ëŠ”ë°, trueì¸ ê°’ë“¤ì„ ì´í›„ì—ë„ ì‚¬ìš©í•˜ê¸° ìœ„í•¨

- Iterator Consumer



### Iterator Consumer

- iteratorì„ ë°›ì•„ì„œ ê²°ê³¼ ì²˜ë¦¬ / ë°˜í™˜

- ë°˜í™˜ ì‹œ, íƒ€ì… ëª…ì‹œ í•„ìš”

  - Typeì„ ë°›ì„ ë•Œ genericìœ¼ë¡œ ì •ì˜ë˜ì–´ ìˆì–´, outputì˜ typeì„ ê²°ì •í•˜ëŠ”ë° ë¬¸ì œê°€ ìˆìŒ

  - ë°©ë²•
  
    1. return ê°’ì„ ë°›ëŠ” ë³€ìˆ˜ì— íƒ€ì… ëª…ì‹œ
    2. ë©”ì†Œë“œ ìì²´ì— turbofishë¡œ type ì§€ì •
    
    ```rust
    let v = vec![6,7,8];
    
    // ë°©ë²• 1
    let total: i32 = v
    	.into_iter()
    	.map(|x: i32| x*3)
    	.filter(|y: &i32| *y%2 == 0)
    	.sum();
    
    // ë°©ë²• 2
    v.into_iter()
    .map(|x: i32| x*3)
    .filter(|y: &i32| *y%2 == 0)
    .sum::<i32>();
    ```
    

- ì¢…ë¥˜
  - `sum()`
  - `for_each`
  - `collect`
    - gather all the items and put them into a new collection
    - elementì— ëŒ€í•œ íƒ€ì…ì€ ì•Œ ìˆ˜ ìˆëŠ” ê²½ìš° `_`ë¡œ ëŒ€ì²´ ê°€ëŠ¥
      -  `Vec<_>`
      - big, complicated item type ë‹¤ë£° ë•Œ ìœ ìš©



### turbofish

- `::<>`

- specify the type of the generic parameter or parameters for a generic function or method

- ìœ„ì¹˜

  - between the method or function name and the argument list
  - `.sum::<i32>()`

  :bulb: rust syntax ìƒ ê°€ì¥ ë¹„ì„ í˜¸ë˜ëŠ” ë¬¸



### iterator ì „í™˜ ì¢…ë¥˜

- `into_iter()`

  - consumes v, returns owned items
  - sugar form : `for _ in v`

- `iter()`

  - returns immutable references
  - sugar form : `for _ in &v`

- `iter_mut()`

  - returns mutable references
  - sugar form : `for _ in &mut v`

  :bulb: reference typeìœ¼ë¡œ ë°˜í™˜í•  ê²½ìš°, ë‹¨ìˆœ for loopë¥¼ ìˆ˜í–‰í•˜ì—¬ë„ ì†Œìœ ê¶Œ ì „í™˜ X



### drain()

- ì‚¬ìš©

  - empty out a collection without consuming the collection itself
  - In all cases, returns an iterator that takes ownership of some or all items in the collection

- íŠ¹ì§•

  - itemì„ ì œê±°í•  ìˆœ ìˆì–´ë„ collection ìì²´ëŠ” intact í•˜ê²Œ ë‚´ë²„ë ¤ ë‘  => can continue to use it
  - collction ì¢…ë¥˜ì— ë”°ë¼ ë°›ëŠ” argument ë‹¤ë¦„

- case

  - vector

    - `v.drain(..)`
    - vectorì—ì„œ drainí•  ë²”ìœ„ë¥¼ ë°›ìŒ

    :bulb: `..`ì˜ ê²½ìš° ì „ì²´ë¥¼ ì˜ë¯¸

    - drainí•œ ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ê³ , ê¸°ì¡´ vectorì—ëŠ” drain ì•ˆëœ ìš”ì†Œë“¤ì´ ë‚¨ì•„ìˆìŒ

    ```rust
    let mut v = vec![1, 2, 3, 4, 5];
    
    let removed = v.drain(1..4);
    
    assert_eq!(v, vec![1, 5]); // v now only contains the elements outside of the removed range
    assert_eq!(removed.collect::<Vec<_>>(), vec![2, 3, 4]); // removed contains the elements that were removed
    
    ```

  - hash map

    - `h.drain()`
    - take no argument
    - returns all of the key value pairs



## Common Traits



### Common Traits

- 4 things which can Implement traits

  - struct
  - enum
  - closure (only few)
  - function(only few)

- Derivable Traits

  - `#[derive(...)]` ì–´íŠ¸ë¦¬ë·°íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì œê³µí•˜ëŠ” íŠ¸ë ˆì´íŠ¸ë¥¼ ìë™ìœ¼ë¡œ êµ¬í˜„
  
  - `derived macro`ê°€ ì •ì˜ë˜ì–´ ìˆìœ¼ë©´, ì‚¬ìš© O
  
  - Debug
    - One of the most common traits to derive
    - struct / enumì— `#[derive(Debug)]` ì ìš© ì‹œ ì‚¬ìš© O
    - ëª¨ë“  primitive íƒ€ì… & ëŒ€ë¶€ë¶„ library íƒ€ì…ë“¤ì€ already Debug
    - ì‚¬ìš©
      - Debug Formatting
        - `println!("{:?}", puzzle)`
      - Pretty Debug Formatting
        - `println!("{:#?}", puzzle)`
    
  - Clone
    - `#[derive(Clone)]` => `.clone()` ì‚¬ìš© O
    
    :bulb: ì—¬ëŸ¬ ê°œ ì ìš© ì‹œ `,`ë¡œ êµ¬ë¶„ : `#[derive(Clone, Debug)]`
    
  - Copy
    - Cloneê³¼ ë¹„ìŠ·
    - move situationì—ì„œ, move ë˜ì§€ ì•Šê³ , copyë¨
    - small values which fit entirely on the stack : primitive Type
    - Heap ì˜ì—­ì— ì €ì¥ë˜ëŠ” Typeë“¤ì€ ì‚¬ìš© X
      - Structê³¼ Enumì€ ê°€ì§€ê³  ìˆëŠ” í•„ë“œì˜ ì¢…ë¥˜ì— ë”°ë¼ Copy ê°€ëŠ¥ ì—¬ë¶€ ê²°ì •ë¨
    
    - subtrait of a Clone => `#[derive(Clone, Copy)]`
    
    :bulb: If you implement a trait, you have to implement all of its parent trait as well
  
  

### How to manually implement a trait

- Bring the Trait Into Scope
  - use `use` statement
- Boilerplate
  - IDE generate
  - go documentation and copy it
- Implementation
  - ì§ì ‘ êµ¬í˜„



### maually implement : `Default`

1. ì½”ë“œë¡œ ê°€ì ¸ì˜¤ê¸°

   - `default`ëŠ” in the standard prelude 

     => by default, it gives you zero numbers, empty string and empty collection

     => not I want

2. ì ìš©í•˜ê³ ì í•˜ëŠ” structì— Boilerplate ì ìš©

   ```rust
   impl Default for Puzzle {
       fn default() -> Self {
           todo!() // panic!("not yet implemented");
       }
   }
   ```

   - `todo!()` macroëŠ” panicí•˜ë„ë¡ ì„¤ì •ë˜ì–´ ìˆìŒ

3. Replace body of the function

   ```rust
   impl Default for Puzzle {
       fn default() -> Self {
           Puzzle {
               num_pieces : PUZZLE_PIECES,
               name : "Forest Lake".to_string(),
           }
       }
   }
   ```

   - Puzzleì„ ìƒˆë¡œ ìƒì„± ì‹œì˜ ê¸°ë³¸ê°’ìœ¼ë¡œ í™œìš©

   - Puzzleì˜ ì”ì—¬ í•„ë“œë“¤  ê¸°ë³¸ê°’ìœ¼ë¡œ í™œìš© : `struct update syntax`

     ```rust
     let puzzle = Puzzle {
         num_pieces: 3000,
         ..Default::default() // ë§ˆì§€ë§‰ì— , ì—†ì–´ì•¼ í•¨
     };
     ```

     - `..` : range operator. 



### PartialEq / Eq

- PartialEq

  - trait that does the actual calculations to test for equality

    ```rust
    impl PartialEq for Puzzle {
        fn eq(&self, other: &Self) -> bool {
            (self.num_pieces == other.num_pieces) && (self.name == other.name)
        }
    }
    ```

    - eq method takes an `immutable reference to self` and an `immutable reference to the other value` 

    :bulb:`&self` = `self: &Self`, `Self` = `Puzzle`

- Eq

  - marker trait that you can implement if the equality logic is `reflexive`, `transitive`, `symmetric`

  - if every possible value is not equal to itself, cannot have Eq marker trait

  - ex) floating point typeì€ `NaN` ê°’ì„ ê°€ì§ˆ ìˆ˜ ìˆìœ¼ë©° `NaN != NaN` ìœ¼ë¯€ë¡œ Eq implement X

    ```rust
    impl Eq for Puzzle {}
    ```

    - now can use a Puzzle as a key in a hash map
    - ëª‡ëª‡ íŠ¹ìˆ˜í•œ ê²½ìš°ì— ì‚¬ìš© ê°€ëŠ¥í•˜ì§€ë§Œ, ì£¼ë¡œ ë¹„êµëŠ” `PartialEq`ë¥¼ í†µí•´ì„œ ì§„í–‰.
    - ì˜¤íˆë ¤ `Eq`ë¥¼ ì•ˆ í•¨ìœ¼ë¡œ, ë” flexibleí•œ `PartialEq` í™œìš©ì´ ê°€ëŠ¥í•´ì§



### From / Into

- `From`ë§Œ implementí•˜ë©´ `into`ëŠ” ìë™ìœ¼ë¡œ implement

- standard preludeì•ˆì— í¬í•¨. import í•„ìš” X

- ê¸°ë³¸ êµ¬í˜„ í˜•íƒœ

  ```rust
  From<T> for U
  Into<U> for T
  ```

  ```rust
  impl From<Puzzle> for String {
      fn from(_: Puzzle) -> Self { // It didnt' pick up parameter name => replace _ with puzzle
          todo!() // puzzle.name
      }
  }
  
  let puzzle = Puzzle::default();
  let s = String::from(puzzle);
  let t: String = puzzle.into();
  ```

- Generic function which takes generic variables of `Into`

  ```rust
  pub fn show<T: Into<String>>(s: T) {
      println!("{}", s.into());
  }
  
  show(puzzle);
  ```

- Both `From`, `Into` traits consume the variable

  ```rust
  impl From<&Puzzle> for String {
      fn from(puzzle: &Puzzle) -> Self {
          puzzle.name.clone()
      }
  }
  show(&puzzle)
  ```

  - ì´í›„ì—ë„ ê°ì²´ë¥¼ ì‚¬ìš©í•˜ê³ ì í•œë‹¤ë©´ `clone` í•„ìš”. But, ê°ì²´ ì „ì²´ë¥¼ cloneí•´ì„œ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ `ë¹„ì‹¼` ì‘ì—…
  - use immutable reference & clone only using fields
    - can't move the field out an immutable reference
  - immutable referenceë¡œ ë³€ê²½í–ˆë‹¤ê³  í•´ì„œ ìœ„ì˜ `show` functionì´ ë°”ë€” í•„ìš”ëŠ” X

â€‹	:bulb: references to types are their own types => references to things can have different traits implemented from the things



## Errors



### Make an Error for a library that you publish

1. Errors should be `enums`

2. Group your errors as variants of as few enums as makes sense

   - Make sense í•˜ê¸°ë§Œ í•˜ë‹¤ë©´, Enum ì•ˆì´ ê¸¸ì–´ì ¸ë„ ìƒê´€ X

3. Should only return your errors from your public library

   - ë‚´ libraryê°€ ë‹¤ë¥¸ libraryì— ì¢…ì†í•˜ê³  ìˆë‹¤ë©´, í•´ë‹¹ libraryì˜ Errorì„ ì§ì ‘ì ìœ¼ë¡œ ë…¸ì¶œì‹œí‚¤ì§€ X
     - If not
       - it gives the external dependency the ability to break you public API
       - prevent you from changing your own library's backend implementation without breaking your own public API
   - í•´ë‹¹ Errorë¥¼ ë‚´ Error enumì— convert ì‹œì¼œì„œ í•¸ë“¤ë§
   - std errorë¼ë©´ ê·¸ëŒ€ë¡œ ë³´ì—¬ì¤˜ë„ ë˜ëŠ” ê²½ìš° æœ‰

4. Enum should be non-exhaustive

   ```rust
   #[non_exhaustive]
   pub enum PuzzleError {
       WontFit(u16),
       MissingPiece,
   }
   ```

   :bulb: `non_exhaustive` : ì¶”í›„ì— í•„ë“œ, ë³€ìˆ˜ê°€ ì¶”ê°€ë  ìˆ˜ ìˆìŒì„ ëª…ì‹œ => `defining crate` ì™¸ì˜ ë°©ì‹ìœ¼ë¡œ ìƒì„± ì œì•½ (wildcard ì‚¬ìš©  X)

5. Implement `Debug + Display + Error` traits in this order

   - Error : Debug + Display

- ìµœì¢…

```rust
use std::error::Error;
use std::fmt::{Display, Formatter};

#[dervie(Debug)]			// #5 : Debug + Display + Error
#[non_exhaustive]			// Non-Exhaustive
pub enum PuzzleError {		// #1 : enum
    WontFit(u16),			// #2 : Group Errors
    MissingPiece,			// #3 : Only Your Errors
}

impl Display for PuzzleError {	// #5 : Debug + Display + Error
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        use PuzzleError::*; // Enumì˜ ë³€ìˆ˜ë“¤ì„ ëª¨ë‘ Localë¡œ ê°€ì ¸ì˜´
        match self {
            MissingPiece => write!(f, "Missing a piece"),
            WontFit(n) => write!(f, "Piece {} doensn't fit!", n),
        }
    }
}

impl Error for PuzzleError{}	// #5 : Debug + Display + Error

```

:bulb: `use` statmentì—ì„œ `*` asterisk ì‚¬ìš©í•´ë„ ë˜ëŠ” 3ê°€ì§€ ê²½ìš° ì¤‘ í•˜ë‚˜



### use `thiserror`

-  `Debug + Display + Error` implementationì˜ ê°„ê²°í™” ì‹œí‚´

1. Add dependencies to `Cargo.toml`

   ```toml
   [dependencies]
   thiserror = "1.0"
   ```

2. Derive `thiserror::Error`

3. add `#[error("...")]` annotations to variants to display message

   ```rust
   use thiserror::Error;
   
   #[derive(Debug, Error)]
   #[non_exhaustive]
   pub enum PuzzleError {
       #[error("Piece {0} doesn't fit!")]
       WontFit(u16),
       #[error("Missing a piece")]
       MissingPiece,
   }
   ```
   
   - tuple dataì˜ ê²½ìš° `{0}`ë¡œ ì•ˆ ë³€ìˆ˜ ì ‘ê·¼ O





### Handling Errors

```rust
// Manually panic
panic!("Your server is on fire");

// Same thing if result is a Result::Err
result.expect("Your server is on fire")

// Same thing, but without a message
result.unwrap();
```

- `panic`
  - ë” ì´ìƒ ì‹œìŠ¤í…œì˜ ì§€ì†ì´ ì•ˆë˜ëŠ” ì—ëŸ¬ ì¼ ë•Œ => System ì¢…ë£Œ
  - ë‹¤ë¥¸ reasonable optionì´ ë” ì´ìƒ ì—†ì„ ë•Œì—ë§Œ ì‚¬ìš©
- `expect`
  - ì»¤ë²„ ê°€ëŠ¥ ì˜ì—­ ì•ˆ ì¼ ë•Œ

â€‹	=> Recoverableí•œ ErrorëŠ” Handle í˜¹ì€ Return í•´ì•¼ í•¨





### Way to handle or return Error

- `if let` expression

  ```rust
  if let Err(e) = my_result {
      println!("Warning: {}", e);
  }
  ```

  - `Err`ì™€ `my_result`ì˜ íƒ€ì…ì´ ê°™ë‹¤ë©´ `{}` ì•ˆì˜ `e`ì— ê°’ ë“¤ì–´ê°€ë©° ì‹¤í–‰

- `match` expression

  ```rust
  let score = match get_saved_score() {
      Ok(x) => x,
      Err(_) => 0,
  }
  ```

  - handle Error with default value => Ok, Err ì‹œ ê°™ì€ íƒ€ì… ë°˜í™˜
  - `unwrap_or(0)` ë©”ì†Œë“œì™€ ë™ì¼ ê¸°ëŠ¥ ìˆ˜í–‰

  ```rust
  let score = get_saved_score().unwrap_or(0);
  ```

- Return the Error

  ```rust
  fn poem() -> Result<String, io::Error> {
      let file = match File::open("file.txt"){
          Ok(f) => f,
          Err(e) => return Err(e1),
      };
      // do stuff
  }
  ```

  - í•¨ìˆ˜ ë‚´ì—ì„œ Err ì²˜ë¦¬ë¥¼ ëª» í•˜ëŠ” ê²½ìš° => callerì—ê²Œ ì²˜ë¦¬ ë„˜ê¹€

- `?` operator

  ```rust
  fn poem() -> Result<String, io::Error> {
      let file = File::open("file.txt")?;
      // do stuff
  }
  ```

  - ìœ„ì˜ match expressionê³¼ ìƒë™

  ```rust
  optinum.stand()?.transaform()?.rollout()?.chase()?
  ```

  - `?`ì„ ì‚¬ìš©í•¨ìœ¼ë¡œì¨ chainingì„ ê°„í¸í•˜ê²Œ í•  ìˆ˜ ìˆ

- `anyhow` library

  - ì—¬ëŸ¬ Err íƒ€ì…ì— ëŒ€í•´ì„œ `?` operator ì‚¬ìš© ê°€ëŠ¥í•˜ê²Œ í•¨

  - `anyhow::Result` : Error trait ì²˜ë¦¬ë¥¼ í†µí•˜ì—¬ ì–´ë– í•œ errorì— ëŒ€í•´ì„œë“  ë™ì‘

    =>  ê°œë°œìëŠ” Resultì˜ Ok typeë§Œ ì‹ ê²½ì“°ë©´ ë¨

  ```rust
  use anyhow::{Context, Result};
  use puzzles:Puzzle;
  use std::fs::File;
  
  fn get_puzzle(filename: &str) -> Result<Puzzle> {
      let fh = File::open(filename).context("couldn't open the puzzle file")?;
      let puzzle = Puzzle::from_file(fh).context("couldn't convert data into a puzzle")?; 
      Ok(puzzle)
  }
  
  fn main() -> Result<()> {
      let puzzle = get_puzzle("puzzle.dat").context("Couldn't get the first puzzle")?;
      println!("Playing puzzle: {}", puzzle.name);
      Ok(())
  }
  ```

  - `anyhow result`
    - io::Error í˜¹ì€ Puzzleì˜ Err implements Error trait => anyhow result accept

  - `context`
    - Bring the trait into scope => allow us to use the context method on Result to add context
    - `expect()` ë©”ì†Œë“œì™€ ìœ ì‚¬í•˜ì§€ë§Œ program crash ì—†ìŒ
  - `main() -> Result<()>`
    - main í•¨ìˆ˜ë„ Result ë°˜í™˜ O
    - the result implements the `Termination trait`
    - `()` : one of the anyhow's Results wrapping the unit type

  :bulb: `with_context`

  ```rust
  let fh = File::open(filename).with_context(|| format!("couldn't open the puzzle file {}", filename))?; 
  ```

  - closureëŠ” errorê°€ ë°œìƒí•  ë•Œë§Œ ë™ì‘ => avoid the overhead of allocating and formatting the string in success case

  

â€» "Error Handling isn't all about errors" by Jane Jusby ë³´ëŠ”ê±° ì¶”ì²œ



## Log



### Log ì°ê¸°

- Add dependency

  ```toml
  [dependencies]
  pretty_env_logger = "0.5.0"
  log = "0.4"
  ```

- ë¡œê·¸ ë ˆë²¨ í™˜ê²½ ì„¤ì •

  - bash : `RUST_LOG=info cargo run`
  - Set Programmatically : `std::env::set_var("RUST_LOG", "info");`

- Init

  - `pretty_env_logger::init();`

- ì‚¬ìš©

  - `log::info!("Test Start");`





## Unit Test



### Unit Test ì‘ì„±

- ì‘ì„± ìœ„ì¹˜

  - bottom of the same file of submodule to test

- ì½”ë“œ ì˜ˆì‹œ

  ```rust
  pub fn snuggle(bunnies: u128) -> u128 {
      bunnies * 8
  }
  
  #[cfg(test)]
  mod test {
      use super::*;
      
      #[test]
      fn snuggling_bunnies_multiply() {
          assert_eq!(snuggle(2), 16);
      }
  }
  ```

  - `#[cfg(test)]` : `cfg` attribute
    - controls conditional compilation of the item 
  - `use super::*`
    - one of 3 idiomatic to use * wild card into scope
  - `#[test]` : `test` attribute : 
    - tells cargo that it should be run by the test runner
  - test function definition
    - can be private
    - name can be anything
    - have no parameter and return 



### assert macro

- `assert_eq!( a, b)`
  - takes 2 arguments that `implement the PartialEq trait`
  - ê°™ì•„ì•¼ ì„±ê³µ, ì•ˆ ê°™ìœ¼ë©´ ì‹¤íŒ¨
- `assert_ne!(5,5)`
  - ì•ˆ ê°™ì•„ì•¼ ì„±ê³µ, ê°™ìœ¼ë©´ ì‹¤íŒ¨
- `assert!(5 >= 5);`
  - boolean return í•˜ëŠ” ì–´ë– í•œ ë¡œì§ ìˆ˜í–‰ O
  - trueì‹œ ì„±ê³µ, false ì‹œ ì‹¤íŒ¨
- `panic!("message")`
  - `#[should_panic]`ì´ ì—†ëŠ” í•œ, ë¬´ì¡°ê±´ ì‹¤íŒ¨



### doc-test ì‘ì„±

```rust
/// # Example
/// 
/// ```
/// # use hello::snuggle;
/// let bunnies = snuggle(5);
/// assert_eq!(buniies, 40);
/// ```
pub fn snuggle(bunnies: u128) -> u128 {
    bunnies *8
}
```

- `#Example` sectionì— ì‘ì„±
- documentì—ì„œ ìˆ¨ê¸°ê³  ì‹¶ì€ ê²ƒì´ ìˆë‹¤ë©´, `#` ë’¤ì—ë‹¤ê°€ ì½”ë“œ ì‘ì„±



### Unit Test with Result

```rust
#[test]
fn bunny_result() -> Result<(), ParseIntError> {
    let num_bunnies: u64 = "four".parse()?;
    assert_eq!(num_bunnies, 4);
    Ok(())
}
```

- Success Typeì€ ë¬´ì‹œë¨ => `()` í‘œê¸°
- Error Typeì€ ë°œìƒ ê°€ëŠ¥í•œ Error í‘œê¸°í•¨. Anyhowì˜ Error ì‚¬ìš© O





### Cargo Test

- Test ê²°ê³¼ Section
  - Section êµ¬ë¶„
    - Indent ëœ ì´ˆë¡ ê¸€ìì™€ í•¨ê»˜ Section ì‹œì‘
    - First Line : the name of the compiled binary that has been produced to run the test
    - í…ŒìŠ¤íŠ¸ ìˆ˜ ëª…ì‹œ + í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œ ëª… & ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ ì¶œë ¥ë¨
    - ë§ˆì§€ë§‰ ì¤„ : ê²°ê³¼ ìš”ì•½ ì¶œë ¥
  - Section êµ¬ë¶„ ê¸°ì¤€
    - All the tests from the library crate will be listed 
    - Binary crate ì•ˆì˜ test => separate section
- Doc-tests Section
  - Cargo search out tests in your library documentation and run them
  - Only for doc-test in your library (binaryëŠ” ëŒ€ìƒ X)

- `cargo test test::bunny_result`
  - ë‹¨ê±´ unit test ì‹¤í–‰ command
  - RustëŠ” testë“¤ ì‹¤í–‰ ì‹œ, ì´ì „ test fail ì‹œ, ì´í›„ test ìˆ˜í–‰ X

:bulb: `cargo test` ìˆ˜í–‰ ì‹œ, ì„±ê³µí•œ ì¼€ì´ìŠ¤ì— ëŒ€í•œ `println`ë¬¸ì€ ë‚˜ì˜¤ì§€ ì•ŠìŒ. `cargo test -- --nocapture` í•„ìš”

- Unit Test Debug Mode

  - install `CodeLLDB` extension (Mac)

  - `/.vscode/launch.json`

    ```json
    {
        "version": "0.2.0",
        "configurations": [
            {
                "type": "lldb",
                "request": "launch",
                "name": "Debug unit tests in library 'yourprogram'",
                "cargo": {
                    "args": [
                        "test",
                        "--no-run",
                        "--lib",
                        "--package=yourprogram"
                    ],
                    "filter": {
                        "name": "yourprogram",
                        "kind": "lib"
                    }
                },
                "args": [],
                "cwd": "${workspaceFolder}"
            }
        ]
    }
    ```

    

### â€» Crate ì •ì˜

- ì •ì˜ 1. Crate = package

  - commonly used

  - packageëŠ” 0 ê°œ ì´ìƒì˜ libraryì™€ binaries í¬í•¨ O

    => libaryì™€ binaryëŠ” ê°™ì€ package ì•ˆì— ìˆìŒ

- ì •ì˜ 2. Crate = a library or a binary
  - Rust language / cargo toolì—ì„œ ì‚¬ìš©



## Integration Tests

### Integration Test

1. `tests` directory ìƒì„±

   - í”„ë¡œì íŠ¸ rootì—  `src`ì™€ ê°™ì€ ìœ„ì¹˜ ìƒì„±

2. `tests` directory ì•ˆì— rust íŒŒì¼ ìƒì„±

   - `tests` directory ì•ˆì˜ ëª¨ë“  rust íŒŒì¼ì€ testë¡œì¨ ì‹¤í–‰ë¨

3. testì— ì‚¬ìš©í•  ëª¨ë“ˆ import(use) ë° í…ŒìŠ¤íŠ¸ functionì—” ëª¨ë‘ `#[test]` ì¶”ê°€

   ```rust
   use hello::snuggle;
   
   #[test]
   fn it_works_from_outside() {
       assert!(snuggle(4) == 32);
   }
   ```

4. `cargo test` ìˆ˜í–‰

   - unit testì™€ì˜ ì°¨ì´ì ì€ Integration testëŠ” í…ŒìŠ¤íŠ¸ fileëª… ìˆ¨ê²¨ì ¸ ìˆìŒ (?)
   - binary fileë„ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì€ í•˜ì§€ë§Œ ê¸°ë³¸ ê³¨ìëŠ” ëª¨ë‘ library fileì— ë„£ì–´ì„œ í…ŒìŠ¤



## Benchmarks



â€» ê°•ì˜ ì‹œì  Rustì˜ BenchmarksëŠ” ì•„ì§ ë¯¸ì™„ì„± ë‹¨ê³„ì´ê¸°, ëŒ€ì²´ë¡œ ì‚¬ìš©ë˜ëŠ” Criterionì— ëŒ€í•œ ì†Œê°œë§Œ í•˜ê³  ë„˜ì–´ê°



### Criterion

1. toml íŒŒì¼ì— ì¶”ê°€

   ```toml
   [dev-dependencies]
   criterion = {version = "0.3", features = ["html_reports"]}
   
   [[bench]]
   name = "snuggle_speed"
   harness = false
   ```

   - `[dev-dependencies]` 

     - ì •ì˜ëœ dependencyëŠ” `cargo test`, `cargo bench`ì™€ ê°™ì€ subcommand ì‹œì—ë§Œ compile
     - ` features = ["html_reports"]` => ê²°ê³¼ë¥¼ target/criterion/report/index.html ì— ì €ì¥

   - `[[ ]]` syntax

     - ë„ˆê°€ í•˜ë‚˜ ì´ìƒì˜ Sectionì„ ê°€ì§ˆ ìˆ˜ ìˆëŠ” ê²ƒì— ëŒ€í•œ toml syntax

       => ì—¬ëŸ¬ ê°œì˜ `[[bench]]` section ì‘ì„± O

     - name : name of the rust source file that will hold your set of benchmarks

     - harness : needs to be false to disable the built-in benchmarking functionality so that Criterion can do the benchmarking instead

2. `benches` directory ìƒì„±

   - All benchmark tests are in the benches directory

3. rust file ì‘ì„±

   ```rust
   use criterion::{black_box, criterion_group, criterion_main, Criterion};
   use hello::snuggle;
   
   pub fn snuggle_benchmark(c: &mut Criterion){
       c.bench_function("snuggle 2", |b| b.iter(|| snuggle(black_box(2))));
   }
   
   criterion_group!(benches, snuggle_benchmark);
   criterion_main!(benches);
   ```

4. `cargo bench` ì‹¤í–‰







## ì½”ë“œ ì˜ˆì œ



### closure-iterators

```rust
// Yes, yes, we know. It's an exercise, compiler, we want it that way!
#[allow(unused_mut)]

fn main() {
    // 1. Uncomment the code below. Create a closure that returns the square of an integer (the
    // number multiplied by itself), and assign the closure to the "square" variable. Then run the
    // code and make sure it works.

    let square = |x| x*x;
    println!("5 squared is {}", square(5));

    // 2. Uncomment the code below.  Finish the .map() iterator adaptor call by passing it a closure
    // which takes a tuple of two integers as a parameter, and returns a tuple with the first
    // integer incremented by 1, and the second integer left alone.  For example, if given the input
    // (0, 1), it should return (1, 1). Run the code and make sure it works.

    let pairs = vec![(0, 1), (2, 3), (4, 5)];
    pairs
        .into_iter()
        .map( |t| (t.0+1, t.1) )
        .for_each(|t| println!("{:?}", t));

    // 3. Uncomment the code below. There is a mutable vector named `numbers`. Use an iterator over
    // mutable references to multiply each of the values in `numbers` by 3.
    // Hint 1: You'll need .iter_mut() -- bonus points if you use the shorter, syntactic sugar form!
    // Hint 2: `x` will be a mutable reference, so remember to dereference it to use it

    let mut numbers = vec![1, 2, 3, 4];
    for x in &mut numbers {
        *x = *x*3 // multiply the value by 3 via the mutable reference x
    }
    println!("{:?}", numbers); // should print [3, 6, 9, 12]

    // 4. Uncomment the code below.  Take the vector of words and
    // - Convert the vector into an iterator with .into_iter()
    // - Use .filter() to remove any word that contains the letter "h" -- use .contains()
    // - Use .map() to convert all the words to uppercase -- use .to_uppercase()
    // - Use .collect() to put the transformed words back into a vector
    //
    // Hint: .to_uppercase() is a method on `str` which returns a String

    let words = vec!["autobot", "beach", "car", "decepticon", "energon", "frothy"];
    let transformed: Vec<_> = words.into_iter()   // do the stuff here
            .filter(|&x| !x.contains("h"))
            .map(|x| x.to_uppercase())
            .collect();
    
    println!("Transformed: {:?}", transformed);

    // Challenge:
    //
    // - Rewrite the code in #2 as a for loop
    // - Rewrite the code in #3 in functional style (without a for loop).  Hint: There are multiple
    // ways to accomplish this, but they all end with an iterator consumer.
}

```



### Common Trait

```rust
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Cake {
    Chocolate,
    MapleBacon,
    Spice,
}

#[derive(Debug)]
pub struct Party {
    pub at_restaurant: bool,
    pub num_people: u8,
    pub cake: Cake,
}

impl Default for Party {

    fn default() -> Self {
        Party {
            at_restaurant: true,
            num_people: 8,
            cake: Cake::Chocolate,
        }
    }
}

impl PartialEq for Party {
    fn eq(&self, other: &Self) -> bool {
        self.cake == other.cake
    }
}

impl From<&Party> for Cake  {

    fn from(party: &Party) -> Self {
        party.cake
    }
}



fn main() {
    // 1. The code below doesn't work because Cake doesn't implement Debug.
    // - Derive the Debug trait for the Cake enum above so this code will work. Then, run the code.

    let cake = Cake::Spice;
    admire_cake(cake);

    // 2. Uncomment the code below. It doesn't work since `cake` was *moved* into the admire_cake()
    // function. Let's fix the Cake enum so the code below works without any changes.
    // - Derive the Copy trait for the Cake enum so that `cake` gets copied into the admire_cake()
    // function instead of moved.
    // - Hint: You may need to derive another trait in order to be able to derive the Copy trait

    match cake {
        Cake::Chocolate => println!("The name's Chocolate. Dark...Chocolate."),
        Cake::MapleBacon => println!("Dreams do come true!"),
        Cake::Spice => println!("Great, let's spice it up!"),
    }

    // 3. Uncomment the println below. It doesn't work since the Party struct doesn't implement the
    // Debug or Default traits.
    // - Derive the Debug trait for the Party struct
    // - Manually implement the Default trait for the Party struct. Use the value below as the
    // default value that you return from the `default` method:
    //
        // Party {
        //     at_restaurant: true,
        //     num_people: 8,
        //     cake: Cake::Chocolate,
        // }
    //
    // Hint: If you get stuck, there is an example at
    // https://doc.rust-lang.org/std/default/trait.Default.html#how-can-i-implement-default

    println!("The default Party is\n{:#?}", Party::default());

    // 4. You prefer Maple Bacon cake. Use "struct update syntax" to create a Party with `cake`
    // set to `Cake::MapleBacon`, but the rest of the values are default.
    //
    // Hint: The trick to struct update syntax is specifying the value(s) you want to customize
    // first and then ending the struct with `..Default::default()` -- but no comma after that!

    let party = Party {
        cake : Cake::MapleBacon,
        ..Default::default()
    };
    println!("Yes! My party has my favorite {:?} cake!", party.cake);

    // 5. Parties are "equal" if they have the same cake.
    // - Derive the PartialEq trait for the Cake enum so Cakes can be compared.
    // - Manually implement the PartialEq trait for Party. If different parties have the same cake,
    // then they are equal, no matter the location or number of attendees at the party.
    // - Uncomment and run the code below.

    let other_party = Party {
        at_restaurant: false,
        num_people: 235,
        cake: Cake::MapleBacon,
    };
    if party == other_party {
        println!("Your party is just like mine!");
    }

    // Challenge: You would like to be able to pass a Party struct into the smell_cake() function
    // which takes a type T which implements the Into<Cake> trait.
    // - Uncomment the code below AND uncomment the smell_cake() function at the bottom of this file
    // - Implement `From<Party> for Cake` so that the function call below works.
    //

    smell_cake(&party);

    // Challenge 2: Implement `From<&Party> for Cake` so that you can smell your cake without
    // consuming it. Change the code above to pass in a &party. Then uncomment and run the code
    // below. After all, you want to smell your cake and eat it, too!

    println!("Yum! I'm eating this cake: {:?}. Oops, I dropped it on the floor.", party.cake);
    drop(cake);
}

pub fn admire_cake(cake: Cake) {
    println!("What a nice {:?} cake! ğŸ‚", cake);
}

pub fn smell_cake<T: Into<Cake>>(something: T) {
    println!("Hmm...something smells like a {:?} cake!", something.into());
}

```



### Error

```rust
// START IN lib.rs!

use anyhow:: Result;
use aquarium::Dolphin;
// Silence some warnings so they don't distract from the exercise.
#[allow(clippy::vec_init_then_push)]

// (You already did #1 in lib.rs, right?)
//
// 2a. Uncomment and finish the play_time function below
// - Bring anyhow::Result into scope with a `use` statement
// - Have the play_time function return a `Result<Vec<String>>`. The vector of Strings will
//   represent successful outcomes of various dolphin tricks.

fn play_time(dolphin: &Dolphin) -> Result<Vec<String>> {
    let mut responses = vec![];
    // 2b. Call the .say_your_name() method on `dolphin`, use `?` to unwrap the value, and push
    // the value onto the `responses` vector.
    //
    let response = dolphin.say_your_name()?;   // this can be done with an intermediate variable...
    responses.push( response ) ;// ...or all on one line. Either way is fine!
    //
    // 2c. Do the same thing as #2b for the .flip() method
    let response = dolphin.flip()?;   
    responses.push( response );
    // 2d. Do the same thing as #2b for the .shake_hands() method
    let response = dolphin.shake_hands()?;   
    responses.push( response );

    Ok(responses)
}

fn main(){
    let dolphins = vec![
        Dolphin {
            name: "Augustinius".into(),
            age: 7,
            hungry: false,
        },
        Dolphin {
            name: "Bitty".into(),
            age: 2,
            hungry: true,
        },
        Dolphin {
            name: "Carson".into(),
            age: 5,
            hungry: true,
        },
        Dolphin {
            name: "Devin".into(),
            age: 6,
            hungry: false,
        },
    ];
    for dolphin in &dolphins {
        // Challenge: Change main() so that it returns a Result, and instead of handling the error
        // that play_time returns, use the try (?) operator to only handle the success condition.
        // 
        // If done correctly, the output of the program will become much shorter. Since play_time
        // returns an Err variant the first time it is called, the try operator will return it from
        // main(), which will end the program at the first error. anyhow's Result will take care of
        // formatting the error output for us.

        // let responses = play_time(dolphin)?;
        // for response in responses {
        //     println!("{} did a FABULOUS PERFORMANCE!", dolphin.name);
        //     println!("  {}", response);
        // }
        
        match play_time(dolphin) {
            Ok(responses) => {
                println!("{} did a FABULOUS PERFORMANCE!", dolphin.name);
                for response in responses {
                    println!("  {}", response);
                }
            }
            Err(e) => println!("{} can't perform today: {}", dolphin.name, e.to_string()),
        }
        
    }
}

```



### Testing

```rust
pub fn sploosh(x: i32, y: i32, z: i32) -> i32 {
    match (x, y, z) {
        (x, _, _) if x < 0 => 99,
        (1, 2, 3) => 4,
        (5, 6, 7) => 3,
        (x, y, z) => x + y - z,
    }
}

pub fn splish(a: i32, b: i32) -> i32 {
    -a + 3 * b
}

// 1. Use the `cfg` attribute to mark the `test` module below as a test module

#[cfg(test)]
mod test {
    // 2. Bring all the library items into scope with a `use` statement
    use super::*;
    // Hint: It's okay to use `*` here.

    // 3. Write a test function that verifies the following condition using the `assert_eq!` or
    // `assert_ne!` macros
    // - sploosh(1, 2, 3) returns 4
    // - sploosh(5, 6, 7) does not return 4
    // - If you pass sploosh a negative number for the first argument, 99 is returned
    #[test]
    fn test_sploosh(){
        assert_eq!(sploosh(1,2,3), 4);
        assert_ne!(sploosh(5,6,7), 4);
        assert_eq!(sploosh(-1,2,3), 99);
    }

    //
    // `cargo test` should run your tests and pass
    // Hint: Don't forget the `#[test]` attribute for your test function!

    // 4. Write a test function that verifies the following conditions using the `assert!` macro
    // - splish(100, 10) is negative
    // - splish(40, 20) is positive
    // - splish(9, 3) is 0
    #[test]
    fn test_splish(){
        assert!(splish(100,10) < 0);
        assert!(splish(40,20) > 0);
        assert!(splish(9,3) == 0);
    }
}

// 5. Create a `tests/` directory and an integration test file `tests/more_tests.rs`
// Inside that file, create a test function that verifies:
// - that `sploosh(splish(-1, 0), splish(1, 1), splish(3, 2))` returns the value `4`
//
// `cargo test` should run your `more_tests.rs` file and pass

// Challenge: Create a benchmark that measures the speed of sploosh(8, 9, 10)
// - Speed up the implementation of sploosh(8, 9, 10) without breaking the other tests.
// - Hint: See Cargo.toml to get you started

```

