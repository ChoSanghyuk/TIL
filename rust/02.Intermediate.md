# Rust Intermediate Concept



## Idiomatic Rust



### rustfmt

- rustì— ë§ëŠ” í¬ë§·ìœ¼ë¡œ codeë¥¼ ë¦¬íŒ©í† ë§ í•´ì¤Œ

- ì„¤ì¹˜
  - `rustup component add rustfmt`
- ì‚¬ìš©
  - `cargo fmt`
- Customize
  - root í´ë”ì— `.rustfmt.toml` íŒŒì¼ì„ ë‘ ìœ¼ë¡œì¨, ì»¤ìŠ¤í„°ë§ˆì´ì§• ê°€ëŠ¥



### clippy

- ì‚¬ìš©

  - `cargo clippy`

- ìš©ë„

  - ì‹¤ì œë¡œ ì½”ë“œë¥¼ ì»´íŒŒì¼ => 450ì—¬ ê°€ì§€ì˜ ë¬¸ì œë“¤ì— ëŒ€í•´ì„œ ì²´í¬í•´ì¤Œ

- ëŒ€í‘œ ì˜ì—­

  1. Style

     - rust conventionì— ë§ëŠ” ë°©ì‹ìœ¼ë¡œ ìœ ë„

  2. Correctness

     - outright wrong or very useless í•œ ì½”ë“œì— ëŒ€í•œ warning

  3. Complexity

     - ë³µì¡í•œ ì½”ë“œë¥¼ ê°„ê²°í•˜ê²Œ ë³€ê²½í•  ìˆ˜ ìˆë„ë¡ ê¶Œê³ 

     - certain / guess í•˜ëŠ” ê²½ìš°ë¡œ ë‚˜ëˆ„ì–´ì§

       :bulb: clippyì˜ ê²½ê³ ë¥¼ ë¬´ì‹œí•˜ê¸° ìœ„í•´ì„œëŠ” `#[allow(clippy::ê²½ê³ ì´ë¦„)]` attributeë¥¼ ì†ŒìŠ¤ì— ì¶”ê°€

  4. Performance

:bulb: `clippy lints`ë¥¼ ê²€ìƒ‰í•´ì„œ ë¬¸ì„œë¥¼ ë³¸ë‹¤ë©´, rustë¥¼ ë” ì˜ ì‘ì„±í•˜ê¸° ìœ„í•œ tipë“¤ì„ ì–»ì„ ìˆ˜ ìˆìŒ



###  :bulb:attribute

- êµ¬ì¡°
  - `#[attribute]`
- ì¢…ë¥˜
  - `outer attribute`
    - it applies to the next item that it is outside of
    - í•´ë‹¹ attribute ë°”ë¡œ ë‹¤ìŒ ì†ŒìŠ¤ì— ëŒ€í•´ì„œë§Œ ì ìš©



## Documentation



### documentation

- ì‹¤í–‰
  - `cargo doc`
  - `cargo doc --no-deps --open`
    - `--no-deps` : generate your library's documentation without generating all the documentation for all your dependencies
    - `--open` : automatically opens the index page of the generated documentation in your default browser
      - or `target/doc/packagename/index.html` ì„ ì§ì ‘ ì—´ì–´ì•¼ í•¨
- ëŒ€ìƒ
  - defaultë¡œëŠ” public ìš”ì†Œë§Œ ìƒì„±
  - private ìš”ì†Œë„ ìƒì„±í•˜ê¸° ìœ„í•´ì„œëŠ” ë³„ë„ ëª…ë ¹ì–´ í•„ìš”
- Tip
  - í•­ìƒ descriptionì„ ìµœìƒë‹¨ì— ì‘ì„±í•œ ì´í›„ì— headerë“¤ê³¼ section ì‘ì„±
  - ì£¼ë¡œ implementation blockì—ëŠ” ì‘ì„±í•˜ì§€ X (ì£¼ë¡œ ë³€ìˆ˜ ì‘ì„± ì‹œì— ëŒ€ë¶€ë¶„ ë‚´ìš©ì´ ë“¤ì–´ê°)



### Outer Documentation Comments

- ì‘ì„±

  1. ë¼ì¸

  ```rust
  /// Number of pieces in the puzzle
  ///
  /// #History
  ///
  /// - ë¸”ë¼ë¸”ë¼
  pub const PUZZLE_PIECES:u32 = 42;
  ```

  2. ë¸”ë¡ 

  ```rust
  /**
  Number of pieces in the puzzle
  
  #History
  ~~
  
  - Clickable link : [`PUZZLE_PIECES`]
  - ë¸”ë¼ë¸”ë¼
  **/
  pub const PUZZLE_PIECES:u32 = 42;
  ```

- markdown ì–´ë²• ì‚¬ìš©

  - ì˜ˆì™¸

    - intra-doc links 

      - hyperlink to other parts of the documentation

      - [`PUZZLE_PIECES`] (`ì€ optional)

      - `[ë‹¤ë¥¸ ë¬¸êµ¬](PUZZLE_PIECES)` ë¡œë„ ê°€ëŠ¥

        :bulb: ë§Œì•½ link ëŒ€ìƒì´ scope ì•ˆì— ìˆì§€ ì•Šë‹¤ë©´, absolute pathë¡œ ì§€ì • O

  



### Inner Documentation Comments

- ìš©ë„
  - document main library, module that you're inside of
  - ë³€ìˆ˜, ë©”ì†Œë“œ ë°”ë¡œ ìœ„ì— ì‘ì„±í•˜ëŠ” ê²ƒì´ ì•„ë‹Œ, íŒŒì¼ ì „ì²´ì— ê´€ë ¨í•œ ë‚´ìš© ì‘ì„±
  
- ì‘ì„±
  - ë¼ì¸ : `//!`
  - ë¸”ë¡ : `/*!   !*/`



## Publishing



### publish crate

- íŠ¹ì§•

  - permanent

    :bulb: private credential, SSH key, AWS access tokenê³¼ ê°™ì€ ì •ë³´ ìœ ì˜

  - Package name should be `Unique`
  - publish í›„ `docs.rs`ì— documentation ìë™ ë“±ì¬

- ë°©ë²•

  1. crates.io ì ‘ì†

  2. Login
  3. Account Settings => API Access & get Token
  4. run `cargo login` & enter Token (once for a machine)
  5. `Cargo.toml` ì‘ì„±
  6. run `cargo publish`

- `Cargo.toml` ì„¤ì • ë‚´ì—­

  - í•„ìˆ˜
    - name
    - version
  - ê¶Œì¥
    - description
    - edition
    - homepage
    - repository
    - readme
    - keyworks
      - 5ê°œê¹Œì§€ ê²€ìƒ‰ í‚¤ì›Œë“œ ì…ë ¥ O
      - `["game", "engine", "graphics"]`
    - categories
      - 5ê°œê¹Œì§€ ì¹´í…Œê³ ë¦¬ ë“±ë¡ O. 
      - ì¹´í…Œê³ ë¦¬ ë“±ë¡ì‹œ ,  `All Valid Category Slugs` í˜ì´ì§€ì˜ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì—ì„œ ë³¼ ìˆ˜ ìˆìŒ
      - `["game-engines"]`
    - license
      - packageì˜ license ë“±ë¡
      - 1ê°œ ì´ˆê³¼ ì‹œ, " " ì•ˆì—ì„œ `OR`ë¡œ êµ¬ë¶„ ê°€ëŠ¥
      - `"MIT OR Apache-2.0"`



## Iterator



### iterator

```rust
let v = vec![6,7,8,9];

for num in v {
    println!("{}", num);
}
```

- for loopëŠ” iteratorì„ íƒìƒ‰í•¨
- ì—¬ê¸°ì„œ `v`ëŠ” iteratorê°€ ì•„ë‹Œë°, ì´ ê²½ìš° `v.into_iter()` ìë™ìœ¼ë¡œ ìˆ˜í–‰

- `into_iter()`
  - returns an iterator which **takes ownership** of the collection



### iterator with closure

```rust
let v = vec![6,7,8];

v.into_iter().for_each(|num| println!("{}", num));
```

- ì¥ì 
  -  `for loop`ë³´ë‹¤ ë¹ ë¦„
  - Iterator Adaptors ì‚¬ìš© O



### Iterator Adaptors

- ê°œë…

  - functional programming paradigmì—ì„œ ì œê³µí•˜ëŠ” toolë¡œ, argumentë¥¼ ê°€ì§€ê³  actionì„ ìˆ˜í–‰ í›„ ê²°ê³¼ ë°˜í™˜
  - ëŒ€ë¶€ë¶„ì˜ iterator traitì˜ ë©”ì†Œë“œëŠ” iterator adapters

- íŠ¹ì§•

  - lazy

    - consumed ë˜ê¸° ì „ê¹Œì§„ ì‹¤í–‰ X

      => ë§ˆì§€ë§‰ì€ Iterator Consumerë¡œ consume

- ê¸°ë³¸ ì˜ˆì œ

  ```rust
  let v = vec![6,7,8];
  
   v.into_iter()
      .map(|x: i32| x*3)
      .filter(|y: &i32| *y%2 == 0)
      .for_each(|z| println!("{}", z));
  ```

  - map

    - valueì˜ ownership ë°›ì•„ì„œ ì²˜ë¦¬

  - filter

    - recieves an immutable reference to the value

      :bulb: filterëŠ” true/falseë¥¼ ë°˜í™˜í•˜ëŠ”ë°, trueì¸ ê°’ë“¤ì„ ì´í›„ì—ë„ ì‚¬ìš©í•˜ê¸° ìœ„í•¨

- Iterator Consumer



### Iterator Consumer

- iteratorì„ ë°›ì•„ì„œ ê²°ê³¼ ì²˜ë¦¬ / ë°˜í™˜

- ë°˜í™˜ ì‹œ, íƒ€ì… ëª…ì‹œ í•„ìš”

  - Typeì„ ë°›ì„ ë•Œ genericìœ¼ë¡œ ì •ì˜ë˜ì–´ ìˆì–´, outputì˜ typeì„ ê²°ì •í•˜ëŠ”ë° ë¬¸ì œê°€ ìˆìŒ

  - ë°©ë²•
  
    1. return ê°’ì„ ë°›ëŠ” ë³€ìˆ˜ì— íƒ€ì… ëª…ì‹œ
    2. ë©”ì†Œë“œ ìì²´ì— turbofishë¡œ type ì§€ì •
    
    ```rust
    let v = vec![6,7,8];
    
    // ë°©ë²• 1
    let total: i32 = v
    	.into_iter()
    	.map(|x: i32| x*3)
    	.filter(|y: &i32| *y%2 == 0)
    	.sum();
    
    // ë°©ë²• 2
    v.into_iter()
    .map(|x: i32| x*3)
    .filter(|y: &i32| *y%2 == 0)
    .sum::<i32>();
    ```
    

- ì¢…ë¥˜
  - `sum()`
  - `for_each`
  - `collect`
    - gather all the items and put them into a new collection
    - elementì— ëŒ€í•œ íƒ€ì…ì€ ì•Œ ìˆ˜ ìˆëŠ” ê²½ìš° `_`ë¡œ ëŒ€ì²´ ê°€ëŠ¥
      -  `Vec<_>`
      - big, complicated item type ë‹¤ë£° ë•Œ ìœ ìš©



### turbofish

- `::<>`

- specify the type of the generic parameter or parameters for a generic function or method

- ìœ„ì¹˜

  - between the method or function name and the argument list
  - `.sum::<i32>()`

  :bulb: rust syntax ìƒ ê°€ì¥ ë¹„ì„ í˜¸ë˜ëŠ” ë¬¸



### iterator ì „í™˜ ì¢…ë¥˜

- `into_iter()`

  - consumes v, returns owned items
  - sugar form : `for _ in v`

- `iter()`

  - returns immutable references
  - sugar form : `for _ in &v`

- `iter_mut()`

  - returns mutable references
  - sugar form : `for _ in &mut v`

  :bulb: reference typeìœ¼ë¡œ ë°˜í™˜í•  ê²½ìš°, ë‹¨ìˆœ for loopë¥¼ ìˆ˜í–‰í•˜ì—¬ë„ ì†Œìœ ê¶Œ ì „í™˜ X



### drain()

- ì‚¬ìš©

  - empty out a collection without consuming the collection itself
  - In all cases, returns an iterator that takes ownership of some or all items in the collection

- íŠ¹ì§•

  - itemì„ ì œê±°í•  ìˆœ ìˆì–´ë„ collection ìì²´ëŠ” intact í•˜ê²Œ ë‚´ë²„ë ¤ ë‘  => can continue to use it
  - collction ì¢…ë¥˜ì— ë”°ë¼ ë°›ëŠ” argument ë‹¤ë¦„

- case

  - vector

    - `v.drain(..)`
    - vectorì—ì„œ drainí•  ë²”ìœ„ë¥¼ ë°›ìŒ

    :bulb: `..`ì˜ ê²½ìš° ì „ì²´ë¥¼ ì˜ë¯¸

    - drainí•œ ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ê³ , ê¸°ì¡´ vectorì—ëŠ” drain ì•ˆëœ ìš”ì†Œë“¤ì´ ë‚¨ì•„ìˆìŒ

    ```rust
    let mut v = vec![1, 2, 3, 4, 5];
    
    let removed = v.drain(1..4);
    
    assert_eq!(v, vec![1, 5]); // v now only contains the elements outside of the removed range
    assert_eq!(removed.collect::<Vec<_>>(), vec![2, 3, 4]); // removed contains the elements that were removed
    
    ```

  - hash map

    - `h.drain()`
    - take no argument
    - returns all of the key value pairs



## Common Traits



### Common Traits

- 4 things which can Implement traits

  - struct
  - enum
  - closure (only few)
  - function(only few)

- Derivable Traits

  - `derived macro`ê°€ ì •ì˜ë˜ì–´ ìˆìœ¼ë©´, ì‚¬ìš© O
  
  - Debug
    - One of the most common traits to derive
    - struct / enumì— `#[derive(Debug)]` ì ìš© ì‹œ ì‚¬ìš© O
    - ëª¨ë“  primitive íƒ€ì… & ëŒ€ë¶€ë¶„ library íƒ€ì…ë“¤ì€ already Debug
    - ì‚¬ìš©
      - Debug Formatting
        - `println!("{:?}", puzzle)`
      - Pretty Debug Formatting
        - `println!("{:#?}", puzzle)`
    
  - Clone
    - `#[derive(Clone)]` => `.clone()` ì‚¬ìš© O
    
    :bulb: ì—¬ëŸ¬ ê°œ ì ìš© ì‹œ `,`ë¡œ êµ¬ë¶„ : `#[derive(Clone, Debug)]`
    
  - Copy
    - Cloneê³¼ ë¹„ìŠ·
    - move situationì—ì„œ, move ë˜ì§€ ì•Šê³ , copyë¨
    - small values which fit entirely on the stack : primitive Type
    - Heap ì˜ì—­ì— ì €ì¥ë˜ëŠ” Typeë“¤ì€ ì‚¬ìš© X
      - Structê³¼ Enumì€ ê°€ì§€ê³  ìˆëŠ” í•„ë“œì˜ ì¢…ë¥˜ì— ë”°ë¼ Copy ê°€ëŠ¥ ì—¬ë¶€ ê²°ì •ë¨
    
    - subtrait of a Clone => `#[derive(Clone, Copy)]`
    
    :bulb: If you implement a trait, you have to implement all of its parent trait as well
  
  

### How to manually implement a trait

- Bring the Trait Into Scope
  - use `use` statement
- Boilerplate
  - IDE generate
  - go documentation and copy it
- Implementation
  - ì§ì ‘ êµ¬í˜„



### maually implement : `Default`

1. ì½”ë“œë¡œ ê°€ì ¸ì˜¤ê¸°

   - `default`ëŠ” in the standard prelude 

     => by default, it gives you zero numbers, empty string and empty collection

     => not I want

2. ì ìš©í•˜ê³ ì í•˜ëŠ” structì— Boilerplate ì ìš©

   ```rust
   impl Default for Puzzle {
       fn default() -> Self {
           todo!() // panic!("not yet implemented");
       }
   }
   ```

   - `todo!()` macroëŠ” panicí•˜ë„ë¡ ì„¤ì •ë˜ì–´ ìˆìŒ

3. Replace body of the function

   ```rust
   impl Default for Puzzle {
       fn default() -> Self {
           Puzzle {
               num_pieces : PUZZLE_PIECES,
               name : "Forest Lake".to_string(),
           }
       }
   }
   ```

   - Puzzleì„ ìƒˆë¡œ ìƒì„± ì‹œì˜ ê¸°ë³¸ê°’ìœ¼ë¡œ í™œìš©

   - Puzzleì˜ ì”ì—¬ í•„ë“œë“¤  ê¸°ë³¸ê°’ìœ¼ë¡œ í™œìš© : `struct update syntax`

     ```rust
     let puzzle = Puzzle {
         num_pieces: 3000,
         ..Default::default() // ë§ˆì§€ë§‰ì— , ì—†ì–´ì•¼ í•¨
     };
     ```

     - `..` : range operator. 



### PartialEq / Eq

- PartialEq

  - triat that does the actual calculations to test for equality

    ```rust
    impl PartialEq for Puzzle {
        fn eq(&self, other: &Self) -> bool {
            (self.num_pieces == other.num_pieces) && (self.name == other.name)
        }
    }
    ```

    - eq method takes an `immutable reference to self` and an `immutable reference to the other value` 

    :bulb:`&self` = `self: &Self`, `Self` = `Puzzle`

- Eq

  - marker trait that you can implement if the equality logic is `reflexive`, `transitive`, `symmetric`

  - if every possible value is not equal to itself, cannot have Eq marker trait

  - ex) floating point typeì€ `NaN` ê°’ì„ ê°€ì§ˆ ìˆ˜ ìˆìœ¼ë©° `NaN != NaN` ìœ¼ë¯€ë¡œ Eq implement X

    ```rust
    imple Eq for Puzzle {}
    ```

    - now can use a Puzzle as a key in a hash map
    - ëª‡ëª‡ íŠ¹ìˆ˜í•œ ê²½ìš°ì— ì‚¬ìš© ê°€ëŠ¥í•˜ì§€ë§Œ, ì£¼ë¡œ ë¹„êµëŠ” `PartialEq`ë¥¼ í†µí•´ì„œ ì§„í–‰.
    - ì˜¤íˆë ¤ `Eq`ë¥¼ ì•ˆ í•¨ìœ¼ë¡œ, ë” flexibleí•œ `PartialEq` í™œìš©ì´ ê°€ëŠ¥í•´ì§



### From / Into

- `From`ë§Œ implementí•˜ë©´ `into`ëŠ” ìë™ìœ¼ë¡œ implement

- standard preludeì•ˆì— í¬í•¨. import í•„ìš” X

- ê¸°ë³¸ êµ¬í˜„ í˜•íƒœ

  ```rust
  From<T> for U
  Into<U> for T
  ```

  ```rust
  impl From<Puzzle> for String {
      fn from(_: Puzzle) -> Self { // It didnt' pick up parameter name => replace _ with puzzle
          todo!() // puzzle.name
      }
  }
  
  let puzzle = Puzzle::default();
  let s = String::from(puzzle);
  let t: String = puzzle.into();
  ```

- Generic function which takes generic variables of `Into`

  ```rust
  pub fn show<T: Into<String>>(s: T) {
      println!("{}", s.into());
  }
  
  show(puzzle);
  ```

- Both `From`, `Into` traits consume the variable

  ```rust
  impl From<&Puzzle> for String {
      fn from(puzzle: &Puzzle) -> Self {
          puzzle.name.clone()
      }
  }
  show(&puzzle)
  ```

  - ì´í›„ì—ë„ ê°ì²´ë¥¼ ì‚¬ìš©í•˜ê³ ì í•œë‹¤ë©´ `clone` í•„ìš”. But, ê°ì²´ ì „ì²´ë¥¼ cloneí•´ì„œ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ `ë¹„ì‹¼` ì‘ì—…
  - use immutable reference & clone only using fields
    - can't move the field out an immutable reference
  - immutable referenceë¡œ ë³€ê²½í–ˆë‹¤ê³  í•´ì„œ ìœ„ì˜ `show` functionì´ ë°”ë€” í•„ìš”ëŠ” X

â€‹	:bulb: references to types are their own types => references to things can have different traits implemented from the things



## Errors



### Make an Error for a library that you publish

1. Errors should be `enums`

2. Group your errors as variants of as few enums as makes sense

   - Make sense í•˜ê¸°ë§Œ í•˜ë‹¤ë©´, Enum ì•ˆì´ ê¸¸ì–´ì ¸ë„ ìƒê´€ X

3. Should only return your errors from your public library

   - ë‚´ libraryê°€ ë‹¤ë¥¸ libraryì— ì¢…ì†í•˜ê³  ìˆë‹¤ë©´, í•´ë‹¹ libraryì˜ Errorì„ ì§ì ‘ì ìœ¼ë¡œ ë…¸ì¶œì‹œí‚¤ì§€ X
     - If not
       - it gives the external dependency the ability to break you public API
       - prevent you from changing your own library's backend implementation without breaking your own public API
   - í•´ë‹¹ Errorë¥¼ ë‚´ Error enumì— convert ì‹œì¼œì„œ í•¸ë“¤ë§
   - std errorë¼ë©´ ê·¸ëŒ€ë¡œ ë³´ì—¬ì¤˜ë„ ë˜ëŠ” ê²½ìš° æœ‰

4. Enum should be non-exhaustive

   ```rust
   #[non_exhaustive]
   pub enum PuzzleError {
       WontFit(u16),
       MissingPiece,
   }
   ```

   :bulb: `non_exhaustive` : ì¶”í›„ì— í•„ë“œ, ë³€ìˆ˜ê°€ ì¶”ê°€ë  ìˆ˜ ìˆìŒì„ ëª…ì‹œ => `defining crate` ì™¸ì˜ ë°©ì‹ìœ¼ë¡œ ìƒì„± ì œì•½ (wildcard ì‚¬ìš©  X)

5. Implement `Debug + Display + Error` traits in this order

   - Error : Debug + Display

- ìµœì¢…

```rust
use std::error::Error;
use std::fmt::{Display, Formatter};

#[dervie(Debug)]			// #5 : Debug + Display + Error
#[non_exhaustive]			// Non-Exhaustive
pub enum PuzzleError {		// #1 : enum
    WontFit(u16),			// #2 : Group Errors
    MissingPiece,			// #3 : Only Your Errors
}

impl Display for PuzzleError {	// #5 : Debug + Display + Error
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        use PuzzleError::*; // Enumì˜ ë³€ìˆ˜ë“¤ì„ ëª¨ë‘ Localë¡œ ê°€ì ¸ì˜´
        match self {
            MissingPiece => write!(f, "Missing a piece"),
            WontFit(n) => write!(f, "Piece {} doensn't fit!", n),
        }
    }
}

impl Error for PuzzleError{}	// #5 : Debug + Display + Error

```

:bulb: `use` statmentì—ì„œ `*` asterisk ì‚¬ìš©í•´ë„ ë˜ëŠ” 3ê°€ì§€ ê²½ìš° ì¤‘ í•˜ë‚˜



### use `thiserror`

-  `Debug + Display + Error` implementationì˜ ê°„ê²°í™” ì‹œí‚´

1. Add dependencies to `Cargo.toml`

   ```toml
   [dependencies]
   thiserror = "1.0"
   ```

2. Derive `thiserror::Error`

3. add `#[error("...")]` annotations to variants to display message

   ```rust
   use thiserror::Error;
   
   #[derive(Debug, Error)]
   #[non_exhaustive]
   pub enum PuzzleError {
       #[error("Piece {0} doesn't fit!")]
       WontFit(u16),
       #[error("Missing a piece")]
       MissingPiece,
   }
   ```
   
   - tuple dataì˜ ê²½ìš° `{0}`ë¡œ ì•ˆ ë³€ìˆ˜ ì ‘ê·¼ O



### Handling Errors
```rust
// Manually panic
panic!("Your server is on fire");

// Same thing if result is a Result::Err
result.expect("Your server is on fire")

// Same thing, but without a message
result.unwrap();
```

- `panic`
  - ë” ì´ìƒ ì‹œìŠ¤í…œì˜ ì§€ì†ì´ ì•ˆë˜ëŠ” ì—ëŸ¬ ì¼ ë•Œ => System ì¢…ë£Œ
  - ë‹¤ë¥¸ reasonable optionì´ ë” ì´ìƒ ì—†ì„ ë•Œì—ë§Œ ì‚¬ìš©
- `expect`
  - ì»¤ë²„ ê°€ëŠ¥ ì˜ì—­ ì•ˆ ì¼ ë•Œ

â€‹	=> Recoverableí•œ ErrorëŠ” Handle í˜¹ì€ Return í•´ì•¼ í•¨



### Way to handle or return Error

- `if let` expression

  ```rust
  if let Err(e) = my_result {
      println!("Warning: {}", e);
  }
  ```

  - `Err`ì™€ `my_result`ì˜ íƒ€ì…ì´ ê°™ë‹¤ë©´ `{}` ì•ˆì˜ `e`ì— ê°’ ë“¤ì–´ê°€ë©° ì‹¤í–‰

- `match` expression

  ```rust
  let score = match get_saved_score() {
      Ok(x) => x,
      Err(_) => 0,
  }
  ```

  - handle Error with default value => Ok, Err ì‹œ ê°™ì€ íƒ€ì… ë°˜í™˜
  - `unwrap_or(0)` ë©”ì†Œë“œì™€ ë™ì¼ ê¸°ëŠ¥ ìˆ˜í–‰

  ```rust
  let score = get_saved_score().unwrap_or(0);
  ```

- Return the Error

  ```rust
  fn poem() -> Result<String, io::Error> {
      let file = match File::open("file.txt"){
          Ok(f) => f,
          Err(e) => return Err(e1),
      };
      // do stuff
  }
  ```

  - í•¨ìˆ˜ ë‚´ì—ì„œ Err ì²˜ë¦¬ë¥¼ ëª» í•˜ëŠ” ê²½ìš° => callerì—ê²Œ ì²˜ë¦¬ ë„˜ê¹€

- `?` operator

  ```rust
  fn poem() -> Result<String, io::Error> {
      let file = File::open("file.txt")?;
      // do stuff
  }
  ```

  - ìœ„ì˜ match expressionê³¼ ìƒë™

  ```rust
  optinum.stand()?.transaform()?.rollout()?.chase()?
  ```

  - `?`ì„ ì‚¬ìš©í•¨ìœ¼ë¡œì¨ chainingì„ ê°„í¸í•˜ê²Œ í•  ìˆ˜ ìˆ

- `anyhow` library

  - ì—¬ëŸ¬ Err íƒ€ì…ì— ëŒ€í•´ì„œ `?` operator ì‚¬ìš© ê°€ëŠ¥í•˜ê²Œ í•¨

  - `anyhow::Result` : Error trait ì²˜ë¦¬ë¥¼ í†µí•˜ì—¬ ì–´ë– í•œ errorì— ëŒ€í•´ì„œë“  ë™ì‘

    =>  ê°œë°œìëŠ” Resultì˜ Ok typeë§Œ ì‹ ê²½ì“°ë©´ ë¨

  ```rust
  use anyhow::{Context, Result};
  use puzzles:Puzzle;
  use std::fs::File;
  
  fn get_puzzle(filename: &str) -> Result<Puzzle> {
      let fh = File::open(filename).context("couldn't open the puzzle file")?;
      let puzzle = Puzzle::from_file(fh).context("couldn't convert data into a puzzle")?; 
      Ok(puzzle)
  }
  
  fn main() -> Result<()> {
      let puzzle = get_puzzle("puzzle.dat").context("Couldn't get the first puzzle")?;
      println!("Playing puzzle: {}", puzzle.name);
      Ok(())
  }
  ```

  - `anyhow result`
    - io::Error í˜¹ì€ Puzzleì˜ Err implements Error trait => anyhow result accept

  - `context`
    - Bring the trait into scope => allow us to use the context method on Result to add context
    - `expect()` ë©”ì†Œë“œì™€ ìœ ì‚¬í•˜ì§€ë§Œ program crash ì—†ìŒ
  - `main() -> Result<()>`
    - main í•¨ìˆ˜ë„ Result ë°˜í™˜ O
    - the result implements the `Termination trait`
    - `()` : one of the anyhow's Results wraaping the unit type

  :bulb: `with_context`

  ```rust
  let fh = File::open(filename).with_context(|| format!("couldn't open the puzzle file {}", filename))?; 
  ```

  - closureëŠ” errorê°€ ë°œìƒí•  ë•Œë§Œ ë™ì‘ => avoid the overhead of allocating and formatting the string in success case

  



eyre snafu



â€» "Error Handling isn't all about errors" by Jane Jusby ë³´ëŠ”ê±° ì¶”ì²œ





## ì½”ë“œ ì˜ˆì œ



### closure-iterators

```rust
// Yes, yes, we know. It's an exercise, compiler, we want it that way!
#[allow(unused_mut)]

fn main() {
    // 1. Uncomment the code below. Create a closure that returns the square of an integer (the
    // number multiplied by itself), and assign the closure to the "square" variable. Then run the
    // code and make sure it works.

    let square = |x| x*x;
    println!("5 squared is {}", square(5));

    // 2. Uncomment the code below.  Finish the .map() iterator adaptor call by passing it a closure
    // which takes a tuple of two integers as a parameter, and returns a tuple with the first
    // integer incremented by 1, and the second integer left alone.  For example, if given the input
    // (0, 1), it should return (1, 1). Run the code and make sure it works.

    let pairs = vec![(0, 1), (2, 3), (4, 5)];
    pairs
        .into_iter()
        .map( |t| (t.0+1, t.1) )
        .for_each(|t| println!("{:?}", t));

    // 3. Uncomment the code below. There is a mutable vector named `numbers`. Use an iterator over
    // mutable references to multiply each of the values in `numbers` by 3.
    // Hint 1: You'll need .iter_mut() -- bonus points if you use the shorter, syntactic sugar form!
    // Hint 2: `x` will be a mutable reference, so remember to dereference it to use it

    let mut numbers = vec![1, 2, 3, 4];
    for x in &mut numbers {
        *x = *x*3 // multiply the value by 3 via the mutable reference x
    }
    println!("{:?}", numbers); // should print [3, 6, 9, 12]

    // 4. Uncomment the code below.  Take the vector of words and
    // - Convert the vector into an iterator with .into_iter()
    // - Use .filter() to remove any word that contains the letter "h" -- use .contains()
    // - Use .map() to convert all the words to uppercase -- use .to_uppercase()
    // - Use .collect() to put the transformed words back into a vector
    //
    // Hint: .to_uppercase() is a method on `str` which returns a String

    let words = vec!["autobot", "beach", "car", "decepticon", "energon", "frothy"];
    let transformed: Vec<_> = words.into_iter()   // do the stuff here
            .filter(|&x| !x.contains("h"))
            .map(|x| x.to_uppercase())
            .collect();
    
    println!("Transformed: {:?}", transformed);

    // Challenge:
    //
    // - Rewrite the code in #2 as a for loop
    // - Rewrite the code in #3 in functional style (without a for loop).  Hint: There are multiple
    // ways to accomplish this, but they all end with an iterator consumer.
}

```



### Common Trait

```rust
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Cake {
    Chocolate,
    MapleBacon,
    Spice,
}

#[derive(Debug)]
pub struct Party {
    pub at_restaurant: bool,
    pub num_people: u8,
    pub cake: Cake,
}

impl Default for Party {

    fn default() -> Self {
        Party {
            at_restaurant: true,
            num_people: 8,
            cake: Cake::Chocolate,
        }
    }
}

impl PartialEq for Party {
    fn eq(&self, other: &Self) -> bool {
        self.cake == other.cake
    }
}

impl From<&Party> for Cake  {

    fn from(party: &Party) -> Self {
        party.cake
    }
}



fn main() {
    // 1. The code below doesn't work because Cake doesn't implement Debug.
    // - Derive the Debug trait for the Cake enum above so this code will work. Then, run the code.

    let cake = Cake::Spice;
    admire_cake(cake);

    // 2. Uncomment the code below. It doesn't work since `cake` was *moved* into the admire_cake()
    // function. Let's fix the Cake enum so the code below works without any changes.
    // - Derive the Copy trait for the Cake enum so that `cake` gets copied into the admire_cake()
    // function instead of moved.
    // - Hint: You may need to derive another trait in order to be able to derive the Copy trait

    match cake {
        Cake::Chocolate => println!("The name's Chocolate. Dark...Chocolate."),
        Cake::MapleBacon => println!("Dreams do come true!"),
        Cake::Spice => println!("Great, let's spice it up!"),
    }

    // 3. Uncomment the println below. It doesn't work since the Party struct doesn't implement the
    // Debug or Default traits.
    // - Derive the Debug trait for the Party struct
    // - Manually implement the Default trait for the Party struct. Use the value below as the
    // default value that you return from the `default` method:
    //
        // Party {
        //     at_restaurant: true,
        //     num_people: 8,
        //     cake: Cake::Chocolate,
        // }
    //
    // Hint: If you get stuck, there is an example at
    // https://doc.rust-lang.org/std/default/trait.Default.html#how-can-i-implement-default

    println!("The default Party is\n{:#?}", Party::default());

    // 4. You prefer Maple Bacon cake. Use "struct update syntax" to create a Party with `cake`
    // set to `Cake::MapleBacon`, but the rest of the values are default.
    //
    // Hint: The trick to struct update syntax is specifying the value(s) you want to customize
    // first and then ending the struct with `..Default::default()` -- but no comma after that!

    let party = Party {
        cake : Cake::MapleBacon,
        ..Default::default()
    };
    println!("Yes! My party has my favorite {:?} cake!", party.cake);

    // 5. Parties are "equal" if they have the same cake.
    // - Derive the PartialEq trait for the Cake enum so Cakes can be compared.
    // - Manually implement the PartialEq trait for Party. If different parties have the same cake,
    // then they are equal, no matter the location or number of attendees at the party.
    // - Uncomment and run the code below.

    let other_party = Party {
        at_restaurant: false,
        num_people: 235,
        cake: Cake::MapleBacon,
    };
    if party == other_party {
        println!("Your party is just like mine!");
    }

    // Challenge: You would like to be able to pass a Party struct into the smell_cake() function
    // which takes a type T which implements the Into<Cake> trait.
    // - Uncomment the code below AND uncomment the smell_cake() function at the bottom of this file
    // - Implement `From<Party> for Cake` so that the function call below works.
    //

    smell_cake(&party);

    // Challenge 2: Implement `From<&Party> for Cake` so that you can smell your cake without
    // consuming it. Change the code above to pass in a &party. Then uncomment and run the code
    // below. After all, you want to smell your cake and eat it, too!

    println!("Yum! I'm eating this cake: {:?}. Oops, I dropped it on the floor.", party.cake);
    drop(cake);
}

pub fn admire_cake(cake: Cake) {
    println!("What a nice {:?} cake! ğŸ‚", cake);
}

pub fn smell_cake<T: Into<Cake>>(something: T) {
    println!("Hmm...something smells like a {:?} cake!", something.into());
}

```













