# Rust Intermediate Concept



## Idiomatic Rust



### rustfmt

- rust에 맞는 포맷으로 code를 리팩토링 해줌

- 설치
  - `rustup component add rustfmt`
- 사용
  - `cargo fmt`
- Customize
  - root 폴더에 `.rustfmt.toml` 파일을 둠으로써, 커스터마이징 가능



### clippy

- 사용

  - `cargo clippy`

- 용도

  - 실제로 코드를 컴파일 => 450여 가지의 문제들에 대해서 체크해줌

- 대표 영역

  1. Style

     - rust convention에 맞는 방식으로 유도

  2. Correctness

     - outright wrong or very useless 한 코드에 대한 warning

  3. Complexity

     - 복잡한 코드를 간결하게 변경할 수 있도록 권고

     - certain / guess 하는 경우로 나누어짐

       :bulb: clippy의 경고를 무시하기 위해서는 `#[allow(clippy::경고이름)]` attribute를 소스에 추가

  4. Performance

:bulb: `clippy lints`를 검색해서 문서를 본다면, rust를 더 잘 작성하기 위한 tip들을 얻을 수 있음



###  :bulb:attribute

- 구조
  - `#[attribute]`
- 종류
  - `outer attribute`
    - it applies to the next item that it is outside of
    - 해당 attribute 바로 다음 소스에 대해서만 적용



## Documentation



### documentation

- 실행
  - `cargo doc`
  - `cargo doc --no-deps --open`
    - `--no-deps` : generate your library's documentation without generating all the documentation for all your dependencies
    - `--open` : automatically opens the index page of the generated documentation in your default browser
      - or `target/doc/packagename/index.html` 을 직접 열어야 함
- 대상
  - default로는 public 요소만 생성
  - private 요소도 생성하기 위해서는 별도 명령어 필요
- Tip
  - 항상 description을 최상단에 작성한 이후에 header들과 section 작성
  - 주로 implementation block에는 작성하지 X (주로 변수 작성 시에 대부분 내용이 들어감)



### Outer Documentation Comments

- 작성

  1. 라인

  ```rust
  /// Number of pieces in the puzzle
  ///
  /// #History
  ///
  /// - 블라블라
  pub const PUZZLE_PIECES:u32 = 42;
  ```

  2. 블록 

  ```rust
  /**
  Number of pieces in the puzzle
  
  #History
  ~~
  
  - Clickable link : [`PUZZLE_PIECES`]
  - 블라블라
  **/
  pub const PUZZLE_PIECES:u32 = 42;
  ```

- markdown 어법 사용

  - 예외

    - intra-doc links 

      - hyperlink to other parts of the documentation

      - [`PUZZLE_PIECES`] (`은 optional)

      - `[다른 문구](PUZZLE_PIECES)` 로도 가능

        :bulb: 만약 link 대상이 scope 안에 있지 않다면, absolute path로 지정 O

  



### Inner Documentation Comments

- 용도
  - document main library, module that you're inside of
  - 변수, 메소드 바로 위에 작성하는 것이 아닌, 파일 전체에 관련한 내용 작성
  
- 작성
  - 라인 : `//!`
  - 블록 : `/*!   !*/`



## Publishing



### publish crate

- 특징

  - permanent

    :bulb: private credential, SSH key, AWS access token과 같은 정보 유의

  - Package name should be `Unique`
  - publish 후 `docs.rs`에 documentation 자동 등재

- 방법

  1. crates.io 접속

  2. Login
  3. Account Settings => API Access & get Token
  4. run `cargo login` & enter Token (once for a machine)
  5. `Cargo.toml` 작성
  6. run `cargo publish`

- `Cargo.toml` 설정 내역

  - 필수
    - name
    - version
  - 권장
    - description
    - edition
    - homepage
    - repository
    - readme
    - keyworks
      - 5개까지 검색 키워드 입력 O
      - `["game", "engine", "graphics"]`
    - categories
      - 5개까지 카테고리 등록 O. 
      - 카테고리 등록시 ,  `All Valid Category Slugs` 페이지의 해당 카테고리에서 볼 수 있음
      - `["game-engines"]`
    - license
      - package의 license 등록
      - 1개 초과 시, " " 안에서 `OR`로 구분 가능
      - `"MIT OR Apache-2.0"`



## Iterator



### iterator

```rust
let v = vec![6,7,8,9];

for num in v {
    println!("{}", num);
}
```

- for loop는 iterator을 탐색함
- 여기서 `v`는 iterator가 아닌데, 이 경우 `v.into_iter()` 자동으로 수행

- `into_iter()`
  - returns an iterator which **takes ownership** of the collection



### iterator with closure

```rust
let v = vec![6,7,8];

v.into_iter().for_each(|num| println!("{}", num));
```

- 장점
  -  `for loop`보다 빠름
  - Iterator Adaptors 사용 O



### Iterator Adaptors

- 개념

  - functional programming paradigm에서 제공하는 tool로, argument를 가지고 action을 수행 후 결과 반환
  - 대부분의 iterator trait의 메소드는 iterator adapters

- 특징

  - lazy

    - consumed 되기 전까진 실행 X

      => 마지막은 Iterator Consumer로 consume

- 기본 예제

  ```rust
  let v = vec![6,7,8];
  
   v.into_iter()
      .map(|x: i32| x*3)
      .filter(|y: &i32| *y%2 == 0)
      .for_each(|z| println!("{}", z));
  ```

  - map

    - value의 ownership 받아서 처리

  - filter

    - recieves an immutable reference to the value

      :bulb: filter는 true/false를 반환하는데, true인 값들을 이후에도 사용하기 위함

- Iterator Consumer



### Iterator Consumer

- iterator을 받아서 결과 처리 / 반환

- 반환 시, 타입 명시 필요

  - Type을 받을 때 generic으로 정의되어 있어, output의 type을 결정하는데 문제가 있음

  - 방법
  
    1. return 값을 받는 변수에 타입 명시
    2. 메소드 자체에 turbofish로 type 지정
    
    ```rust
    let v = vec![6,7,8];
    
    // 방법 1
    let total: i32 = v
    	.into_iter()
    	.map(|x: i32| x*3)
    	.filter(|y: &i32| *y%2 == 0)
    	.sum();
    
    // 방법 2
    v.into_iter()
    .map(|x: i32| x*3)
    .filter(|y: &i32| *y%2 == 0)
    .sum::<i32>();
    ```
    

- 종류
  - `sum()`
  - `for_each`
  - `collect`
    - gather all the items and put them into a new collection
    - element에 대한 타입은 알 수 있는 경우 `_`로 대체 가능
      -  `Vec<_>`
      - big, complicated item type 다룰 때 유용



### turbofish

- `::<>`

- specify the type of the generic parameter or parameters for a generic function or method

- 위치

  - between the method or function name and the argument list
  - `.sum::<i32>()`

  :bulb: rust syntax 상 가장 비선호되는 문



### iterator 전환 종류

- `into_iter()`

  - consumes v, returns owned items
  - sugar form : `for _ in v`

- `iter()`

  - returns immutable references
  - sugar form : `for _ in &v`

- `iter_mut()`

  - returns mutable references
  - sugar form : `for _ in &mut v`

  :bulb: reference type으로 반환할 경우, 단순 for loop를 수행하여도 소유권 전환 X



### drain()

- 사용

  - empty out a collection without consuming the collection itself
  - In all cases, returns an iterator that takes ownership of some or all items in the collection

- 특징

  - item을 제거할 순 있어도 collection 자체는 intact 하게 내버려 둠 => can continue to use it
  - collction 종류에 따라 받는 argument 다름

- case

  - vector

    - `v.drain(..)`
    - vector에서 drain할 범위를 받음

    :bulb: `..`의 경우 전체를 의미

    - drain한 결과를 반환하고, 기존 vector에는 drain 안된 요소들이 남아있음

    ```rust
    let mut v = vec![1, 2, 3, 4, 5];
    
    let removed = v.drain(1..4);
    
    assert_eq!(v, vec![1, 5]); // v now only contains the elements outside of the removed range
    assert_eq!(removed.collect::<Vec<_>>(), vec![2, 3, 4]); // removed contains the elements that were removed
    
    ```

  - hash map

    - `h.drain()`
    - take no argument
    - returns all of the key value pairs



## Common Traits



### Common Traits

- 4 things which can Implement traits

  - struct
  - enum
  - closure (only few)
  - function(only few)

- Derivable Traits

  - `derived macro`가 정의되어 있으면, 사용 O
  
  - Debug
    - One of the most common traits to derive
    - struct / enum에 `#[derive(Debug)]` 적용 시 사용 O
    - 모든 primitive 타입 & 대부분 library 타입들은 already Debug
    - 사용
      - Debug Formatting
        - `println!("{:?}", puzzle)`
      - Pretty Debug Formatting
        - `println!("{:#?}", puzzle)`
    
  - Clone
    - `#[derive(Clone)]` => `.clone()` 사용 O
    
    :bulb: 여러 개 적용 시 `,`로 구분 : `#[derive(Clone, Debug)]`
    
  - Copy
    - Clone과 비슷
    - move situation에서, move 되지 않고, copy됨
    - small values which fit entirely on the stack : primitive Type
    - Heap 영역에 저장되는 Type들은 사용 X
      - Struct과 Enum은 가지고 있는 필드의 종류에 따라 Copy 가능 여부 결정됨
    
    - subtrait of a Clone => `#[derive(Clone, Copy)]`
    
    :bulb: If you implement a trait, you have to implement all of its parent trait as well
  
  

### How to manually implement a trait

- Bring the Trait Into Scope
  - use `use` statement
- Boilerplate
  - IDE generate
  - go documentation and copy it
- Implementation
  - 직접 구현



### maually implement : `Default`

1. 코드로 가져오기

   - `default`는 in the standard prelude 

     => by default, it gives you zero numbers, empty string and empty collection

     => not I want

2. 적용하고자 하는 struct에 Boilerplate 적용

   ```rust
   impl Default for Puzzle {
       fn default() -> Self {
           todo!() // panic!("not yet implemented");
       }
   }
   ```

   - `todo!()` macro는 panic하도록 설정되어 있음

3. Replace body of the function

   ```rust
   impl Default for Puzzle {
       fn default() -> Self {
           Puzzle {
               num_pieces : PUZZLE_PIECES,
               name : "Forest Lake".to_string(),
           }
       }
   }
   ```

   - Puzzle을 새로 생성 시의 기본값으로 활용

   - Puzzle의 잔여 필드들  기본값으로 활용 : `struct update syntax`

     ```rust
     let puzzle = Puzzle {
         num_pieces: 3000,
         ..Default::default() // 마지막에 , 없어야 함
     };
     ```

     - `..` : range operator. 



### PartialEq / Eq

- PartialEq

  - triat that does the actual calculations to test for equality

    ```rust
    impl PartialEq for Puzzle {
        fn eq(&self, other: &Self) -> bool {
            (self.num_pieces == other.num_pieces) && (self.name == other.name)
        }
    }
    ```

    - eq method takes an `immutable reference to self` and an `immutable reference to the other value` 

    :bulb:`&self` = `self: &Self`, `Self` = `Puzzle`

- Eq

  - marker trait that you can implement if the equality logic is `reflexive`, `transitive`, `symmetric`

  - if every possible value is not equal to itself, cannot have Eq marker trait

  - ex) floating point type은 `NaN` 값을 가질 수 있으며 `NaN != NaN` 으므로 Eq implement X

    ```rust
    imple Eq for Puzzle {}
    ```

    - now can use a Puzzle as a key in a hash map
    - 몇몇 특수한 경우에 사용 가능하지만, 주로 비교는 `PartialEq`를 통해서 진행.
    - 오히려 `Eq`를 안 함으로, 더 flexible한 `PartialEq` 활용이 가능해짐



### From / Into

- `From`만 implement하면 `into`는 자동으로 implement

- standard prelude안에 포함. import 필요 X

- 기본 구현 형태

  ```rust
  From<T> for U
  Into<U> for T
  ```

  ```rust
  impl From<Puzzle> for String {
      fn from(_: Puzzle) -> Self { // It didnt' pick up parameter name => replace _ with puzzle
          todo!() // puzzle.name
      }
  }
  
  let puzzle = Puzzle::default();
  let s = String::from(puzzle);
  let t: String = puzzle.into();
  ```

- Generic function which takes generic variables of `Into`

  ```rust
  pub fn show<T: Into<String>>(s: T) {
      println!("{}", s.into());
  }
  
  show(puzzle);
  ```

- Both `From`, `Into` traits consume the variable

  ```rust
  impl From<&Puzzle> for String {
      fn from(puzzle: &Puzzle) -> Self {
          puzzle.name.clone()
      }
  }
  show(&puzzle)
  ```

  - 이후에도 객체를 사용하고자 한다면 `clone` 필요. But, 객체 전체를 clone해서 사용하는 것은 `비싼` 작업
  - use immutable reference & clone only using fields
    - can't move the field out an immutable reference
  - immutable reference로 변경했다고 해서 위의 `show` function이 바뀔 필요는 X

​	:bulb: references to types are their own types => references to things can have different traits implemented from the things



## Errors



### Make an Error for a library that you publish

1. Errors should be `enums`

2. Group your errors as variants of as few enums as makes sense

   - Make sense 하기만 하다면, Enum 안이 길어져도 상관 X

3. Should only return your errors from your public library

   - 내 library가 다른 library에 종속하고 있다면, 해당 library의 Error을 직접적으로 노출시키지 X
     - If not
       - it gives the external dependency the ability to break you public API
       - prevent you from changing your own library's backend implementation without breaking your own public API
   - 해당 Error를 내 Error enum에 convert 시켜서 핸들링
   - std error라면 그대로 보여줘도 되는 경우 有

4. Enum should be non-exhaustive

   ```rust
   #[non_exhaustive]
   pub enum PuzzleError {
       WontFit(u16),
       MissingPiece,
   }
   ```

   :bulb: `non_exhaustive` : 추후에 필드, 변수가 추가될 수 있음을 명시 => `defining crate` 외의 방식으로 생성 제약 (wildcard 사용  X)

5. Implement `Debug + Display + Error` traits in this order

   - Error : Debug + Display

- 최종

```rust
use std::error::Error;
use std::fmt::{Display, Formatter};

#[dervie(Debug)]			// #5 : Debug + Display + Error
#[non_exhaustive]			// Non-Exhaustive
pub enum PuzzleError {		// #1 : enum
    WontFit(u16),			// #2 : Group Errors
    MissingPiece,			// #3 : Only Your Errors
}

impl Display for PuzzleError {	// #5 : Debug + Display + Error
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        use PuzzleError::*; // Enum의 변수들을 모두 Local로 가져옴
        match self {
            MissingPiece => write!(f, "Missing a piece"),
            WontFit(n) => write!(f, "Piece {} doensn't fit!", n),
        }
    }
}

impl Error for PuzzleError{}	// #5 : Debug + Display + Error

```

:bulb: `use` statment에서 `*` asterisk 사용해도 되는 3가지 경우 중 하나



### use `thiserror`

-  `Debug + Display + Error` implementation의 간결화 시킴

1. Add dependencies to `Cargo.toml`

   ```toml
   [dependencies]
   thiserror = "1.0"
   ```

2. Derive `thiserror::Error`

3. add `#[error("...")]` annotations to variants to display message

   ```rust
   use thiserror::Error;
   
   #[derive(Debug, Error)]
   #[non_exhaustive]
   pub enum PuzzleError {
       #[error("Piece {0} doesn't fit!")]
       WontFit(u16),
       #[error("Missing a piece")]
       MissingPiece,
   }
   ```
   
   - tuple data의 경우 `{0}`로 안 변수 접근 O



### Handling Errors
```rust
// Manually panic
panic!("Your server is on fire");

// Same thing if result is a Result::Err
result.expect("Your server is on fire")

// Same thing, but without a message
result.unwrap();
```

- `panic`
  - 더 이상 시스템의 지속이 안되는 에러 일 때 => System 종료
  - 다른 reasonable option이 더 이상 없을 때에만 사용
- `expect`
  - 커버 가능 영역 안 일 때

​	=> Recoverable한 Error는 Handle 혹은 Return 해야 함



### Way to handle or return Error

- `if let` expression

  ```rust
  if let Err(e) = my_result {
      println!("Warning: {}", e);
  }
  ```

  - `Err`와 `my_result`의 타입이 같다면 `{}` 안의 `e`에 값 들어가며 실행

- `match` expression

  ```rust
  let score = match get_saved_score() {
      Ok(x) => x,
      Err(_) => 0,
  }
  ```

  - handle Error with default value => Ok, Err 시 같은 타입 반환
  - `unwrap_or(0)` 메소드와 동일 기능 수행

  ```rust
  let score = get_saved_score().unwrap_or(0);
  ```

- Return the Error

  ```rust
  fn poem() -> Result<String, io::Error> {
      let file = match File::open("file.txt"){
          Ok(f) => f,
          Err(e) => return Err(e1),
      };
      // do stuff
  }
  ```

  - 함수 내에서 Err 처리를 못 하는 경우 => caller에게 처리 넘김

- `?` operator

  ```rust
  fn poem() -> Result<String, io::Error> {
      let file = File::open("file.txt")?;
      // do stuff
  }
  ```

  - 위의 match expression과 상동

  ```rust
  optinum.stand()?.transaform()?.rollout()?.chase()?
  ```

  - `?`을 사용함으로써 chaining을 간편하게 할 수 있

- `anyhow` library

  - 여러 Err 타입에 대해서 `?` operator 사용 가능하게 함

  - `anyhow::Result` : Error trait 처리를 통하여 어떠한 error에 대해서든 동작

    =>  개발자는 Result의 Ok type만 신경쓰면 됨

  ```rust
  use anyhow::{Context, Result};
  use puzzles:Puzzle;
  use std::fs::File;
  
  fn get_puzzle(filename: &str) -> Result<Puzzle> {
      let fh = File::open(filename).context("couldn't open the puzzle file")?;
      let puzzle = Puzzle::from_file(fh).context("couldn't convert data into a puzzle")?; 
      Ok(puzzle)
  }
  
  fn main() -> Result<()> {
      let puzzle = get_puzzle("puzzle.dat").context("Couldn't get the first puzzle")?;
      println!("Playing puzzle: {}", puzzle.name);
      Ok(())
  }
  ```

  - `anyhow result`
    - io::Error 혹은 Puzzle의 Err implements Error trait => anyhow result accept

  - `context`
    - Bring the trait into scope => allow us to use the context method on Result to add context
    - `expect()` 메소드와 유사하지만 program crash 없음
  - `main() -> Result<()>`
    - main 함수도 Result 반환 O
    - the result implements the `Termination trait`
    - `()` : one of the anyhow's Results wraaping the unit type

  :bulb: `with_context`

  ```rust
  let fh = File::open(filename).with_context(|| format!("couldn't open the puzzle file {}", filename))?; 
  ```

  - closure는 error가 발생할 때만 동작 => avoid the overhead of allocating and formatting the string in success case

  



eyre snafu



※ "Error Handling isn't all about errors" by Jane Jusby 보는거 추천





## 코드 예제



### closure-iterators

```rust
// Yes, yes, we know. It's an exercise, compiler, we want it that way!
#[allow(unused_mut)]

fn main() {
    // 1. Uncomment the code below. Create a closure that returns the square of an integer (the
    // number multiplied by itself), and assign the closure to the "square" variable. Then run the
    // code and make sure it works.

    let square = |x| x*x;
    println!("5 squared is {}", square(5));

    // 2. Uncomment the code below.  Finish the .map() iterator adaptor call by passing it a closure
    // which takes a tuple of two integers as a parameter, and returns a tuple with the first
    // integer incremented by 1, and the second integer left alone.  For example, if given the input
    // (0, 1), it should return (1, 1). Run the code and make sure it works.

    let pairs = vec![(0, 1), (2, 3), (4, 5)];
    pairs
        .into_iter()
        .map( |t| (t.0+1, t.1) )
        .for_each(|t| println!("{:?}", t));

    // 3. Uncomment the code below. There is a mutable vector named `numbers`. Use an iterator over
    // mutable references to multiply each of the values in `numbers` by 3.
    // Hint 1: You'll need .iter_mut() -- bonus points if you use the shorter, syntactic sugar form!
    // Hint 2: `x` will be a mutable reference, so remember to dereference it to use it

    let mut numbers = vec![1, 2, 3, 4];
    for x in &mut numbers {
        *x = *x*3 // multiply the value by 3 via the mutable reference x
    }
    println!("{:?}", numbers); // should print [3, 6, 9, 12]

    // 4. Uncomment the code below.  Take the vector of words and
    // - Convert the vector into an iterator with .into_iter()
    // - Use .filter() to remove any word that contains the letter "h" -- use .contains()
    // - Use .map() to convert all the words to uppercase -- use .to_uppercase()
    // - Use .collect() to put the transformed words back into a vector
    //
    // Hint: .to_uppercase() is a method on `str` which returns a String

    let words = vec!["autobot", "beach", "car", "decepticon", "energon", "frothy"];
    let transformed: Vec<_> = words.into_iter()   // do the stuff here
            .filter(|&x| !x.contains("h"))
            .map(|x| x.to_uppercase())
            .collect();
    
    println!("Transformed: {:?}", transformed);

    // Challenge:
    //
    // - Rewrite the code in #2 as a for loop
    // - Rewrite the code in #3 in functional style (without a for loop).  Hint: There are multiple
    // ways to accomplish this, but they all end with an iterator consumer.
}

```



### Common Trait

```rust
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Cake {
    Chocolate,
    MapleBacon,
    Spice,
}

#[derive(Debug)]
pub struct Party {
    pub at_restaurant: bool,
    pub num_people: u8,
    pub cake: Cake,
}

impl Default for Party {

    fn default() -> Self {
        Party {
            at_restaurant: true,
            num_people: 8,
            cake: Cake::Chocolate,
        }
    }
}

impl PartialEq for Party {
    fn eq(&self, other: &Self) -> bool {
        self.cake == other.cake
    }
}

impl From<&Party> for Cake  {

    fn from(party: &Party) -> Self {
        party.cake
    }
}



fn main() {
    // 1. The code below doesn't work because Cake doesn't implement Debug.
    // - Derive the Debug trait for the Cake enum above so this code will work. Then, run the code.

    let cake = Cake::Spice;
    admire_cake(cake);

    // 2. Uncomment the code below. It doesn't work since `cake` was *moved* into the admire_cake()
    // function. Let's fix the Cake enum so the code below works without any changes.
    // - Derive the Copy trait for the Cake enum so that `cake` gets copied into the admire_cake()
    // function instead of moved.
    // - Hint: You may need to derive another trait in order to be able to derive the Copy trait

    match cake {
        Cake::Chocolate => println!("The name's Chocolate. Dark...Chocolate."),
        Cake::MapleBacon => println!("Dreams do come true!"),
        Cake::Spice => println!("Great, let's spice it up!"),
    }

    // 3. Uncomment the println below. It doesn't work since the Party struct doesn't implement the
    // Debug or Default traits.
    // - Derive the Debug trait for the Party struct
    // - Manually implement the Default trait for the Party struct. Use the value below as the
    // default value that you return from the `default` method:
    //
        // Party {
        //     at_restaurant: true,
        //     num_people: 8,
        //     cake: Cake::Chocolate,
        // }
    //
    // Hint: If you get stuck, there is an example at
    // https://doc.rust-lang.org/std/default/trait.Default.html#how-can-i-implement-default

    println!("The default Party is\n{:#?}", Party::default());

    // 4. You prefer Maple Bacon cake. Use "struct update syntax" to create a Party with `cake`
    // set to `Cake::MapleBacon`, but the rest of the values are default.
    //
    // Hint: The trick to struct update syntax is specifying the value(s) you want to customize
    // first and then ending the struct with `..Default::default()` -- but no comma after that!

    let party = Party {
        cake : Cake::MapleBacon,
        ..Default::default()
    };
    println!("Yes! My party has my favorite {:?} cake!", party.cake);

    // 5. Parties are "equal" if they have the same cake.
    // - Derive the PartialEq trait for the Cake enum so Cakes can be compared.
    // - Manually implement the PartialEq trait for Party. If different parties have the same cake,
    // then they are equal, no matter the location or number of attendees at the party.
    // - Uncomment and run the code below.

    let other_party = Party {
        at_restaurant: false,
        num_people: 235,
        cake: Cake::MapleBacon,
    };
    if party == other_party {
        println!("Your party is just like mine!");
    }

    // Challenge: You would like to be able to pass a Party struct into the smell_cake() function
    // which takes a type T which implements the Into<Cake> trait.
    // - Uncomment the code below AND uncomment the smell_cake() function at the bottom of this file
    // - Implement `From<Party> for Cake` so that the function call below works.
    //

    smell_cake(&party);

    // Challenge 2: Implement `From<&Party> for Cake` so that you can smell your cake without
    // consuming it. Change the code above to pass in a &party. Then uncomment and run the code
    // below. After all, you want to smell your cake and eat it, too!

    println!("Yum! I'm eating this cake: {:?}. Oops, I dropped it on the floor.", party.cake);
    drop(cake);
}

pub fn admire_cake(cake: Cake) {
    println!("What a nice {:?} cake! 🎂", cake);
}

pub fn smell_cake<T: Into<Cake>>(something: T) {
    println!("Hmm...something smells like a {:?} cake!", something.into());
}

```













