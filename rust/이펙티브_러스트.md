# Effective Rust



# Item 1. 데이터 구조를 타입 시스템으로 표현하라



### 튜플 구조체

구조체 전체에 대해서는 이름을 붙일 수 있지만, 개별 필드에는 이름이 없고, s.0, s.1 등과 같은 숫자로 표현



### enum 사용법

- enum을 사용하여 파라미터를 지정하면 호출 지점의 가독성과 타입 안정성을 높일 수 있음

  - 올바르지 않은 코드

    ```rust
    pub fn print_page(both_sides: bool, color:bool) { }
    ```

  - 올바른 코드

    ```rust
    pub enum Sides {
      Both,
      Single,
    }
    pub enum Output {
      BlackAndWhite,
      Color,
    }
    
    pub fn print_page(sides: Sides, color: Output) {
      //…
    }
    ```

    - bool 타입 인수를 받도록 정의할 때와 달리, 라이브러리 사용자가 실수로 인수의 순서를 바꿔적으면 컴파일러가 즉시 오류 메시지를 출력

    - 항상 bool 타입임을 나타낸다면 뉴타입 패턴을 사용하고, 새로운 대안이 나올 가능성이 있다면 enum을 사용하는 것이 좋음

- enum에 대한 타입 안정성은 match 표현식으로도 보장 가능하다.

  - 컴파일러는 enum으로 표현되는 모든 경우의 수를 프로그래머가 반드시 검토하도록 요구

  - 모든 가능성을 고려해야 한다는 특성 때문에 기존 enum에 배리언트를 새로 추가하는 것은 중대한 변경에 해당

- 유효하지 않은 상태가 타입에 표현될 수 없게 만들어야 함

  - 올바르지 않은 코드

    ```rust
    pub struct DisplayProps {
      pub x: u32,
      pub y: u32,
      pub monochrome: bool,
      // monochrome 이 참이면 fg_color는 반드시 (0, 0, 0) 이어야 한다.
      pub fg_color: Rgbcolor,
    }
    ```

  - 올바른 코드

    ```rust
    pub enum Color 1
      Monochrome,
      Foreground (RgbColor),
    }
    
    pub struct DisplayProps {
      pub x: u32,
      pub y: u32,
      pub color: Color,
    }
    ```

    - '데이터를 담을 수 있는 enum' 으로 표현하는 것이 바람직





### 흔히 사용하는 enum 타입

- `Option<T>`

  - 특정 타입의 값이 있을 수도 있고, 없을 수도 있음을 나타냄

  - **값이 없을 수도 있는 경우는 반드시 Option으로 표현**
    - ex) 값이 없을 수 있는 String을 다룰 때, `""`보단 `Option<String>`이 더 명확하게 표현 가능

  - 고려할 점. 컬렉션을 다룰 때, 원소가 없는 경우와 컬렉션이 없는 경우가 같은 의미인지 결정 필요

- `Result<T,E>`

  - 오류 처리에서 흔히 사용

  - **실패할 수 있는 연산 결과는 항상 Result로 인코딩**





### :bulb: TIP

- 러스트의 타입 시스템은 엄격하기 때문에 항상 대상을 명확히 표현해야 한다.

- Rust allows inline comments like this anywhere in the code
  - `print_page(/* both_sides= */ true, /* color= */ false);`





## Item 2. 공통 동작은 타입 시스템으로 표현하라



### 함수와 메서드

- 반환값을 `-> ()`로도 표현할 수 있음
- enum 타입에도 메서드를 정의할 수 있음
  - 메서드 시그니처는 입력과 출력에 대한 타입 정보를 제공

- 메서드는 첫 번째 입력으로 다양한 형태의 self를 받는데, 이를 통해 작업의 성격을 나타냄

  - `&self` 매개변수는 데이터 구조의 내용을 읽을 수는 있지만 수정할 수는 없음

  - `&mut self` 매개변수는 메서드가 데이터 구조의 내용을 수정할 수 있음을 나타냄

  - `self` 매개변수는 메서드가 데이터 구조를 소비함을 나타냄



### 함수 포인터

- 개념
  - 특정 코드(함수)를 가리키는 포인터로서 타입은 함수의 시그니처로 정의
  - 프로그램이 실행될 시점에는 포인터의 크기에 맞는 값만 오게 된다.
- 함수 vs 함수 포인터

  ```rust
  fn sum(x: i32, y: i32) -> 132 {
    x + y
  }
  // ' f n 타입으로 명시적 강제 변환(coercion)해야 한다.
  Let op: fn(i32, i32) -> i32 = Sum;
  ```
  
  - 함수 (`sum`)
    - sum의 타입은 컴파일러 내부에서만 사용하는 타입(`fn(i32, i32) -> i32 {main::sum}`)
    - 최적화를 위해 함수의 시그니처와 위치를 모두 인코딩한다.
      - 함수와 함수 시그니처를 식별하는데 사용
    - 값으로 취급 불가능
  - 함수 포인터 (`op`)
    - 사용자 코드에서 작성할 수 있는 타입
    - 값으로 취급 가능
      - 다른 변수에 `Copy`, 혹은  `==`와 같은 비교 수행 가능

- 한계
  - 매개변수를 통해 명시적으로 지정한 값만 호출된 함수의 입력값으로 전달할 수 있음
  - 외부 상태를 기반으로 수정해야 할 때, 그 상태를 함수 포인터로 전달할 방법이 없음

  ```rust
  // 오류
  let amount_to_add = 3;
  fn add_n(v: U32) -> U32 {
    v + amount_to_add
  }
  ```





### 클로저

- 개념

  - 함수 정의의 본문(람다 표현식)과 같은 코드 블록으로 다음과 같은 차이가 있음

    - 표현식의 일부로 만들 수 있어서 이름을 붙일 필요가 없음

    - 입력 매개변수는 `|param1, param2|`와 같이 파이프로 묶는다 (타입은 대부분 컴파일러 자동으로 추론)

    - 주변 환경을 캡처할 수 있다.

  - 캡처 동작

    1. 컴파일러는 람다 표현식으로 언급하는 환경을 구성하는 모든 부분에 대해 일회용 내부 타입을 생성
       - 개념적인 컨텍스트에 저장된 값은 레퍼런스인 경우가 많음
       - 단, 환경에 있는 것에 대한 가변 레퍼런스이거나, 입력 매개변수 앞에 move 키워드를 사용해 환경에서 이동된 값일 수 있음
    2. 클로저가 생성되는 시점에 앞서 만들어 둔 일회용 타입의 인스턴스를 생성해 환경값을 보관
    3. 클로저가 호출되면 해당 인스턴스를 컨텍스트에 추가해서 사용

- 사용
  - 함수 포인터를 받는 자리에 클로저를 바로 전달할 수는 없음
  - 클로저를 받게 하려면 Fn* 트레이트 인스턴스를 받도록 수정

- Fn* 트레이트

  - 종류

    - `FnOnce`
      - 한 번만 호출할 수 있는 클로저
      - move를 통해 환경의 일부를 콜로저의 컨텍스트로 이동 
    - `FnMut`
      - 여러 번 반복 호출 가능
      - 값들을 가변형으로 대여

    - `Fn`
      - 여러 번 반복 호출
      - 값을 환경에서 불변형으로만 빌려옴

  - 구현
    - 컴파일러는 코드에 나온 람다 표현식을 모두 적절한 Fn* 트레이트로 자동으로 구현
      - `FnOnce` : 이동된 값이 있을 때
      - `FnMut` : 값에 대한 가변 레퍼런스(&mut T)가 있을 때
      - `Fn` : 값에 대한 일반 레퍼런스(&T)가 있을 때
    - 단, Fn* 트레이트를 직접 구현할 수는 없음

  - 특징

    - FnMut와 Fn 트레이트는 각각 FnOnce와 FnMut 트레이트를 트레이트 바운드로 갖음
    - 원시 함수 포인터 타입인 fn 역시 개념상 Fn 트레이트에 해당

    => 결론적으로 클로저를 받는 코드를 작성할 때는 가장 범용적인 Fn* 트레이트를 사용해 호출자의 자유도를 극대화하는 것이 좋음



:triangular_flag_on_post: **원시 함수 포인터(fn)보다는 Fn* 트레이트 바운드를 사용하는 것이 좋다**





### 트레이트

- 개념
  - 트레이트는 내부 항목을 외부에서 사용할 수 있게 공개하는데 관련된 함수들의 집합을 정의 (인터페이스 유사)
    - 단, 사용될 데이터도 함께 제공할 수 있음
  - 대부분 self 또는 그 변형을 첫 번째 인수로 받는 메서드로 정의
  - 객체 지향 스타일로 코드와 데이터를 하나로 캡슐화한 공통 추상화를 제공
    - 유연성이 필요할 것 같으면, **구체적인 타입보다는 트레이트 타입을 받게 만들어라**

- **마커 트레이트**
  - 간혹 어떤 동작을 타입 시스템으로 구분하고 싶은데, 함수 시그니처로는 표현할 수 없는 경우

    ```rust
    pub trait Sort {
      // 내용을 순서에 맞게 정렬한다.
      fn sort(&mut self);
    }
    /// ['Sort ['Sort]가 안정적으로 정렬된다고 알려 주는 마커 트레이트
    pub trait StableSort: Sort 0
    ```
    
    - '내 구현은 안정적으로 정렬됨을 엄숙히 선언'을 의미

  - 불변성을 유지하는 신뢰 관계 형성

    :triangular_flag_on_post: **트레이트 함수 시그니처로 표현할 수 없는 동작은 마커 트레이트로 구분**

- **트레이트 바운드**
  - 타입 T를 매개변수로 받도록 정의한 제네릭 코드에서, 타입 T가 특정한 트레이트를 구현하는 경우에만 받을 수 있게 제한
  - 제네릭이 단형화되는 컴파일 타임에 수행
    - 단형화 : 임의의 타입 T에 대해 처리하도록 정의된 제네릭 코드가 특정한 타입을 처리하도록 변환되는 것
  - 트레이트 바운드가 없으면 모든 타입(T)에 적용되는 연산만 수행할 수 있음 
    - (그렇게 되면 기본 연산 외에는 할 수 있는 것이 많지 않다.)

  ```rust
  pub fn dump_sorted<T>(mut collection: T)
  where
    T: Sort + Intolterator,
    T:: Item: std:: fmt:: Debug,
  {
    // 다음 줄을 위해서는 'T: Sort 라는 트레이트 바운드를 붙여야 한다.
    collection.sort;
    // 다음 줄을 위해서는 'T: IntoIterator°라는 트레이트 바운드를 붙여야 한다.
    for item i n collection {
      // 다음 줄을 위해서는 'T::Item : Debug' 라는 트레이트 바운드를 붙여야 한다.
      printin! ("{:?)", item);
    }
  }
  ```
  
  :triangular_flag_on_post: **제네릭에서 사용하는 타입에 대한 조건은 트레이트 바운드로 표현하라**

- **트레이트 객체**
  - **동적 디스패치**
    - 다양한 트레이트 구현 중에서 하나를 선택하는 시점이 컴파일 타임이 아닌 런타임
    - 동적인 특성 때문에 트레이트 객체를 레퍼런스나 포인터 등으로 간접적으로 처리 (컴파일 시점에는 객체의 크기를 알 수 없기 때문)
  - **객체 안정성**
    - Self와 제네릭 함수를 사용할 없다는 제약 사항을 묶어서 **객체 안정성**이라 부름
      - Self 사용 불가 : Self의 크기를 알지 못해, Self를 반환하거나 수신자 이외에 Self를 사용하는 인수 X (레퍼런스는 O)
      - 제네릭 사용 불가 : 제네릭 포함 시, 컴파일러가 객체를 단일 타입으로 고정할 수 없음
    - 객체 안정성을 만족하는 트레이트만 트레이트 객체로 사용할 수 있음





## Item3. 명시적인 match 표현식보다 Option과 Result 변환을 사용하라



명시적인 match가 바람직하지 않은 첫 번째 경우는 값이 있을 때만 중요하고, 값이 없거나 오류가 발생할 때는 무시해도 되는 경우

Option과 Result 둘 다 내부 값을 추출하되 값이 없으면 panic!을 실행하는 메서도인 unwrap과 expect를 제공

expect를 사용하면 실패한 경우에 출력할 오류 메시지를 별도로 정의

어느 것을 사용해도 코드를 짧게 간결하게 작성 가능



오류를 넘겨 받은 쪽에서 쉽게 처리할 수 있게 만들려면 Option보다는 Result로 표현하는 것이 좋음

두 가지 타입 중 어느 것을 선택할지는 주어진 상황에 맞게 판단해야 하지만, 오류에 유용한 정보를 전달할 수 있다면 가급적 Result를 사용



명시적인 match로 작성하면 오류 전파는 가능하겠지만, Go 언어스러운 보일러플레이트 발생

러스트의 **물음표 연산자(?)**를 사용하면 확 줄어듬

물음표 연산자는 Err 갈래를 표현하는 편의 구문으로, 오류 타입 변환이 필요하다면 수행하고, return Err(...) 표현식을 구성하는 작업을 문자 하나로 표현

`Result`의 경우:

- `Ok(value)`이면 값을 추출하여 사용.
- `Err(error)`이면 현재 함수에서 즉시 반환(`return`)하여 오류를 전달.

`Option`의 경우:

- `Some(value)`이면 값을 추출하여 사용.
- `None`이면 현재 함수에서 즉시 반환.

```rust
pub fn find_user (username: &str) -> Result<UserId, std::io::Error> {
  let f = match std::fs::File::open("/etc/passwd") {
    Ok(f) => f,
    Err(e) => return Err(From::from(e)),
  };
  // ...
}
```



```rust
pub fn find_user(username: &str)-> Result(UserId, std::10::Error> {
	let f= std::fs::File::open("/etc/passwd")?;
}
```





여러 하위 라이브러리부터 반환된 다양한 오류를 처리할 때는 `.map_err()` 변환을 이용하면 좀 더 간결하고 관용적으로 표현 O

더 좋은 방법은 아예 이렇게 할 일이 없도록, 표준 트레이트인 `From` 구현을 이용해 내부 오류 타입에서 외부 오류 타입을 생성

그림 1-1 45p



as_ref() 메서드. Option에 대한 레퍼런스를 레퍼런스에 대한 Option으로 변환

오류 케이스. Option에 대한 레퍼런스

```rust
// payload : Option<Vec<u8>> 타입인 self에 대한 필드
pub fn encrypted(&self) -> Vec<u8> {
	encrypt(&self.payload.unwrap_or (vec! []))
}
```

정상 케이스. 레퍼런스에 대한 Option

```rust
pub fn encrypted(&self) - Vec<u8> {
	encrypt(self.payload.as_ref).unwrap_or(&vec! [)))
}
```





기억할 사항

- Option과 Result 변환을 익히고, 가급적 Option보다는 Result를 사용하라. 레퍼런스 관련 변환이 필요하다면, `.as_ref()`를 사용하라
- Option과 Result에 대해 명시적인 match 연산보다는 Option과 Result 변환을 사용하라
- 특히 이러한 변환을 사용해 결과 타입을 물음표 연산자를 적용할 수 있는 형태로 바꿔라



























