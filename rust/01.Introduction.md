# Introduction



## ì†Œê°œ



### ë¶„ë¥˜

- systems programming language

:bulb: íŠ¹ì§• : able to reach low-level stuff, getting close to the real hardware world



### ê°•ì 

- safety

- concurrency

- speed



## Fundamentals



### cargo

- ì—­í• 
  - pacakge manager
  - build system
  - test runner
  - docs generator
- ëª…ë ì–´
  - `cargo new hello`
    - `hello` ë¼ëŠ” package ìƒì„±
    - ìƒì„± íŒŒì¼
      - `Cargo.toml` : config file
      - `main.rs` : rust source file
  - `cargo run`
    - í”„ë¡œì íŠ¸ ì‹¤í–‰



### Cargo.toml

- name : í”„ë¡œì íŠ¸ ì´ë¦„
- version
  - sementic versioning(.ìœ¼ë¡œ êµ¬ë¶„ëœ 3ìë¦¬ ìˆ˜)ë¡œ ë²„ì „ í‘œê¸°
- authors
  - ì£¼ë¡œ ì—°ê²°ëœ gitìœ¼ë¡œ ìë™ ìƒì„±
- edition



### Cargo Run

- ì§„í–‰ ë‹¨ê³„
  - Compiling
    - ì½”ë“œ ë³€ê²½ X ì¬ì‹¤í–‰ => ìƒëµ
  - Finished
  - Running
- Debug ëª¨ë“œ
  - defaultë¡œ ì‹¤í–‰
-  Release ëª¨ë“œ
  - Debugë³´ë‹¤ ë¹ ë¥¸ Run íƒ€ì„ but, ëŠë¦° Compile
  - `cargo run --release`



### Variables

- íŠ¹ì§•

  - Strongly Typed Language

  - Default Immutable
    - Safety
    - Concurrency
    - Speed

- ê¸°ë³¸ ì„ ì–¸

    ```rust
    let var = 2;
    ```

    - let : declare

- Type ì§€ì •

    ```rust
    let var: i32 = 4;
    ```

- ë‹¤ì¤‘ ë³€ìˆ˜ ì„ ì–¸

    ```rust
    let (var1, var2) = (8,50);
    ```

- Mutable ì„ ì–¸

    ```rust
    let mut var = 32;
    var - 2;
    ```

- Const ì„ ì–¸

    ```rust
    const CONST_VAR: f64 = 9.9;
    ```

    - ì„ ì–¸ ë°©ë²•
      - `const`ë¡œ ì„ ì–¸
      - ë³€ìˆ˜ëª… : Screaming snake caseë¡œ ì„ ì–¸
      - ë³€ìˆ˜ íƒ€ì… í•„ìˆ˜
      - ê°’ì€ constant expression
        - compile ì‹œ, ì•Œ ìˆ˜ ìˆëŠ” ê°’
    - ì‚¬ìš© ì´ì 
      - Function Outsideì—ì„œ ì„ ì–¸ë˜ì—ˆì–´ë„, ì–´ë””ì„œë“  ì‚¬ìš© O
      - compile ì‹œ ì„ ì–¸ => REALLY FAST




### Scope

- No Garbage Collector => Block ì¢…ë£Œ ì‹œ, Block ë‚´ ì„ ì–¸ëœ ëª¨ë“  ë³€ìˆ˜ ì‚­ì œ

- Shadowed

  1. ì™¸ë¶€ ë¸”ë¡ ë³€ìˆ˜ì— ëŒ€í•œ Shadow

     - ì™¸ë¶€ ë¸”ë¡ì˜ ë³€ìˆ˜ì™€ ê°™ì€ ì´ë¦„ìœ¼ë¡œ ë‚´ë¶€ì—ì„œ ì„ ì–¸ ì‹œ, ë¸”ë¡ ë‚´ ë³€ìˆ˜ ì‚¬ìš©

     - Variable is always local to the scope

  2. ê°™ì€ ë¸”ë¡ ë‚´ ë³€ìˆ˜ì— ëŒ€í•œ Shadow

     - ê°™ì€ ë¸”ë¡ ë‚´ì—ì„œë„ ì„ ì–¸ëœ ë³€ìˆ˜ì— ëŒ€í•´ì„œ ì¬ì„ ì–¸ ê°€ëŠ¥

     ```rust
     let mut x = 5;
     let x = x; // now immutable
     ```

     - ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ ì¬ì„ ì–¸

     ```rust
     let var = "Sample String";
     let var = make_different(var);
     ```

     :bulb: Data Transform í›„ ì´ì „ ë³€ìˆ˜ ì œê±° ëª©ì ìœ¼ë¡œ ìì£¼ ì‚¬ìš©



### Memory Safety

- Complie ì‹œ, í™•ì¸

- ëª¨ë“  ë³€ìˆ˜ë“¤ì€ ì‚¬ìš©ì „ Initialize ë˜ì–´ì•¼ í•¨



### Functions

```rust
fn do_stuff(param1: f64, param2: f64) -> f64{
    return param1 * param2; // param1 * param2
}
```

- ì„ ì–¸
  - `fn` í‚¤ì›Œë“œ
- naming convention
  - snake_case
- ì¸ì ê°’
  - `íŒŒë¼ë¯¸í„°: íƒ€ì…` 
  - ë‹¤ì¤‘ ì¸ì ì‹œ, `,`ë¡œ êµ¬ë¶„
- Return íƒ€ì…
  - `-> íƒ€ì…`
- `return` ë° `;` ìƒëµ ê°€ëŠ¥
  - `{return true;}` = `{true}` 

:bulb: í˜¸ì¶œ ì‹œ ì¸ìëª…ìœ¼ë¡œ ì§€ì • X => ì„ ì–¸ëœ ì •í™•í•œ ìˆœì„œëŒ€ë¡œ ì¸ì ì…ë ¥



### Module System

- ìì²´ Library ì¶”ê°€

  - project root/src/`lib.rs` ìƒì„±

  - Library ë‚´ ëª¨ë“  í•­ëª©ì€ Default ê°’ìœ¼ë¡œ Private

    - `pub` : public 

    ```rust
    pub fn greet(){
    	println!("Hi!");
    }
    ```

- ëª¨ë“ˆ ì‚¬ìš©

  - Absolute Pathë¡œ Libraryì˜ í•¨ìˆ˜ ì‚¬ìš© O
    - Absolute Path = Library Name = Name of project In Cargo.toml

      ```rust
      fn main(){
          hello::greet();
      }
      ```

  - `use` í‚¤ì›Œë“œë¡œ ëª¨ë“ˆ Import ì‹œ, Absolute Path ìƒëµ O

      ```rust
      use hello::great;
      
      fn main(){
          greet();
      }
      ```

      - `ëª¨ë“ˆ::*` ì‹œ, ëª¨ë“  ë©”ì†Œë“œ ì‚¬ìš© O

  - Rust Standard Library : `std`
  
    - Rust ìì²´ ì œê³µ ê¸°ë³¸ Library
    - ex) `use std::collections::HashMap;`
    - í•´ë‹¹ Library ê´€ë ¨ ì •ë³´ëŠ” êµ¬ê¸€ì— `rust std ì°¾ëŠ” ì´ë¦„` ê²€ìƒ‰
  
  - Rust Package Registry : `crates.io`
  
    - standardì—ì„œ ë¯¸ì œê³µí•˜ëŠ” Library ë“±ë¡ëœ ì‚¬ì´íŠ¸
  
    - `Cargo.toml`ì— dependency ì¶”ê°€
  
      - `íŒ¨í‚¤ì§€ ì´ë¦„ = "ë²„ì „"`
  
      - ex) `rand = "0.6.5"`



## Primitive Types & Control Flow



### Scalar Types

- Integer Types

  | Unsigned(ë¶€í˜¸ ì—†ëŠ”) | Signed (ë¶€í˜¸ìˆëŠ”) |
  | :-----------------: | :---------------: |
  |         u8          |        i8         |
  |         u16         |        i16        |
  |         u32         |   i32 (default)   |
  |         u64         |        i64        |
  |        u128         |       i128        |
  |        usize        |       isize       |

  - u/i size

    - ë©”ëª¨ë¦¬ í¬ê¸°ì™€ ì—°ê´€ë  ë•Œ ì‚¬ìš©
      - ê°ì²´ì˜ í¬ê¸°, ë²¡í„°ì˜ ì¸ë±ì‹± ë“±
    - 32bit í™˜ê²½ => 4byte / 64bit í™˜ê²½ => 8byte

  - ì§„ë²•

    |     ì§„ë²•      |  í‘œê¸°   |
    | :-----------: | :-----: |
    |    Decimal    | 1000000 |
    |      Hex      |  0x~~   |
    |     Octal     |  0o~~   |
    |    Binary     |  0b~~   |
    | Byte(u8 only) |  b'A'   |

  - íŠ¹ì§•

    - ì¤‘ê°„ _ ë„£ì–´ë„ ë¬´ì‹œë¨

- Float

  - f32
  - f64 (default)
    - 64bit ë¯¸ë§Œ í™˜ê²½ì—ì„œëŠ” ë§ì´ ëŠë ¤ì§

- Floating Point Literals

  - statndard :IEEE-754
  - suffixëŠ” í•„ìš” ì—†ì§€ë§Œ, `.` ì•ì— ìˆ«ì í•„ìš”

:bulb: Numerical NumbersëŠ” suffixë¡œ íƒ€ì… ëª…ì‹œ O. 

- ë‹¤ìŒ ë‘ ì‹ ì¤‘ ì„ íƒ O
  - `let x: u16 = 5;`  
  - `let x = 5u16;` or `let x = 5_u16;`

- Boolean

  - type ëª…ì‹œ : `bool`
  - ê°’ : `true`, `false`

- Character

  - type ëª…ì‹œ ì´ë¦„ x

    - `' '`ìœ¼ë¡œ initiate

  - í¬ê¸°

    - 4 bytes (32 bits)

      => make array of characters `USC-4` or `UTF-32` string

      => Stringì€ ê±°ì˜ `utf-8` ì´ê¸° ë•Œë¬¸ì—, character íƒ€ì… ì“¸ ì¼ ê±°ì˜ X



### Compound Types

- ì—¬ëŸ¬ íƒ€ì…ì˜ ê°’ë“¤ì„ í•˜ë‚˜ì˜ íƒ€ì…ìœ¼ë¡œ ëª¨ì„
- Tuple
  - stores multiple values of any type
  - ì„ ì–¸
    - `let info = (1, 3.3, 999);`
    - `let info: (u8, f64, i32) = (1, 3.3, 999);`
  - ê°’ ì ‘ê·¼
    - dot syntax
      - `let var1 = info.0;`
    - destructure
      - `let (var1, var2, var3) = info;`
  - ìµœëŒ€ í¬ê¸°
    - `12` ë¥¼ ë„˜ì–´ê°€ë©´, ì‚¬ìš©ì€ ê°€ëŠ¥í•˜ì§€ë§Œ ì œí•œëœ ê¸°ëŠ¥ ì‚¬ìš©
- array

  - stores multiple values of same type
  - ì„ ì–¸
    - `let arr = [1,2,3];`
    - `let arr = [0;3];` 
      - ê°’;ê°œìˆ˜
    - `let arr: [f32;2] = [0.0;2];`
  - ì ‘ê·¼
    - `let var1 = arr[0];`
  - ìµœëŒ€ í¬ê¸°
    - `32` ë¥¼ ë„˜ì–´ê°€ë©´, ì‚¬ìš©ì€ ê°€ëŠ¥í•˜ì§€ë§Œ ì œí•œëœ ê¸°ëŠ¥ ì‚¬ìš©
- Vec



### Control Flow

- ì¡°ê±´ë¬¸

  - ifë¬¸ ì‚¬ìš©ì‹œ `( )` í•„ìš” X. `if`ì™€ `{}` ì‚¬ì´ê°€ ì¡°ê±´ì‹
  - ì¡°ê±´ì‹ì—ëŠ” `boolean` íƒ€ì…ë§Œ í—ˆìš© (type coercion X)
  - ifë¬¸ì€ `expression` ì·¨ê¸‰ (statement X)

      ```rust
      msg = if num == 5 {
          "five"
      } else if num == 4 {
          "four"
      } else {
          "other"
      };
      ```

      1. `;` ìƒëµìœ¼ë¡œ return í‘œí˜„
      2. return ì‚¬ìš© ë¶ˆê°€
         - returnì€ function bodyì—ë§Œ ì‚¬ìš©ë˜ê¸°ì— ì‚¬ìš© ì‹œ í˜„ì¬ functionì—ì„œ return out
      3. ëª¨ë“  blockì€ ê°™ì€ type return
      4. ë§ˆì§€ë§‰ì— `;`
        - ifë¬¸ì˜ ê°’ì„ ì‚¬ìš©í•  ê²½ìš°ì—ë§Œ `;` í•„ìš”
     
     :bulb: expression : í‰ê°€ê°€ ê°€ëŠ¥í•˜ì—¬ í•˜ë‚˜ì˜ ê°’ìœ¼ë¡œ í™˜ì› O 
     
     :bulb: statement : ì‹¤í–‰ ê°€ëŠ¥í•œ ìµœì†Œì˜ ë…ë¦½ì ì¸ ì½”ë“œ ì¡°ê°.  expression < statement
     
  - `{ }` ëŠ” í•„ìˆ˜
  
  - ì‚¼í•­ ì—°ì‚°ì ì—†ìŒ


- unconditional loop

  ```rust
  loop {
      loop {
          break;
      }
  }
  ```

  - íŠ¹ì • loop ì§€ì •ìœ¼ë¡œ `break` ë˜ëŠ” `continue` í•  loopë„ ì„ íƒ O

  ```rust
  'bob: loop {
      loop {
          break 'bob;
      }
  }
  ```

- conditional loop

  ```rust
  while ì¡°ê±´ {
      
  }
  ```

- for loop

  - iterate : `.iter()`
  	  ```rust
      for num in [7,8,9].iter() {
  	  
      }
      ```

    - collectionì´ orderedë¼ë©´ ìˆœì„œëŒ€ë¡œ, ì•„ë‹ ì‹œ ëœë¤

  - destructure ê°€ëŠ¥

    ```rust
    let array = [(1,2), (3,4)];
    for (x,y) in array.iter(){
        // do sth
    }
    ```

  - range : `..`

    ```rust
    for num in 0..50{
        // 0 ~ 49
    }
    ```

    - = ëª…ì‹œì‹œ, inclusive
      - `0..=50` 



### String

- at least 6 types in standard library, but 2 are most used
- str
  - called as string slice. In most case, called as borrowed string slice
  - ë¹„êµ (vs String)
    - cannot be modified`&str`
  - String typeìœ¼ë¡œ ë³€í™˜
    - `strë³€ìˆ˜.to_string()` ë©”ì†Œë“œ
    - `String::from(strë³€ìˆ˜)`
  - êµ¬ì¡°
    - ptr (pointer)
    - len

- String

  - can be modified

  - êµ¬ì¡°

    - ptr
    - len
    - capacity

    :bulb: strì€ Stringì˜ subsetêµ¬ì¡°

- ê³µí†µì 

  - Valid UTF-8
  - can not be indexed by character position (like `my_string[3]`)
    - ì„œë¡œ ë‹¤ë¥¸ ì–¸ì–´ì—ì„œ ê³µí†µì ìœ¼ë¡œ indexing í•˜ëŠ” ê²ƒì´ ë¶ˆê°€ëŠ¥
      - grapheme(ìì†Œ)ì˜ ì¡´ì¬ ì •í™•í•˜ê²Œ byteë¡œ ë‚˜ëˆ„ê¸° X

- ì¸ë±ì‹±

  - `~.bytes()` 

    - Stringì„ byte arrayë¡œ ì „í™˜
    - ASC2 ì¸ ì˜ì–´ë¼ë©´ ì‚¬ìš©ì„± O

  - `~.chars()`

    - Unicode scalars iterate

  - package : `unicode-segmentation`

    - `graphemes(ë¬¸ìì—´, true)`
      - return iterators that handle graphemes of various types

    :bulb: ì¸ë±ì‹±ë§Œ ê°€ëŠ¥í•˜ë‹¤ë©´, fase, constant-time operation O

  - iterator method : `.nth(ìˆ«ì)`
    - Stringì˜ index ëŒ€ì‹  ì‚¬ìš©





## Ownership



### Ownership

- ì˜ë¯¸ìˆëŠ” ì»´íŒŒì¼ ì—ëŸ¬ ë©”ì‹œì§€ ìƒì„±
- 3 Rules
  1. Each value has an owner
  2. Only one owner
  3. Value gets dropped if its owner goes out of scope

- ë™ì‘

  ```rust
  let s1 = String::from("abc");
  let s2 = s1;
  ```

  1. `Stack`ì— s1ì— ëŒ€í•œ ptr, len, capacitryê°€ ì €ì¥ë˜ë©°, ptrì€ Heapì— ì €ì¥ëœ abc ê°€ë¥´í‚´

  2. `Stack`ì— s2ì— ëŒ€í•œ ptr, len, capacitryê°€ ì €ì¥ë˜ë©°, ptrì€ Heapì— ì €ì¥ëœ abc ê°€ë¥´í‚´

  3. s1ì˜ Heap valueì— ëŒ€í•œ ì—°ê²° í•´ì œ ì‹œí‚´. Stackì—ëŠ” s1 ê·¸ëŒ€ë¡œ ì¡´ì¬ but ì‚¬ìš© X

     :bulb: shallow copy X. move O

  - Deep Copy

    ```rust
    let s1 = String::from("abc");
    let s2 = s1.clone();
    ```

```rust
let s1 = String::from("abc");
do_stuff(s1);


fn do_stuff(s: String) {
    
}
```

- s1 ê³„ì† ì‚¬ìš© ë°©ë²•

  1. make s1 mutable

     ```rust
     let mut s1 = String::from("abc");
     s1 = do_stuff(s1);
     
     fn do_stuff(s: String) -> String {
         // ... 
     }
     ```

     - ë³´í†µì˜ ê²½ìš° ì‚¬ìš© X

  2. **Reference & Borrowing**

:bulb: Stack vs heap

| Stack     | Heap          |
| --------- | ------------- |
| In order  | Unordered     |
| Fixed-siz | Variable-size |
| LIFO      | Unordered     |
| Fast      | Slow          |



### Reference & Borrowing

```rust
let s1 = String::from("abc");
do_stuff(&s1);
println!("{}",s1);


fn do_stuff(s: &String) {
    
}
```

- ë™ì‘
  - valueê°€ ì•„ë‹Œ referenceê°€ do_stuffë¡œ moved/ dropped => s1ì— ëŒ€í•´ì„œ ê³„ì† ì‚¬ìš©  O

- Lifetimes
  - Rustê°€ pointerì„ ìë™ìœ¼ë¡œ ê´€ë¦¬í•´ì£¼ëŠ” ê°œë…
  - rule : `references must always be valid`
    - valid í•˜ì§€ ì•Šì€ reference ì‚¬ìš© X
    - null ê°’ point X



### Mutable Reference

- referenceëŠ” ê¸°ë³¸ì ìœ¼ë¡œ immutable

- muttable ì„¤ì •

  ```rust
  let mut s1 = String::from("abc");
  do_stuff(&mut s1);
  println!("{}",s1);
  
  
  fn do_stuff(s: &mut String) {
      s.insert_str(0, "Hi, ");
      *s = String::from("Replacement");
  }
  ```

  - muttable valueì— ëŒ€í•œ muttable reference ì„¤ì •

  - `.`operator for a method or a field auto-dereferences down to the actual value

    => `.` operator ì‚¬ìš© ì‹œ, í•´ë‹¹ ê°’ì´ value, reference, reference of reference ì¸ì§€ ì‹ ê²½ ì“¸ í•„ìš” X

    :bulb: manually dereference : `(*s).insert_str(0, "Hi, ");`

- Rule

  - ë‹¤ìŒ ë‘˜ ì¤‘ í•œê°€ì§€ë§Œ ê°€ëŠ¥

    1. Exactly one mutable reference

    2. Any number of immutable references

       => multy thread í™˜ê²½ì—ì„œë„ ì ìš©



## ìë£Œêµ¬ì¡°



### Structs

- êµ¬ì„±

  - data fields
  - methods
  - associated functions

- ì˜ˆì‹œ

  ```rust
  struct RedFox {
      enemy: bool,
      life: u8,
  }
  ```

  :bulb: ë§ˆì§€ë§‰ fieldì—ë„ , ë¶€ì°© ê°€ëŠ¥

- Implementation

  ```rust
  impl RedFox {
      fn new() -> Self {
          Self {
              enemy: true,
              life: 70,
          }
      }
  }
  ```

  - associated functionì„ constructor ì²˜ëŸ¼ í™œìš©
  - parameterë¡œ form of selfê°€ ë“¤ì–´ê°€ì§€ ì•ŠëŠ” ë©”ì†Œë“œê°€ `associated functions` = class method
  - `Self`ëŠ” implementation block ì•ˆì—ì„œ Struct ì´ë¦„ ëŒ€ì‹ í•˜ì—¬ ì‚¬ìš© O

- ìƒì„±

  ```rust
  let fox = RedFox::new();
  ```

  - `::` Structì˜ associate function ì ‘ê·¼

- í•„ë“œ ì ‘ê·¼

  - `.` syntaxë¡œ  get / set ê°€ëŠ¥

  ``` rust
  let liff_left = fox.life;
  fox.enemy = false;
  ```

- methods

  ```rust
  imple RedFox {
      fn move(self) ...
      fn borrow(&self) ... 
  }
  ```

  - Method always take some form of self as their `first argument`



### Traits

- similar with interface

- Rust takes composition over inheritance approach

- defines required behavior

  ```rust
  trait Noisy {
      fn get_noise(&self) -> &str;
  }
  
  impl Noisy for RedFox {
      fn get_noise(&self) -> &str {"Meow?"}
  }
  ```

- can start writing `generic functions` that accpet any value that implements the traits

  ```rust
  fn print_noise<T: Noisy>(item: T){
      println!("{}", item.get_noise());
  }
  
  fn main() {
      print_noise(fox)
  }
  ```

  - can implement your triats on any types from anywhere including built-in types

  ```rust
  impl Noisy for u8 {
      fn get_noise(&self) -> &str {"BYTE!"}
  }
  
  fn main() {
      print_noise(5_u8); // prints "BYTE!"
  }
  ```

- Define default behavior

  ```rust
  trait Run {
     fn run(&self) {
         println!("I'm running!");
      } 
  }
  
  struct Robot{}
  impl Run for Robot{}
  ```

  - don't need to provide a new definition for the method

- can't define fields as part of traits



### Copy

- special trait
- if implements Copy, it will be copied instead of moved in move situations



### Collections

- `Vec<T>`

  - holds a bunch of one type
  - ì„ ì–¸

      ```rust
      let mut v: Vec<i32> = Vec::new();
      ```

  - ë©”ì†Œë“œ

    ````rust
    v.push(2);
    v.push(4);
    v.push(6);
    let x = v.pop(); // x is 6
    println!("{}", v[1]); // print "4"
    ````

    - `push`
      - appends  things to the end
    - `pop()`
      - removes the item at the end and returns it
    - ë“±ë“± ë‹¤ ìˆìŒ

  - macro

    ```rust
    let mut v = vec![2,4,6];
    ```

    - create vectors from literal values much more ergonomic

- `HashMap<K, V>`

  - ìƒì„±

    ```rust
    let mut h: HashMap<u8, bool> = HashMap::new();
    ```

  - ë©”ì†Œë“œ

    ```rust
    h.insert(5, true);
    h.insert(6, false);
    let have_five = h.remove(&5).unwrap();
    ```

    - also have methods for getting references to values and iterating through keys, values, or (keys, values), 

- ê¸°íƒ€ collection

  - `VecDeque`
    - uses a ring buffer => implement a double-ended queue

  - `LinkedList`
  - `HashSet`
  - `BinaryHeap`
    - priority queue

  - `BTreemap`
  - `BTreeSet`
    - needed when map keys or set values to always be sorted



### Enums

- ë¹„êµ

  - more like algebraic Data Types in Haskell > enums in C
  - simliar with a union in C

  ```rust
  enum Color {
      Red,
      Green,
      Blue,
  }
  ```

  - Enum nameì€ camel-case

  ```rust
  let color = Color:;Red;
  ```

- ê°•ì 

  - Associating data and methods with the variants

    ```rust
    enum DispenserItem {
        Empty, // variant with no data
        Ammo(u8), // variant with single type of data
        Things(String, i32), // variant with tuple
        Place {x: i32, y:i32} // variant with anonymous struct of data
    }
    ```

  - can be any one of those, but only one at a time


  ```rust
  use DispenserItem::*;
  let item1 = Empty;
  let item2 = Ammo(69);
  ```

  - implement functions and methods for an enum

    ```rust
    impl DispenserItem{
        fn display(&self) {      
        }
    }
    ```

  - use enums with generics

    - `Option` is a generic enum in the std library

    ```rust
    enum Option<T> {
        Some(T),
        None,
    }
    ```

    - `Option` enum represents when sth is either absent or present
    - `NULL` ì‚¬ìš©í•˜ê³  ì‹¶ì„ ë•Œ, Option ì‚¬ìš©

- patterns to examine variants in Enum

    - `if let`

        - check single variant

        ```rust
        if let Some(x) = my_variable {
            println!("value is {}", x);
        }
        ```

        - pattern matches => conditon is true => variabls inside the pattern are created

    - `match`

        - check multi variants

        ```rust
        match my_variable {
            Some(x) => {
                println!("value is {}", x);
            },
            
            None => {
                println!("no value");
            },
            
            _ => {
                println!("defualt");
            }
        }
        ```

        - write a branch arm for every possible outcome
          - = match expression must be exhaustive
        - `single unscore` : matches anything => used for defualt / anything-else branch
        - ëª¨ë“  branch armì€ `ê°™ì€ íƒ€ì… return` or `return ê°’ X` ì´ì–´ì•¼ í•¨




### Option

- Initiate

  ```rust
  let mut x: Option<i32> = None;
  ```

- íŠ¹ì§•

  - Once you use Option with concrete type, compiler infer the type.

    => leave the type annotation off

    ```rust
    let mut x = None;
    x = Some(5);
    ```

- method

  - `is_some()`

    ```rust
    x.is_some(); // true
    ```

  - `is_none()`

    ```rust
    x.is_none(); // false
    ```

- implements Iterator trait

  ```rust
  for i in x {
      println!("{}", i); 
  }
  ```

  

### Result

- ì‚¬ìš©

  - whenever sth might have a useful result or might have an error
  - Functions return `Result` whenever errors are expected and recoverable.
  - io module ì‚¬ìš©ì‹œ, ìì£¼ ì‚¬ìš©

- Definition

  ```rust
  #[must_use]
  enum Result<T, E> {
      Ok(T),
      Err(E),
  }
  ```

  - `type wrapped by Ok`, and `the type wrapped by Err` are both generic but independent of each other

  - `#[must_use]` annotation makes it a compiler warning to silently drop a result

    => Rust strongly encourages you to look at all possible erros and make a conscious choise what to do with each one

- method
  - `is_ok()`
  - `is_err()`

- ì˜ˆì‹œ

  ```rust
  use std::fs::File;
  
  fn main() {
      let res = File::open("foo");
      let f = res.unwrap();	// If Result is Ok, give you File struct. If Err, crashes the program
  }
  ```

  ```rust
  use std::fs::File;
  
  fn main() {
      let res = File::open("foo");
      let f = res.expect("error message"); // unwrapê³¼ ê°™ì€ ë™ì‘. crash ì¼ ë•Œ, error message í‘œì‹œ
  }
  ```

  ```rust
  use std::fs::File;
  
  fn main() {
      let res = File::open("foo");
      if res.is_ok() {
          let f = res.unwrap();
      }
  }
  ```




### Closures

- when you spawn a thread, or when you want to do functional programming

- ì •ì˜

  - anonymous functions that can borrow or capture some data from the scope it is nested in

- systax

  ```rust
  // with paraemeter
  |x, y| {x+y}
  
  // no parameter
  || {x+y}
  
  // ê·¹ë‹¨ì ìœ¼ë¡œ parameterì™€ return ë‘˜ë‹¤ ì—†ì´ë„ ê°€ëŠ¥
  || {}
  ```

  - types or arguments and the return value are all inferred from how you use the arguments and what you return

- Borrow Reference

  ```rust
  let s = "sample".to_string();
  let f = || {
      println!("{}", s);
  };
  f(); // print "sample"
  ```

  - closureê°€ ì°¸ì¡°í•˜ëŠ” ë³€ìˆ˜ ë³´ë‹¤ ì˜¤ë˜ ì‚´ì§€ ì•ŠëŠ” ì´ìƒ, ê³„ì† ì°¸ì¡° ê°€ëŠ¥
    - ì°¸ì¡° ë³€ìˆ˜ê°€ closureë³´ë‹¤ ì˜¤ë˜ ì§€ì†ë¨ì´ ë³´ì¥ë˜ì§€ ì•Šìœ¼ë©´ compile X
  - ë‹¤ë¥¸ Threadë¡œ ë³´ë‚´ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥
    - í˜„ì¬ Threadê°€ í•´ë‹¹ Thread ë³´ë‹¤ ì¼ì° ì¢…ë£Œë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ì»´íŒŒì¼ëŸ¬ê°€ ë§‰ìŒ

- Move Semantics

  ```rust
  let s = "sample".to_string();
  let s2 = s.clone();
  let f = move || {
      println!("{}", s2);
  };
  f(); // print "sample"
  ```

  - can force the closure to move any variables it uses into itself and take ownership of them

    => closureì™€ í•´ë‹¹ ë³€ìˆ˜ì˜ ìˆ˜ëª…ì´ ê°™ì•„ì§

    => ë‹¤ë¥¸ Threadë¡œ ë³´ë‚´ëŠ” ê²ƒì´ ê°€ëŠ¥í•´ì§

  - `clone()`ì„ í†µí•´ì„œ, ë³µì œí’ˆì„ closureì— ë³´ë‚¼ ìˆ˜ ìˆìŒ

- Functional Programming

  ```rust
  let mut v = vec![2,4,6];
  
  v.iter()	// javaì˜ stream
  	.map(|&x| x*3)
  	.filter(|x| *x > 10)
  	.fold(0, |acc,x| acc+x); // javaì˜ reduce
  ```

  :bulb: The argument passed to the closure will be reference

- pass closures to or from functions

  - need traits of `std::ops`
    - Fn
    - FnMut
    - FnOnce


  

### Threads

```rust
use std::thread;

fn main() {
    let thread1 = thread::spawn(move || {
        
    })
    
    thread1.join().unwrap();
}
```

- `thread::spawn` : thread ìƒì„±
- `move || {}` : threadì˜ ë©”ì¸ ë™ì‘ ë¶€ë¶„
- `join` : pause the thread until the thread has completed and exited

:bulb: ThreadëŠ” ë¹„ì‹¼ ì‘ì—…. ë…ë¦½ì ì¸ ë©”ëª¨ë¦¬ í• ë‹¹ ë° ì „í™˜ ì‹œì—ëŠ” ë¹„ì‹¼ context ì „í™˜ì„ í•´ì•¼í•¨








## Code Practice



### Varaibles

```rust
const STARTING_MISSILES: i32 = 8;
const READY_AMOUNT: i32 = 2;

fn main() {
    
    let (mut missiles, ready)  = (STARTING_MISSILES, READY_AMOUNT);
    // let ready = READY_AMOUNT;

    println!("Firing {} of my {} missiles...", ready, missiles);

    missiles = missiles - ready;
    println!("{} missiles left", missiles);
   
}
```



### Functions

```rust
// Silence some warnings so they don't distract from the exercise.
#![allow(unused_variables)]

fn main() {
    let width = 4;
    let height = 7;
    let depth = 10;
    // 1. Try running this code with `cargo run` and take a look at the error.
    //
    // See if you can fix the error. It is right around here, somewhere.  If you succeed, then
    // doing `cargo run` should succeed and print something out.
    
    let area = area_of(width, height);
    
    println!("Area is {}", area);

    // 2. The area that was calculated is not correct! Go fix the area_of() function below, then run
    //    the code again and make sure it worked (you should get an area of 28).

    // 3. Uncomment the line below.  It doesn't work yet because the `volume` function doesn't exist.
    //    Create the `volume` function!  It should:
    //    - Take three arguments of type i32
    //    - Multiply the three arguments together
    //    - Return the result (which should be 280 when you run the program).
    //
    // If you get stuck, remember that this is *very* similar to what `area_of` does.
    //
    println!("Volume is {}", volume(width, height, depth));
}

fn area_of(x: i32, y: i32) -> i32 {
    // 2a. Fix this function to correctly compute the area of a rectangle given
    // dimensions x and y by multiplying x and y and returning the result.
    //
    x*y
    // Challenge: It isn't idiomatic (the normal way a Rust programmer would do things) to use
    //            `return` on the last line of a function. Change the last line to be a
    //            "tail expression" that returns a value without using `return`.
    //            Hint: `cargo clippy` will warn you about this exact thing.
}

fn volume(width: i32, height: i32, depth: i32) -> i32{
    width*height*depth
}
```



### Types

- main.rs

```rust
// Silence some warnings so they don't distract from the exercise.
#![allow(dead_code, unused_variables)]
use ding_machine::*;

fn main() {
    let coords: (f32, f32) = (6.3, 15.0);
    // 1. Pass parts of `coords` to the `print_difference` function. This should show the difference
    // between the two numbers in coords when you do `cargo run`.  Use tuple indexing.
    //
    // The `print_difference` function is defined below the `main` function. It may help if you look
    // at how it is defined.
    //
    let (x, y) = coords;
    print_difference( x, y );   // Uncomment and finish this line


    // 2. We want to use the `print_array` function to print coords...but coords isn't an array!
    // Create an array of type [f32; 2] and initialize it to contain the
    // information from coords.  Uncomment the print_array line and run the code.
    //
    let coords_arr: [f32;2] = [0.0;2];               // create an array literal out of parts of `coord` here
    print_array(coords_arr);        // and pass it in here (this line doesn't need to change)


    let series = [1, 1, 2, 3, 5, 8, 13];
    // 3. Make the `ding` function happy by passing it the value 13 out of the `series` array.
    // Use array indexing.  Done correctly, `cargo run` will produce the additional output
    // "Ding, you found 13!"
    //
    ding(series[6]);


    let mess = ([3, 2], 3.14, [(false, -3), (true, -100)], 5, "candy");
    // 4. Pass the `on_off` function the value `true` from the variable `mess`.  Done correctly,
    // `cargo run` will produce the additional output "Lights are on!" I'll get you started:
    //
    on_off(mess.2[1].0);

    // 5.  What a mess -- functions in a binary! Let's get organized!
    //
    // - Make a library file (src/lib.rs)
    // - Move all the functions (except main) into the library
    // - Make all the functions public with `pub`
    // - Bring all the functions into scope using use statements. Remember, the name of the library
    //   is defined in Cargo.toml.  You'll need to know that to `use` it.
    //
    // `cargo run` should produce the same output, only now the code is more organized. ğŸ‰

    // Challenge: Uncomment the line below, run the code, and examine the
    // output. Then go refactor the print_distance() function according to the
    // instructions in the comments inside that function.

    print_distance(coords);
}

```

- lib.rs

```rust
pub fn print_difference(x: f32, y: f32) {
    println!("Difference between {} and {} is {}", x, y, (x - y).abs());
}

pub fn print_array(a: [f32; 2]) {
    println!("The coordinates are ({}, {})", a[0], a[1]);
}

pub fn ding(x: i32) {
    if x == 13 {
        println!("Ding, you found 13!");
    }
}

pub fn on_off(val: bool) {
    if val {
        println!("Lights are on!");
    }
}

pub fn print_distance((x,y): (f32, f32)) {
    // Using z.0 and z.1 is not nearly as nice as using x and y.  Lucky for
    // us, Rust supports destructuring function arguments.  Try replacing "z" in
    // the parameter list above with "(x, y)" and then adjust the function
    // body to use x and y.
    println!(
        "Distance to the origin is {}",
        ( x.powf(2.0) + y.powf(2.0) ).sqrt());
}
```



### Control Flow

```rust
// Silence some warnings so they don't distract from the exercise.
#![allow(dead_code, unused_mut, unused_variables)]

fn main() {
    // This collects any command-line arguments into a vector of Strings.
    // For example:
    //
    //     cargo run apple banana
    //
    // ...produces the equivalent of
    //
    //     vec!["apple".to_string(), "banana".to_string()]
    let args: Vec<String> = std::env::args().skip(1).collect();

    // This consumes the `args` vector to iterate through each String
    for arg in args {
        // 1a. Your task: handle the command-line arguments!
        //
        // - If arg is "sum", then call the sum() function
        // - If arg is "double", then call the double() function
        // - If arg is anything else, then call the count() function, passing "arg" to it.
        if arg == "sum"{
            sum();
        } else if arg == "double" {
            double();
        } else {
            count(arg);
        }


        // 1b. Now try passing "sum", "double" and "bananas" to the program by adding your argument
        // after "cargo run".  For example "cargo run sum"
    }
}

fn sum() {
    let mut sum = 0;
    // 2. Use a "for loop" to iterate through integers from 7 to 23 *inclusive* using a range
    // and add them all together (increment the `sum` variable).  Hint: You should get 255
    // Run it with `cargo run sum`

    for i in 7..=23 {
        sum += i;
    }


    println!("The sum is {}", sum);
}

fn double() {
    let mut count = 0;
    let mut x = 1;
    // 3. Use a "while loop" to count how many times you can double the value of `x` (multiply `x`
    // by 2) until `x` is larger than 500.  Increment `count` each time through the loop. Run it
    while x <= 500 {
        x *= 2;
        count+=1;
    }
    // with `cargo run double`  Hint: The answer is 9 times.


    println!("You can double x {} times until x is larger than 500", count);
}

fn count(arg: String) {
    // Challenge: Use an unconditional loop (`loop`) to print `arg` 8 times, and then break.
    // You will need to count your loops, somehow.  Run it with `cargo run bananas`
    let mut count = 0;
    
    'myLoop: loop {
        print!("{} ", arg);
        count += 1;
        if count == 8{
            break 'myLoop;
        }
    }
     // Execute this line 8 times, and then break. `print!` doesn't add a newline.


    println!(); // This will output just a newline at the end for cleanliness.
}

```



### ownership_reference

```rust
// Silence some warnings so they don't distract from the exercise.
#![allow(unused_mut, unused_variables)]

fn main() {
    // This fancy stuff either gets the first argument as a String, or prints
    // usage and exits if an argument was not supplied to the program.
    let mut arg: String = std::env::args().nth(1).unwrap_or_else(|| {
        println!("Please supply an argument to this program.");
        std::process::exit(-1);
    });

    // 1. Write a function `inspect` that takes a reference to a String, returns nothing, but
    // prints whether the contents of the String is plural or singular. Then uncomment and run this
    // code with `cargo run apple` and `cargo run apples'.  Hint: use `.ends_with("s")` on the
    // String reference
    //
    inspect(&arg);

    // 2. Write a function `change` that takes a *mutable* reference to a String and adds an "s" to
    // the String if it doesn't already end with "s". Then uncomment and run the code below with
    // `cargo run apple`.  Hint: use `.push_str("s")` on the mutable String reference to add an "s".
    //
    change(&mut arg);
    println!("I have many {}", arg);

    // 3. Write a function `eat` that accepts ownership of (consumes) a String and returns a bool
    // indicating whether or not the String both starts with a "b" AND contains an "a".
    // Hint 1: use `.starts_with("b")` and `.contains("a")`
    // Hint 2: `&&` is the boolean "AND" operator
    //
    if eat(arg) {
        println!("Might be bananas");
    } else {
        println!("Not bananas");
    }

    // Try running this program with "boat", "banana", and "grapes" as the arguments :-)

    // Challenge: Write a function "bedazzle" that takes a mutable reference to a String and
    // ignores what is in the string and replaces the contents of the string with the String
    // "sparkly". Then uncomment the code below.
    //
    // Hint: You will need to dereference the mutable reference in order to assign it a
    // new value.
    //
    let mut material = "mud".to_string();
    println!("This material is just `{}`.", material);
    bedazzle(&mut material);
    println!("Wow! Now the material is `{}`!", material);
}


fn inspect( x: &str){
    if !x.ends_with("s"){
        println!("singular");
    } else {
        println!("plural");
    }
    
}

fn change( x: &mut String){

    if !x.ends_with("s"){
        x.push_str("s");
    } 
}

fn eat( x: String) -> bool {
    x.starts_with("b") && x.contains("a")
}

fn bedazzle (x : &mut String) {
    *x = String::from("sparkly");
}
```



### Collections_Enums

```rust
// Silence some warnings that could distract from the exercise
#![allow(unused_variables, unused_mut, dead_code)]

// Someone is shooting arrows at a target.  We need to classify the shots.
//
// 1a. Create an enum called `Shot` with variants:
// - `Bullseye`
// - `Hit`, containing the distance from the center (an f64)
// - `Miss`
enum Shot {
    Bullseye,
    Hit(f64),
    Miss,
}

// You will need to complete 1b as well before you will be able to run this program successfully.
impl Shot {
    // Here is a method for the `Shot` enum you just defined.
    // 1b. Implement this method to convert a Shot into points
        // - return 5 points if `self` is a `Shot::Bullseye`
        // - return 2 points if `self` is a `Shot::Hit(x)` where x < 3.0
        // - return 1 point if `self` is a `Shot::Hit(x)` where x >= 3.0
        // - return 0 points if `self` is a Miss
    
    fn points(self) -> i32 {
        match self {
           Shot::Bullseye => {
                5
            },
            Shot::Hit(x) => {
                if x < 3.0 {
                    2
                } else {
                    1
                }
            },
            Shot::Miss => {
                0
            },
        }
        
    }
}

fn main() {
    // Simulate shooting a bunch of arrows and gathering their coordinates on the target.
    let arrow_coords: Vec<Coord> = get_arrow_coords(5);
    let mut shots: Vec<Shot> = Vec::new();

    // 2. For each coord in arrow_coords:
    //
    //   A. Call `coord.print_description()`
    //   B. Append the correct variant of `Shot` to the `shots` vector depending on the value of
    //   `coord.distance_from_center()`
    //      - Less than 1.0 -- `Shot::Bullseye`
    //      - Between 1.0 and 5.0 -- `Shot::Hit(value)`
    //      - Greater than 5.0 -- `Shot::Miss`

    for coord in arrow_coords {
        coord.print_description();
        let distance = coord.distance_from_center();
        if distance < 1.0 {
            shots.push(Shot::Bullseye)
        } else if distance >= 1.0 && distance < 5.0 {
            shots.push(Shot::Hit(distance))
        } else {
            shots.push(Shot::Miss)
        }
    }


    let mut total = 0;
    // 3. Finally, loop through each shot in shots and add its points to total
    for shot in shots {
        total += shot.points();
    }

    println!("Final point total is: {}", total);
}

// A coordinate of where an Arrow hit
#[derive(Debug)]
struct Coord {
    x: f64,
    y: f64,
}

impl Coord {
    fn distance_from_center(&self) -> f64 {
        (self.x.powf(2.0) + self.y.powf(2.0)).sqrt()
    }
    fn print_description(&self) {
        println!(
            "coord is {:.1} away, at ({:.1}, {:.1})",
            self.distance_from_center(),
            self.x,
            self.y);
    }

}

// Generate some random coordinates
fn get_arrow_coords(num: u32) -> Vec<Coord> {
    let mut coords: Vec<Coord> = Vec::new();
    for _ in 0..num {
        let coord = Coord {
            x: (rand::random::<f64>() - 0.5) * 12.0,
            y: (rand::random::<f64>() - 0.5) * 12.0,
        };
        coords.push(coord);
    }
    coords
}
```



### Closure Thread

```rust
// Silence some warnings so they don't distract from the exercise.
#![allow(dead_code, unused_imports, unused_variables)]
use crossbeam::channel;
use std::thread;
use std::time::Duration;

fn expensive_sum(v: Vec<i32>) -> i32 {
    pause_ms(500);
    println!("Child thread: just about finished");
    // 1a. Between the .iter() and the .sum() add a .filter() with a closure to keep any even
    // number (`x % 2` will be 0 for even numbers).
    // 1b. Between the .filter() and the .sum() add a .map() with a closure to square the values
    // (multiply them by themselves)
    //
    // In the closures for both the .filter() and .map() the argument will be a reference, so you'll
    // either need to dereference the argument once in the parameter list like this: `|&x|` or you
    // will need to dereference it each time you use it in the expression like this: `*x`
    v.iter()
        .filter(|x| *x%2==0) // .filter() goes here
        .map(|&x| x*x) // .map() goes here
        .sum()
}

fn pause_ms(ms: u64) {
    thread::sleep(Duration::from_millis(ms));
}

fn main() {
    let my_vector = vec![2, 5, 1, 0, 4, 3];

    // 2. Spawn a child thread and have it call `expensive_sum(my_vector)`.  Store the returned
    // join handle in a variable called `handle`. Once you've done this you should be able to run
    // the code and see the Child thread output in the middle of the main thread's letters
    //
    let handle = thread::spawn(move || {
        expensive_sum(my_vector)
    });

    // While the child thread is running, the main thread will also do some work
    for letter in vec!["a", "b", "c", "d", "e", "f"] {
        println!("Main thread: Letter {}", letter);
        pause_ms(200);
    }

    // 3. Let's retrieve the value returned by the child thread once it has exited.  Using the
    // `handle` variable you stored the join handle in earlier, call .join() to wait for the thread
    // to exit with a `Result<i32, Err>`.  Get the i32 out of the result and store it in a `sum`
    // variable.  Uncomment the println.  If you did 1a and 1b correctly, the sum should be 20.
    //
    let result = handle.join();
    let sum: i32 = if result.is_ok() {
        result.unwrap()
    } else {
        -1
    };
    
    println!("The child thread's expensive sum is {:?}", sum);

    // Time for some fun with threads and channels!  Though there is a primitive type of channel
    // in the std::sync::mpsc module, I recommend always using channels from the crossbeam crate,
    // which is what we will use here.
    //
    // 4. Uncomment the block comment below (Find and remove the `/*` and `*/`).  Examine how the
    // flow of execution works.  Once you understand it, alter the values passed to the `pause_ms()`
    // calls so that both the "Thread B" outputs occur before the "Thread A" outputs.

    
    let (tx, rx) = channel::unbounded(); // Sender<i32>, Receiver<i32>
    // Cloning a channel makes another variable connected to that end of the channel so that you can
    // send it to another thread.
    let tx2 = tx.clone();

    let handle_a = thread::spawn(move || {
        pause_ms(200);
        tx2.send("Thread A: 1").unwrap();
        pause_ms(200);
        tx2.send("Thread A: 2").unwrap();
    });

    pause_ms(100); // Make sure Thread A has time to get going before we spawn Thread B

    let handle_b = thread::spawn(move || {
        pause_ms(0);
        tx.send("Thread B: 1").unwrap();
        pause_ms(0);
        tx.send("Thread B: 2").unwrap();
    });

    // Using a Receiver channel as an iterator is a convenient way to get values until the channel
    // gets closed.  A Receiver channel is automatically closed once all Sender channels have been
    // closed.  Both our threads automatically close their Sender channels when they exit and the
    // destructors for the channels get automatically called.
    for msg in rx { // sending sideê°€ ì „ë¶€ ë‹«íˆê¸° ì „ê¹Œì§€ ê³„ì† loopë¥¼ ëŒê³  ìˆìŒ
        println!("Main thread: Received {}", msg);
    }

    // Join the child threads for good hygiene.
    handle_a.join().unwrap();
    handle_b.join().unwrap();
    

    // Challenge: Make two child threads and give them each a receiving end to a channel.  From the
    // main thread loop through several values and print each out and then send it to the channel.
    // On the child threads print out the values you receive. Close the sending side in the main
    // thread by calling `drop(tx)` (assuming you named your sender channel variable `tx`).  Join
    // the child threads.
    println!("Main thread: Exiting.");

    let (ts, tr) = channel::unbounded();
    let tr2 = tr.clone();

    for i in vec![2,4,6,8,10] {
        println!("{}", i);
        ts.send(i).unwrap();
    }
    drop(ts);

    let handle_c = thread::spawn( || {
        for msg in tr2 {
            pause_ms(200);
            println!("thread c: Received {}", msg);
        }
    });

    let handle_d = thread::spawn( || {
        for msg in tr {
            pause_ms(200);
            println!("thread d: Received {}", msg);
        }
    });
    handle_c.join().unwrap();
    handle_d.join().unwrap();

}

```

