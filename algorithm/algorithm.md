# 알고리즘

## 목차

- 알고리즘
- 그리디 알고리즘
- 너비 우선 탐색
- 동적 계획법
- 모듈러 증명
- 백트래킹
- 보이어-무어
- 브루트포스
- 이진 검색(Binary Search)
- 조합
- 호제법



## 알고리즘

### 알고리즘

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법



### 알고리즘 효율 <=> 복잡도

- 시간적 효율성
  - 하드웨어와 소프트웨어 환경에 따라 다름 => 분석 힘듦
- 공간적 효율성
  - O (Big-Oh) 표기
    - 점근적 상한 
    - n이 증가함에 따라 n0보다 큰 n에 대해서 O(g(n))이 f(n)보다 항상 큼
    - O(n^2) : 단순히 실행시간이 n^2에 비례 하는 알고리즘
  - Ω (Big-Omega) 표기
    - 점근적 하한
    - 최소한 이만한 시간은 걸린다
  - Θ (Theta) 표기
    - O-표기와 Ω-표기가 같은 경우에 사용



## 그리디 알고리즘

- 그리디 알고리즘은 전체 수를 탐색하지 않고, 각 단계에서 가장 최선의 선택을 하는 기법이다. 동적 계획법의 효율성 문제에서 고안되었으며, 모든 문제에서 최선의 해를 도출하진 못한다. 

- 그리디 알고리즘을 사용하기 위해서는, `원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해` 임을 증명

- Top-down 방식



## 너비 우선 탐색 (Breadth First Search)

​	탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문한다.

​	큐를 통한 구현

1. 큐에 시작점 in
2. 큐 맨 앞 pop  
3. 해당 노드에서 할 일 처리하고 해당 노드 방문 표시
4. 해당 노드와 연결된 정점들 중 방문 x 정점들은 큐에 in
5. 큐가 빌 때까지 2~4 과정 반복



## 동적 계획법

  동적 계획법이란 복잡한 문제를 간단한 여러 개의 하위 문제로 나누어 푼 다음, 이것을 결합하여 최종 목적을 달성하는 방법이다. 각 하위 문제의 결과 값을 저장해 둠으로써, 반복되는 하위 문제를 빠르게 해결함으로써 계산 횟수를 줄인다. 

 

## 모듈러 증명

- 성질 1

```
(a + b) % m = ((a % m) + (b % m)) % m
```

- 성질 2

```
(a * b) % m = ((a % m) * (b % m)) % m
```



## 보이어-무어

​	문자열에서 패턴 찾기에 활용되는 알고리즘이다. 문자열 비교는 앞부분보다 뒷부분에서 불일치가 일어날 확률이 높다는 성질을 활용한다. 그래서 패턴의 오른쪽 부터 비교를 시작한다. 수행 순서는 다음과 같다.

1. 패턴의 마지막 인덱스의 글자와 본문에서 같은 인덱스에 있는 글자를 비교합니다.
2. 만약 둘 글자가 같다면, 앞의 글자들을 차례대로 같은지 확인합니다.
3. 만약 같지 않고, 본문의 글자가 패턴에 존재하지 않는다면, 패턴의 길이만큼 패턴을 이동시킵니다.
4. 만약 같지 않고, 본문의 글자가 패턴에 존재한다면, 패턴의 오른쪽 끝에서부터 그 문자까지의 칸 수를 세서 그만큼 이동합니다.
5. 이를 반복하며 문자열 끝까지 탐색합니다.



## 백트래킹

 기본적으로 `가능한 모든 방법`을 `효율적으로 탐색` 하는 기법.  대표적인 완전 탐색 방법으로는 깊이 우선 탐석(DFS)가 있지만, 목표 지점에 도달할 가능성이 없는 곳도 탐색한다는 단점이 존재한다. 이에 백트래킹은 가지치기를 통해 `가능성이 있는` 루트만 고려하는 기법

 `수행순서`

1. DFS 수행

2. 유망한 노드 검토 

   : 유망하면 서브트리로 이동 , 유망하지 않으면 백트래킹 수행



## 브루트 포스

- 완전 검색으로 모든 경우의 수를 생성하고 테스트 => 설계가 간단하고 정확도 높음 but 느림
- **우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘 사용하고 해답을 확인하는 것이 바람직**



## 이진 검색

​	자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 검색하고 검색을 계속 진행. 단, 자료가 **정렬**된 상태여야 함





## 조합

- 1번 성질

$$
 _{n+1}\mathrm{C}_{r+1} =  _{n}\mathrm{C}_{r} +  _{n}\mathrm{C}_{r+1}
$$

- 2번 성질

$$
_{n}\mathrm{C}_{0} =  _{n}\mathrm{C}_{n} = 1
$$





## 호제법

 2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 [나머지](https://ko.wikipedia.org/wiki/나머지)를 r이라 하면(단, a>b), a와 b의 최대공약수는 b와 r의 최대공약수와 같다.

```java
 public static int gcd(int p, int q)
 {
	if (q == 0) return p;
	return gcd(q, p%q);
 }
```

