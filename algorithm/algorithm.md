# 알고리즘

## 목차

- 그리디 알고리즘
- 너비 우선 탐색
- 동적 계획법
- 모듈러 증명
- 백트래킹
- 보이어-무어
- 이진 검색(Binary Search)
- 조합
- 호제법



## 그리디 알고리즘

 그리디 알고리즘은 전체 수를 탐색하지 않고, 각 단계에서 가장 최선의 선택을 하는 기법이다. 동적 계획법의 효율성 문제에서 고안되었으며, 모든 문제에서 최선의 해를 도출하진 못한다. 



## 너비 우선 탐색 (Breadth First Search)

​	탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문한다.

​	큐를 통한 구현

1. 큐에 시작점 in
2. 큐 맨 앞 pop  
3. 해당 노드에서 할 일 처리하고 해당 노드 방문 표시
4. 해당 노드와 연결된 정점들 중 방문 x 정점들은 큐에 in
5. 큐가 빌 때까지 2~4 과정 반복



## 동적 계획법

  동적 계획법이란 복잡한 문제를 간단한 여러 개의 하위 문제로 나누어 푼 다음, 이것을 결합하여 최종 목적을 달성하는 방법이다. 각 하위 문제의 결과 값을 저장해 둠으로써, 반복되는 하위 문제를 빠르게 해결함으로써 계산 횟수를 줄인다. 

 

## 모듈러 증명

- 성질 1

```
(a + b) % m = ((a % m) + (b % m)) % m
```

- 성질 2

```
(a * b) % m = ((a % m) * (b % m)) % m
```



## 보이어-무어

​	문자열에서 패턴 찾기에 활용되는 알고리즘이다. 문자열 비교는 앞부분보다 뒷부분에서 불일치가 일어날 확률이 높다는 성질을 활용한다. 그래서 패턴의 오른쪽 부터 비교를 시작한다. 수행 순서는 다음과 같다.

1. 패턴의 마지막 인덱스의 글자와 본문에서 같은 인덱스에 있는 글자를 비교합니다.
2. 만약 둘 글자가 같다면, 앞의 글자들을 차례대로 같은지 확인합니다.
3. 만약 같지 않고, 본문의 글자가 패턴에 존재하지 않는다면, 패턴의 길이만큼 패턴을 이동시킵니다.
4. 만약 같지 않고, 본문의 글자가 패턴에 존재한다면, 패턴의 오른쪽 끝에서부터 그 문자까지의 칸 수를 세서 그만큼 이동합니다.
5. 이를 반복하며 문자열 끝까지 탐색합니다.



## 백트래킹

 기본적으로 `가능한 모든 방법`을 `효율적으로 탐색` 하는 기법.  대표적인 완전 탐색 방법으로는 깊이 우선 탐석(DFS)가 있지만, 목표 지점에 도달할 가능성이 없는 곳도 탐색한다는 단점이 존재한다. 이에 백트래킹은 가지치기를 통해 `가능성이 있는` 루트만 고려하는 기법

 `수행순서`

1. DFS 수행

2. 유망한 노드 검토 

   : 유망하면 서브트리로 이동 , 유망하지 않으면 백트래킹 수행



## 이진 검색

​	자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 검색하고 검색을 계속 진행. 단, 자료가 **정렬**된 상태여야 함





## 조합

- 1번 성질

$$
 _{n+1}\mathrm{C}_{r+1} =  _{n}\mathrm{C}_{r} +  _{n}\mathrm{C}_{r+1}
$$

- 2번 성질

$$
_{n}\mathrm{C}_{0} =  _{n}\mathrm{C}_{n} = 1
$$





## 호제법

 2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 [나머지](https://ko.wikipedia.org/wiki/나머지)를 r이라 하면(단, a>b), a와 b의 최대공약수는 b와 r의 최대공약수와 같다.

```java
 public static int gcd(int p, int q)
 {
	if (q == 0) return p;
	return gcd(q, p%q);
 }
```

